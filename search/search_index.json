{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Documentation"},{"location":"api/","text":"Introduction \u00b6 This is a reference guide for the available Core APIs. APIs expose different resources and data provided by the Core Server (Node). Based on the Core Server configuration (enabled core modules) we can configure different array of services, such as: Public REST API Webhook API info Each Core server (node) has its own internal blockchain and state, meaning it may have forked or be out of sync, causing queries to fail. Monitor your node by comparing it to different public nodes, such as the official Mainnet or Testnet Explorer to ensure you are in sync. Mainnet Explorer - explorer.solar.org Testnet Explorer - texplorer.solar.org","title":"Introduction"},{"location":"api/#introduction","text":"This is a reference guide for the available Core APIs. APIs expose different resources and data provided by the Core Server (Node). Based on the Core Server configuration (enabled core modules) we can configure different array of services, such as: Public REST API Webhook API info Each Core server (node) has its own internal blockchain and state, meaning it may have forked or be out of sync, causing queries to fail. Monitor your node by comparing it to different public nodes, such as the official Mainnet or Testnet Explorer to ensure you are in sync. Mainnet Explorer - explorer.solar.org Testnet Explorer - texplorer.solar.org","title":"Introduction"},{"location":"api/public-rest-api/endpoints/","text":"Endpoints \u00b6 See the full interactive list of API endpoints via the following links: Mainnet - api.solar.org Testnet - tapi.solar.org","title":"Endpoints"},{"location":"api/public-rest-api/endpoints/#endpoints","text":"See the full interactive list of API endpoints via the following links: Mainnet - api.solar.org Testnet - tapi.solar.org","title":"Endpoints"},{"location":"api/public-rest-api/getting-started/","text":"Getting Started \u00b6 tip All HTTP requests have to be sent with the Content-Type: application/json header. If the header is not present it will result in malformed responses or request rejections. This is the reference guide for the Public API. This API exposes all resources and data provided by a Solar Core node and is the preferred way of interacting with the Solar Network. info Each Core server (node) has its own internal blockchain and state, meaning it may have forked or be out of sync, causing queries to fail. Monitor your node by comparing it to different public nodes, such as the official Mainnet or Testnet Explorer to ensure you are in sync. Mainnet Explorer - explorer.solar.org Testnet Explorer - texplorer.solar.org If you have any problems or requests, please open an issue . Pagination \u00b6 Requests that return multiple items will be paginated to 100 items by default. You can specify further pages with the ?page parameter. For some resources, you can also set a custom page size up to 100 with the ?limit parameter. Note that for technical reasons not all endpoints respect the ?limit parameter. Public Testing Relay \u00b6 If you are not running a relay yourself you can test API calls using: Mainnet API api.solar.org Testnet API tapi.solar.org Self-Hosted Relay Port \u00b6 When running a self-hosted Core relay instance, the default API port is 6003 (e.g., <your_relay's_ip>:6003/api ). Be sure to configure your firewall appropriately. warning It's strongly advised to only enable API access on a relay node and never on a delegate forging node. Happy Developing!","title":"Getting Started"},{"location":"api/public-rest-api/getting-started/#getting-started","text":"tip All HTTP requests have to be sent with the Content-Type: application/json header. If the header is not present it will result in malformed responses or request rejections. This is the reference guide for the Public API. This API exposes all resources and data provided by a Solar Core node and is the preferred way of interacting with the Solar Network. info Each Core server (node) has its own internal blockchain and state, meaning it may have forked or be out of sync, causing queries to fail. Monitor your node by comparing it to different public nodes, such as the official Mainnet or Testnet Explorer to ensure you are in sync. Mainnet Explorer - explorer.solar.org Testnet Explorer - texplorer.solar.org If you have any problems or requests, please open an issue .","title":"Getting Started"},{"location":"api/public-rest-api/getting-started/#pagination","text":"Requests that return multiple items will be paginated to 100 items by default. You can specify further pages with the ?page parameter. For some resources, you can also set a custom page size up to 100 with the ?limit parameter. Note that for technical reasons not all endpoints respect the ?limit parameter.","title":"Pagination"},{"location":"api/public-rest-api/getting-started/#public-testing-relay","text":"If you are not running a relay yourself you can test API calls using: Mainnet API api.solar.org Testnet API tapi.solar.org","title":"Public Testing Relay"},{"location":"api/public-rest-api/getting-started/#self-hosted-relay-port","text":"When running a self-hosted Core relay instance, the default API port is 6003 (e.g., <your_relay's_ip>:6003/api ). Be sure to configure your firewall appropriately. warning It's strongly advised to only enable API access on a relay node and never on a delegate forging node. Happy Developing!","title":"Self-Hosted Relay Port"},{"location":"api/public-rest-api/modify-response/","text":"Modify API Response \u00b6 In some cases users wants to alter existing HTTP API responses, by removing excess fields, changing content or modify result in any other way. In this chapter we will go trough process step by step and describe how to remove explorer property from the /node/configuration route accessible on GET method. { \"data\" : { \"symbol\" : \"tSXP\" , \"explorer\" : \"http://texplorer.solar.org\" , \"version\" : 30 , } } Desired response : { \"data\" : { \"symbol\" : \"tSXP\" , \"version\" : 30 , } } Process \u00b6 Get route \u00b6 First we need get existing route object that we want to modify. Be aware there can be two Server instances accessible via Identifiers.HTTP or Identifiers.HTTPS symbols. Each Server instance expose getRoute method which is used for obtaining ServerRoute . const route = this . app . get < Server > ( Identifiers . HTTP ). getRoute ( \"GET\" , \"/api/node/configuration\" ); Keep original handler \u00b6 Save the reference to existing handler. Use bind() function to bind original object which method belongs to, otherwise you will lose this reference if one is used inside the handler. const originalHandler = route . settings . handler . bind ( route . settings . bind ); Create new handler \u00b6 Replace route handler with new wrapper function. New function will call original handler and set desired property to undefined . JSON standard defined that undefined properties are not included in stringified response, which will result as removed field in response body. Finally return modified response. route . settings . handler = async ( request : Hapi.Request , h : Hapi.ResponseToolkit ) => { const response = await originalHandler ( arguments ); response . data . explorer = undefined ; return response ; }; API \u00b6 Methods \u00b6 Server.getRoute(method: string , path: string ) : ServerRoute | undefined \u00b6 Parameters : method - HTTP method eg. \"GET\", \"POST\" path - route path eg. \"/api/node/configuration\" Response : Returns ServerRoute object or undefined . Complete code sample \u00b6 // Import import Hapi from \"@hapi/hapi\" ; // Modify route const route = this . app . get < Server > ( Identifiers . HTTP ). getRoute ( \"GET\" , \"/api/node/configuration\" ); if ( route ) { const originalHandler = route . settings . handler . bind ( route . settings . bind ); route . settings . handler = async ( request : Hapi.Request , h : Hapi.ResponseToolkit ) => { const response = await originalHandler ( arguments ); response . data . explorer = undefined ; return response ; }; } Additional reading \u00b6 Hapi official documentation","title":"Modify API Response"},{"location":"api/public-rest-api/modify-response/#modify-api-response","text":"In some cases users wants to alter existing HTTP API responses, by removing excess fields, changing content or modify result in any other way. In this chapter we will go trough process step by step and describe how to remove explorer property from the /node/configuration route accessible on GET method. { \"data\" : { \"symbol\" : \"tSXP\" , \"explorer\" : \"http://texplorer.solar.org\" , \"version\" : 30 , } } Desired response : { \"data\" : { \"symbol\" : \"tSXP\" , \"version\" : 30 , } }","title":"Modify API Response"},{"location":"api/public-rest-api/modify-response/#process","text":"","title":"Process"},{"location":"api/public-rest-api/modify-response/#get-route","text":"First we need get existing route object that we want to modify. Be aware there can be two Server instances accessible via Identifiers.HTTP or Identifiers.HTTPS symbols. Each Server instance expose getRoute method which is used for obtaining ServerRoute . const route = this . app . get < Server > ( Identifiers . HTTP ). getRoute ( \"GET\" , \"/api/node/configuration\" );","title":"Get route"},{"location":"api/public-rest-api/modify-response/#keep-original-handler","text":"Save the reference to existing handler. Use bind() function to bind original object which method belongs to, otherwise you will lose this reference if one is used inside the handler. const originalHandler = route . settings . handler . bind ( route . settings . bind );","title":"Keep original handler"},{"location":"api/public-rest-api/modify-response/#create-new-handler","text":"Replace route handler with new wrapper function. New function will call original handler and set desired property to undefined . JSON standard defined that undefined properties are not included in stringified response, which will result as removed field in response body. Finally return modified response. route . settings . handler = async ( request : Hapi.Request , h : Hapi.ResponseToolkit ) => { const response = await originalHandler ( arguments ); response . data . explorer = undefined ; return response ; };","title":"Create new handler"},{"location":"api/public-rest-api/modify-response/#api","text":"","title":"API"},{"location":"api/public-rest-api/modify-response/#methods","text":"","title":"Methods"},{"location":"api/public-rest-api/modify-response/#servergetroutemethod-string-path-string-serverroute-undefined","text":"Parameters : method - HTTP method eg. \"GET\", \"POST\" path - route path eg. \"/api/node/configuration\" Response : Returns ServerRoute object or undefined .","title":"Server.getRoute(method: string, path: string) : ServerRoute | undefined"},{"location":"api/public-rest-api/modify-response/#complete-code-sample","text":"// Import import Hapi from \"@hapi/hapi\" ; // Modify route const route = this . app . get < Server > ( Identifiers . HTTP ). getRoute ( \"GET\" , \"/api/node/configuration\" ); if ( route ) { const originalHandler = route . settings . handler . bind ( route . settings . bind ); route . settings . handler = async ( request : Hapi.Request , h : Hapi.ResponseToolkit ) => { const response = await originalHandler ( arguments ); response . data . explorer = undefined ; return response ; }; }","title":"Complete code sample"},{"location":"api/public-rest-api/modify-response/#additional-reading","text":"Hapi official documentation","title":"Additional reading"},{"location":"api/public-rest-api/troubleshooting/","text":"Troubleshooting \u00b6 If you're encountering some oddities in the API, here's a list of resolutions to some of the problems you may be experiencing. Why Am I Getting a 404 Error on a Resource That Exists? \u00b6 tip All HTTP requests have to be sent with the Content-Type: application/json header. If the header is not present it will result in malformed responses or request rejections. Typically, this means that the node you are sending your requests to is out of sync and missing data that exists on other nodes that are in sync. To troubleshoot, ensure you're querying a node that is in sync, and third-party application restrictions are not blocking access. Querying the public Mainnet API is usually a good start. Why Am I Not Seeing All My Results? \u00b6 Most API calls accessing a list of resources (e.g., blocks and transactions) support pagination. If you're making requests and receiving an incomplete set of results, you're probably only seeing the first page. You'll need to request the remaining pages to get more results. It's important not to try to guess the format of the pagination URL. Not every API call uses the same structure. Instead, extract the pagination information from the meta field, which is sent with every request. My Node Is Running, but API Keeps Returning CONNECTION REFUSED ? \u00b6 Note that the Public API is only available after a node has fully synced. This ensures your data on the blockchain is up to date. A full sync may take up to 15h, depending on your hardware configuration and network speed. If your node is synced and you still get CONNECTION_REFUSED error, please check your firewall configuration and if needed whitelist your client.","title":"Troubleshooting"},{"location":"api/public-rest-api/troubleshooting/#troubleshooting","text":"If you're encountering some oddities in the API, here's a list of resolutions to some of the problems you may be experiencing.","title":"Troubleshooting"},{"location":"api/public-rest-api/troubleshooting/#why-am-i-getting-a-404-error-on-a-resource-that-exists","text":"tip All HTTP requests have to be sent with the Content-Type: application/json header. If the header is not present it will result in malformed responses or request rejections. Typically, this means that the node you are sending your requests to is out of sync and missing data that exists on other nodes that are in sync. To troubleshoot, ensure you're querying a node that is in sync, and third-party application restrictions are not blocking access. Querying the public Mainnet API is usually a good start.","title":"Why Am I Getting a 404 Error on a Resource That Exists?"},{"location":"api/public-rest-api/troubleshooting/#why-am-i-not-seeing-all-my-results","text":"Most API calls accessing a list of resources (e.g., blocks and transactions) support pagination. If you're making requests and receiving an incomplete set of results, you're probably only seeing the first page. You'll need to request the remaining pages to get more results. It's important not to try to guess the format of the pagination URL. Not every API call uses the same structure. Instead, extract the pagination information from the meta field, which is sent with every request.","title":"Why Am I Not Seeing All My Results?"},{"location":"api/public-rest-api/troubleshooting/#my-node-is-running-but-api-keeps-returning-connection-refused","text":"Note that the Public API is only available after a node has fully synced. This ensures your data on the blockchain is up to date. A full sync may take up to 15h, depending on your hardware configuration and network speed. If your node is synced and you still get CONNECTION_REFUSED error, please check your firewall configuration and if needed whitelist your client.","title":"My Node Is Running, but API Keeps Returning CONNECTION REFUSED?"},{"location":"api/webhook-api/endpoints/","text":"Endpoints \u00b6 List All Webhooks \u00b6 The webhooks resource returns all enabled and disabled webhooks. There is thus no need to store all active webhooks client side; as the node maintains a register for you. Endpoint \u00b6 GET /api/webhooks Query Parameters \u00b6 Name Type Description Required page int The number of the page that will be returned. No limit int The number of resources per page. No Response \u00b6 { \"meta\" : { \"count\" : 29 , \"pageCount\" : 1 , \"totalCount\" : 29 , \"next\" : null , \"previous\" : null , \"self\" : \"/api/v2/webhooks?page=1&limit=100\" , \"first\" : \"/api/v2/webhooks?page=1&limit=100\" , \"last\" : \"/api/v2/webhooks?page=1&limit=100\" }, \"data\" : [ { \"id\" : \"4b255244-a535-4aca-aa92-9ff9e02c98dd\" , \"event\" : \"block.forged\" , \"target\" : \"https://httpbin.org/post\" , \"enabled\" : true , \"conditions\" : [ { \"key\" : \"generatorPublicKey\" , \"condition\" : \"eq\" , \"value\" : \"032fcfd19f0e095bf46bd3ada87e283720c405249b1be1a70bad1d5f20095a8515\" } ] } ] } Retrieve a Webhook \u00b6 It is possible to query for a specific webhook by ID, which has to be saved client-side or obtained from another API call. Endpoint \u00b6 GET /api/webhooks/ { id } Path Parameters \u00b6 Name Type Description Required id string The identifier of the webhook to be retrieved. Yes Response \u00b6 { \"data\" : { \"id\" : \"4b255244-a535-4aca-aa92-9ff9e02c98dd\" , \"event\" : \"block.forged\" , \"target\" : \"https://httpbin.org/post\" , \"enabled\" : true , \"conditions\" : [ { \"key\" : \"generatorPublicKey\" , \"condition\" : \"eq\" , \"value\" : \"032fcfd19f0e095bf46bd3ada87e283720c405249b1be1a70bad1d5f20095a8515\" } ] } } Create a Webhook \u00b6 It is recommended to have a backend service running that will handle your webhook calls, as you'll have to provide a target value when creating the webhook. To give you an idea of how this works, we created a couple of example setups that you can use or get inspiration from. A webhook may be triggered by multiple conditions; as long as one of the conditions evaluates to true , the webhook will fire. The returned token should be saved and used to validate the webhook origin. It is a secret value which should not be shared. For extra security, whitelist the IP of the node with your target service, ensuring other parties are not able to post webhook payloads. The conditions lists consists of an array of objects, with the following properties: key : the key used on the object that is passed along with the specified event condition : a condition used to check the value against value : (Optional) a value used to check the key against. This is not needed for the falsy and truthy conditions. In case of between and not-between , you'll have to provide an object like this: \"value\": { \"min\": \"someValue\", \"max\": \"someValue\" } Endpoint \u00b6 POST /api/webhooks Body Parameters \u00b6 Name Type Description Required event string The name of the event to be listened for. Yes target string The target URL for the HTTP payload. Yes enabled string The value to enable or disable the webhook. No conditions array The list of conditions required to trigger the webhook. Yes Response \u00b6 { \"data\" : { \"id\" : \"4b255244-a535-4aca-aa92-9ff9e02c98dd\" , \"event\" : \"block.forged\" , \"target\" : \"https://httpbin.org/post\" , \"token\" : \"7e66949f67b36c34a05eeb3a866957b3f1b6f8947fb215500b78e5091d4e484a\" , \"enabled\" : true , \"conditions\" : [ { \"key\" : \"generatorPublicKey\" , \"condition\" : \"eq\" , \"value\" : \"032fcfd19f0e095bf46bd3ada87e283720c405249b1be1a70bad1d5f20095a8515\" } ] } } Events \u00b6 Event Description Implemented block.applied Fires when a block is saved Yes block.disregarded Fires when a block is disregarded Yes block.forged Fires when a block is forged Yes block.received Fires when a block is incoming Yes block.reverted Fires when a block is removed from the database (e.g. on a rollback) Yes delegate.registered Fires when a new delegate is registered Yes delegate.resigned Fires when a delegate resigns Yes forger.failed Fires when the forger module fails to start Yes forger.missing Fires when it is detected that the forger module isn't running Yes forger.started Fires when the forger module forges a new block No peer.added Fires when a peer is added Yes peer.removed Fires when a peer is removed Yes round.created Fires when a new round is created and saved to the database Yes state:started No transaction.applied Fires when a transaction is saved Yes transaction.expired Fires when an unconfirmed transaction expires Yes transaction.forged Fires when a transaction is forged by a delegate Yes transaction.pool.added Fires when transactions are added to the transaction pool Yes transaction.pool.rejected Fires when transactions are rejected and not added to the transaction pool Yes transaction.pool.removed Fires when a transaction is removed from the transaction pool by its ID Yes transaction.reverted Fires when a transaction is removed from the database No wallet.saved Fires when a wallet is updated (e.g. its balance changed, voted etc) Yes wallet.created.cold Fires when a wallet that never existed before is saved (e.g. received its first tx) Yes Conditions \u00b6 Condition Description between Check if the given value is between min and max contains Check if A contains B eq Check if A equals B falsy Check if the given value is false gt Check if A is greater than B gte Check if A is greater than or equal to B lt Check if A is lesser than B lte Check if A is lesser than or equal to B ne Check if A does not equal B not-between Check if the given value is not between min and max regexp Check if the given value matches truthy Check if the given value is true Update a Webhook \u00b6 Existing webhooks may be updated. Note that this is the equivalent of deleting and creating a webhook; but retaining the same token . If you are often updating and creating webhooks; consider deleting and creating new webhooks instead of updating to rotate your validation token often. Endpoint \u00b6 PUT /api/webhooks/ { id } Path Parameters \u00b6 Name Type Description Required id string The identifier of the webhook to be updated. Yes Body Parameters \u00b6 Name Type Description Required event string The name of the event to be listened for. No target string The target URL for the HTTP payload. No enabled string The value to enable or disable the webhook. No conditions array The list of conditions required to trigger the webhook. No Response \u00b6 HTTP / 1.1 204 No Content {} Delete a Webhook \u00b6 A webhook may be deleted by ID. Delete unused webhooks to save machine resources. Endpoint \u00b6 DELETE /api/webhooks/ { id } Path Parameters \u00b6 Name Type Description Required id string The identifier of the webhook to be deleted. Yes Response \u00b6 HTTP / 1.1 204 No Content {}","title":"Endpoints"},{"location":"api/webhook-api/endpoints/#endpoints","text":"","title":"Endpoints"},{"location":"api/webhook-api/endpoints/#list-all-webhooks","text":"The webhooks resource returns all enabled and disabled webhooks. There is thus no need to store all active webhooks client side; as the node maintains a register for you.","title":"List All Webhooks"},{"location":"api/webhook-api/endpoints/#endpoint","text":"GET /api/webhooks","title":"Endpoint"},{"location":"api/webhook-api/endpoints/#query-parameters","text":"Name Type Description Required page int The number of the page that will be returned. No limit int The number of resources per page. No","title":"Query Parameters"},{"location":"api/webhook-api/endpoints/#response","text":"{ \"meta\" : { \"count\" : 29 , \"pageCount\" : 1 , \"totalCount\" : 29 , \"next\" : null , \"previous\" : null , \"self\" : \"/api/v2/webhooks?page=1&limit=100\" , \"first\" : \"/api/v2/webhooks?page=1&limit=100\" , \"last\" : \"/api/v2/webhooks?page=1&limit=100\" }, \"data\" : [ { \"id\" : \"4b255244-a535-4aca-aa92-9ff9e02c98dd\" , \"event\" : \"block.forged\" , \"target\" : \"https://httpbin.org/post\" , \"enabled\" : true , \"conditions\" : [ { \"key\" : \"generatorPublicKey\" , \"condition\" : \"eq\" , \"value\" : \"032fcfd19f0e095bf46bd3ada87e283720c405249b1be1a70bad1d5f20095a8515\" } ] } ] }","title":"Response"},{"location":"api/webhook-api/endpoints/#retrieve-a-webhook","text":"It is possible to query for a specific webhook by ID, which has to be saved client-side or obtained from another API call.","title":"Retrieve a Webhook"},{"location":"api/webhook-api/endpoints/#endpoint_1","text":"GET /api/webhooks/ { id }","title":"Endpoint"},{"location":"api/webhook-api/endpoints/#path-parameters","text":"Name Type Description Required id string The identifier of the webhook to be retrieved. Yes","title":"Path Parameters"},{"location":"api/webhook-api/endpoints/#response_1","text":"{ \"data\" : { \"id\" : \"4b255244-a535-4aca-aa92-9ff9e02c98dd\" , \"event\" : \"block.forged\" , \"target\" : \"https://httpbin.org/post\" , \"enabled\" : true , \"conditions\" : [ { \"key\" : \"generatorPublicKey\" , \"condition\" : \"eq\" , \"value\" : \"032fcfd19f0e095bf46bd3ada87e283720c405249b1be1a70bad1d5f20095a8515\" } ] } }","title":"Response"},{"location":"api/webhook-api/endpoints/#create-a-webhook","text":"It is recommended to have a backend service running that will handle your webhook calls, as you'll have to provide a target value when creating the webhook. To give you an idea of how this works, we created a couple of example setups that you can use or get inspiration from. A webhook may be triggered by multiple conditions; as long as one of the conditions evaluates to true , the webhook will fire. The returned token should be saved and used to validate the webhook origin. It is a secret value which should not be shared. For extra security, whitelist the IP of the node with your target service, ensuring other parties are not able to post webhook payloads. The conditions lists consists of an array of objects, with the following properties: key : the key used on the object that is passed along with the specified event condition : a condition used to check the value against value : (Optional) a value used to check the key against. This is not needed for the falsy and truthy conditions. In case of between and not-between , you'll have to provide an object like this: \"value\": { \"min\": \"someValue\", \"max\": \"someValue\" }","title":"Create a Webhook"},{"location":"api/webhook-api/endpoints/#endpoint_2","text":"POST /api/webhooks","title":"Endpoint"},{"location":"api/webhook-api/endpoints/#body-parameters","text":"Name Type Description Required event string The name of the event to be listened for. Yes target string The target URL for the HTTP payload. Yes enabled string The value to enable or disable the webhook. No conditions array The list of conditions required to trigger the webhook. Yes","title":"Body Parameters"},{"location":"api/webhook-api/endpoints/#response_2","text":"{ \"data\" : { \"id\" : \"4b255244-a535-4aca-aa92-9ff9e02c98dd\" , \"event\" : \"block.forged\" , \"target\" : \"https://httpbin.org/post\" , \"token\" : \"7e66949f67b36c34a05eeb3a866957b3f1b6f8947fb215500b78e5091d4e484a\" , \"enabled\" : true , \"conditions\" : [ { \"key\" : \"generatorPublicKey\" , \"condition\" : \"eq\" , \"value\" : \"032fcfd19f0e095bf46bd3ada87e283720c405249b1be1a70bad1d5f20095a8515\" } ] } }","title":"Response"},{"location":"api/webhook-api/endpoints/#events","text":"Event Description Implemented block.applied Fires when a block is saved Yes block.disregarded Fires when a block is disregarded Yes block.forged Fires when a block is forged Yes block.received Fires when a block is incoming Yes block.reverted Fires when a block is removed from the database (e.g. on a rollback) Yes delegate.registered Fires when a new delegate is registered Yes delegate.resigned Fires when a delegate resigns Yes forger.failed Fires when the forger module fails to start Yes forger.missing Fires when it is detected that the forger module isn't running Yes forger.started Fires when the forger module forges a new block No peer.added Fires when a peer is added Yes peer.removed Fires when a peer is removed Yes round.created Fires when a new round is created and saved to the database Yes state:started No transaction.applied Fires when a transaction is saved Yes transaction.expired Fires when an unconfirmed transaction expires Yes transaction.forged Fires when a transaction is forged by a delegate Yes transaction.pool.added Fires when transactions are added to the transaction pool Yes transaction.pool.rejected Fires when transactions are rejected and not added to the transaction pool Yes transaction.pool.removed Fires when a transaction is removed from the transaction pool by its ID Yes transaction.reverted Fires when a transaction is removed from the database No wallet.saved Fires when a wallet is updated (e.g. its balance changed, voted etc) Yes wallet.created.cold Fires when a wallet that never existed before is saved (e.g. received its first tx) Yes","title":"Events"},{"location":"api/webhook-api/endpoints/#conditions","text":"Condition Description between Check if the given value is between min and max contains Check if A contains B eq Check if A equals B falsy Check if the given value is false gt Check if A is greater than B gte Check if A is greater than or equal to B lt Check if A is lesser than B lte Check if A is lesser than or equal to B ne Check if A does not equal B not-between Check if the given value is not between min and max regexp Check if the given value matches truthy Check if the given value is true","title":"Conditions"},{"location":"api/webhook-api/endpoints/#update-a-webhook","text":"Existing webhooks may be updated. Note that this is the equivalent of deleting and creating a webhook; but retaining the same token . If you are often updating and creating webhooks; consider deleting and creating new webhooks instead of updating to rotate your validation token often.","title":"Update a Webhook"},{"location":"api/webhook-api/endpoints/#endpoint_3","text":"PUT /api/webhooks/ { id }","title":"Endpoint"},{"location":"api/webhook-api/endpoints/#path-parameters_1","text":"Name Type Description Required id string The identifier of the webhook to be updated. Yes","title":"Path Parameters"},{"location":"api/webhook-api/endpoints/#body-parameters_1","text":"Name Type Description Required event string The name of the event to be listened for. No target string The target URL for the HTTP payload. No enabled string The value to enable or disable the webhook. No conditions array The list of conditions required to trigger the webhook. No","title":"Body Parameters"},{"location":"api/webhook-api/endpoints/#response_3","text":"HTTP / 1.1 204 No Content {}","title":"Response"},{"location":"api/webhook-api/endpoints/#delete-a-webhook","text":"A webhook may be deleted by ID. Delete unused webhooks to save machine resources.","title":"Delete a Webhook"},{"location":"api/webhook-api/endpoints/#endpoint_4","text":"DELETE /api/webhooks/ { id }","title":"Endpoint"},{"location":"api/webhook-api/endpoints/#path-parameters_2","text":"Name Type Description Required id string The identifier of the webhook to be deleted. Yes","title":"Path Parameters"},{"location":"api/webhook-api/endpoints/#response_4","text":"HTTP / 1.1 204 No Content {}","title":"Response"},{"location":"api/webhook-api/getting-started/","text":"Getting Started \u00b6 The webhooks API allows you to register a webhook in a specific node, which will send a payload to a predefined target when certain conditions are met. Webhooks ensure that you do not need to poll the public API periodically and are a robust way to stay up-to-date with the blockchain state. tip All HTTP requests have to be sent with the Content-Type: application/json header. If the header is not present it will result in malformed responses or request rejections. Installation \u00b6 The webhooks API comes by default with an installation of core. In case you don't have it installed, you can add it manually by running yarn global add @solar-network/core-webhooks . Alias \u00b6 webhooks Configuration \u00b6 The webhooks API requires the following configuration in your app.json file. Make sure to have this configuration listed after @solar-network/core-blockchain . { \"package\" : \"@solar-network/core-webhooks\" }, It is recommended to make configuration changes to these options by working with your .env file and the corresponding variables: Variable Description Type Default CORE_WEBHOOKS_ENABLED Enables or disabled the webhook API plugin boolean false CORE_WEBHOOKS_HOST The host to expose the API on string \"0.0.0.0\" CORE_WEBHOOKS_PORT The API port on which the plugin will listen integer 6004 The whitelist property can be changed directly in the app.json file and is an Array consisting of IP addresses that you allow to make connections to the webhook API. By default, only local access to the webhook API is allowed. This means that if you want to expose your webhook API to the outside, you'll need to explicitly add the IP addresses that you will use to this list (recommended approach). It is also possible to use wildcards to indicate a range of IPs (e.g. \"12.34.56.*\" ) or even to allow everyone (e.g. \"*\" ) (not recommended). { \"package\" : \"@solar-network/core-webhooks\" , \"options\" : { \"server\" : { \"whitelist\" : [ \"127.0.0.1\" , \"::ffff:127.0.0.1\" ] } } }, Remember that there is no further authentication on the webhooks API itself, meaning that everyone that can access it can add, edit and delete your webhooks. Note : due to the way the CORE_WEBHOOKS_ENABLED check is implemented, you will need to remove the entry from your .env file if you want to disabled it. Setting the property to CORE_WEBHOOKS_ENABLED=false will not disable the webhooks API. Final Checks \u00b6 After making changes to the webhooks API configuration, you will need to restart your relay process for the changes to take effect. If you want to check whether your webhook API is running, you should pay attention to the startup messages in the logs of your relay. It will print a line similar to INFO : Webhook API Server running at: http://0.0.0.0:6004 when it has successfully started the webhooks API. When you see INFO : Webhooks are disabled it means the webhooks API is currently disabled.","title":"Getting Started"},{"location":"api/webhook-api/getting-started/#getting-started","text":"The webhooks API allows you to register a webhook in a specific node, which will send a payload to a predefined target when certain conditions are met. Webhooks ensure that you do not need to poll the public API periodically and are a robust way to stay up-to-date with the blockchain state. tip All HTTP requests have to be sent with the Content-Type: application/json header. If the header is not present it will result in malformed responses or request rejections.","title":"Getting Started"},{"location":"api/webhook-api/getting-started/#installation","text":"The webhooks API comes by default with an installation of core. In case you don't have it installed, you can add it manually by running yarn global add @solar-network/core-webhooks .","title":"Installation"},{"location":"api/webhook-api/getting-started/#alias","text":"webhooks","title":"Alias"},{"location":"api/webhook-api/getting-started/#configuration","text":"The webhooks API requires the following configuration in your app.json file. Make sure to have this configuration listed after @solar-network/core-blockchain . { \"package\" : \"@solar-network/core-webhooks\" }, It is recommended to make configuration changes to these options by working with your .env file and the corresponding variables: Variable Description Type Default CORE_WEBHOOKS_ENABLED Enables or disabled the webhook API plugin boolean false CORE_WEBHOOKS_HOST The host to expose the API on string \"0.0.0.0\" CORE_WEBHOOKS_PORT The API port on which the plugin will listen integer 6004 The whitelist property can be changed directly in the app.json file and is an Array consisting of IP addresses that you allow to make connections to the webhook API. By default, only local access to the webhook API is allowed. This means that if you want to expose your webhook API to the outside, you'll need to explicitly add the IP addresses that you will use to this list (recommended approach). It is also possible to use wildcards to indicate a range of IPs (e.g. \"12.34.56.*\" ) or even to allow everyone (e.g. \"*\" ) (not recommended). { \"package\" : \"@solar-network/core-webhooks\" , \"options\" : { \"server\" : { \"whitelist\" : [ \"127.0.0.1\" , \"::ffff:127.0.0.1\" ] } } }, Remember that there is no further authentication on the webhooks API itself, meaning that everyone that can access it can add, edit and delete your webhooks. Note : due to the way the CORE_WEBHOOKS_ENABLED check is implemented, you will need to remove the entry from your .env file if you want to disabled it. Setting the property to CORE_WEBHOOKS_ENABLED=false will not disable the webhooks API.","title":"Configuration"},{"location":"api/webhook-api/getting-started/#final-checks","text":"After making changes to the webhooks API configuration, you will need to restart your relay process for the changes to take effect. If you want to check whether your webhook API is running, you should pay attention to the startup messages in the logs of your relay. It will print a line similar to INFO : Webhook API Server running at: http://0.0.0.0:6004 when it has successfully started the webhooks API. When you see INFO : Webhooks are disabled it means the webhooks API is currently disabled.","title":"Final Checks"},{"location":"api/webhook-api/usage/","text":"Usage \u00b6 Introduction \u00b6 With the release of Solar Core 2.0, a new feature was introduced, called Webhooks which allows you to create more flexible and automated systems while also reducing traffic/load on your server. Authorisation \u00b6 Before we start working on the implementation of a webhook handler, we will take a look at handling authorisation. To guarantee that only your server is allowed to send data to your webhook handler, an authorisation token is generated on creation of a webhook. The generated token will only be returned once and not be visible again. To generate an authorisation token, you need to create a webhook . Lets take the following token as an example fe944e318edb02b979d6bf0c87978b640c8e74e1cbfe36404386d33a5bbd8b66 which is 64 characters long and breaks down into 2 parts at 32 characters length each. The first 32 characters will be stored in the database and sent to you as a header Authorization: fe944e318edb02b979d6bf0c87978b64 via a POST request. The last 32 characters 0c8e74e1cbfe36404386d33a5bbd8b66 need to be stored by you and will serve as a way for you to verify that the request is authorised. Handling Webhooks \u00b6 Now that we know how the token is structured and what it is used for we can continue with implementing a webhook handler. A webhook handler is just a simple POST endpoint that you need to implement at the URL you specified when creating a webhook. const webhookToken = \"fe944e318edb02b979d6bf0c87978b640c8e74e1cbfe36404386d33a5bbd8b66\" ; const verification = \"0c8e74e1cbfe36404386d33a5bbd8b66\" ; server . post ( \"/blocks\" , jsonParser , ( req , res ) => { // This will be fe944e318edb02b979d6bf0c87978b64 const authorisation = req . headers [ \"authorization\" ]; // This will be authorisation + verification const token = authorisation + verification ; // Make sure we block access if the token is invalid... if ( token !== webhookToken ) { return res . status ( 401 ). send ( \"Unauthorized!\" ); } // the datetime of when the webhook was sent console . log ( req . body . created ); // the data the webhook transferred, e.g. a block struct console . log ( req . body . data ); // the type of event that was sent, e.g. block.forged console . log ( req . body . type ); // do something with the above req.body data return res . status ( 200 ). send ( \"Hello Webhook!\" ); }); package main import ( \"fmt\" \"log\" \"net/http\" ) const ( webhookToken = \"fe944e318edb02b979d6bf0c87978b640c8e74e1cbfe36404386d33a5bbd8b66\" verification = \"0c8e74e1cbfe36404386d33a5bbd8b66\" ) func validateOrigin ( next http . Handler ) http . Handler { return func ( w http . ResponseWriter , r * http . Request ) { if r . Header . Get ( \"authorization\" ) + verification != webhookToken { w . WriteHeader ( http . StatusUnauthorized ) w . Write ([] byte ( \"Unauthorized!\" )) return } return next ( w , r ) } } func handler ( w http . ResponseWriter , r * http . Request ) { decoder := json . NewDecoder ( r . Body ) var resp Response // some defined DTO err := decoder . Decode ( & resp ) if err != nil { handle ( w , err ) } // do something with the received block/transaction/wallet } func main () { http . HandleFunc ( \"/blocks\" , validateOrigin ( handler )) log . Fatal ( http . ListenAndServe ( \":8080\" , nil )) } import pickle import hashlib from flask import Flask , request from werkzeug.exceptions import Unauthorized from functools import wraps app = Flask ( __name__ ) def dump_webhook_token ( token ): authorisation = token [: 32 ] # \"fe944e318edb02b979d6bf0c87978b64\" verification = token [ 32 :] # \"0c8e74e1cbfe36404386d33a5bbd8b66\" filename = hashlib . md5 ( authorisation . encode ( \"utf-8\" )) . hexdigest () with open ( filename , \"wb\" ) as out : pickle . dump ( { \"verification\" : verification , \"hash\" : hashlib . sha256 ( token . encode ( \"utf-8\" )) . hexdigest () }, out ) def check_webhook_token ( authorisation ): filename = hashlib . md5 ( authorisation . encode ( \"utf-8\" )) . hexdigest () try : with open ( filename , \"rb\" ) as in_ : data = pickle . load ( in_ ) except Exception : return False else : token = authorisation + data [ \"verification\" ] return hashlib . sha256 ( token . encode ( \"utf-8\" ) ) . hexdigest () == data [ \"hash\" ] # ... # Somewhere On Webhook Subscription dump_webhook_token ( \"fe944e318edb02b979d6bf0c87978b640c8e74e1cbfe36404386d33a5bbd8b66\" ) # verification = \"0c8e74e1cbfe36404386d33a5bbd8b66\" # token = \"fe944e318edb02b979d6bf0c87978b640c8e74e1cbfe36404386d33a5bbd8b66\" #... # This Should Be Middleware if This App Is Dedicated to Webhooks def token_required ( f ): @wraps ( f ) def decorated_function ( * args , ** kwargs ): # if request.headers.get(\"authorisation\") + verification != token: if not check_webhook_token ( request . headers . get ( \"authorization\" )): raise Unauthorised ( \"Unauthorized!\" ) return f ( * args , ** kwargs ) return decorated_function @app . route ( \"/blocks\" ) @token_required def handle_block (): block = request . get_json () # do something with the block if __name__ == \"__main__\" : app . run ( debug = True , port = 5000 ) Let's break down the steps we took here: Grab the Authorization header. Create the full token based on the Authorization header and Verification string. Deny access if the full token does not equal the webhook token . Log and process the request body if the full token is valid. Authentication \u00b6 To communicate with the Webhooks API, you will need to provide the token you configured on your node through the Authorization header. Authenticating with an invalid token will return 401 Unauthorized . Headers \u00b6 Name Type Description Required Authorization string The webhook token defined in the node configuration. Yes","title":"Usage"},{"location":"api/webhook-api/usage/#usage","text":"","title":"Usage"},{"location":"api/webhook-api/usage/#introduction","text":"With the release of Solar Core 2.0, a new feature was introduced, called Webhooks which allows you to create more flexible and automated systems while also reducing traffic/load on your server.","title":"Introduction"},{"location":"api/webhook-api/usage/#authorisation","text":"Before we start working on the implementation of a webhook handler, we will take a look at handling authorisation. To guarantee that only your server is allowed to send data to your webhook handler, an authorisation token is generated on creation of a webhook. The generated token will only be returned once and not be visible again. To generate an authorisation token, you need to create a webhook . Lets take the following token as an example fe944e318edb02b979d6bf0c87978b640c8e74e1cbfe36404386d33a5bbd8b66 which is 64 characters long and breaks down into 2 parts at 32 characters length each. The first 32 characters will be stored in the database and sent to you as a header Authorization: fe944e318edb02b979d6bf0c87978b64 via a POST request. The last 32 characters 0c8e74e1cbfe36404386d33a5bbd8b66 need to be stored by you and will serve as a way for you to verify that the request is authorised.","title":"Authorisation"},{"location":"api/webhook-api/usage/#handling-webhooks","text":"Now that we know how the token is structured and what it is used for we can continue with implementing a webhook handler. A webhook handler is just a simple POST endpoint that you need to implement at the URL you specified when creating a webhook. const webhookToken = \"fe944e318edb02b979d6bf0c87978b640c8e74e1cbfe36404386d33a5bbd8b66\" ; const verification = \"0c8e74e1cbfe36404386d33a5bbd8b66\" ; server . post ( \"/blocks\" , jsonParser , ( req , res ) => { // This will be fe944e318edb02b979d6bf0c87978b64 const authorisation = req . headers [ \"authorization\" ]; // This will be authorisation + verification const token = authorisation + verification ; // Make sure we block access if the token is invalid... if ( token !== webhookToken ) { return res . status ( 401 ). send ( \"Unauthorized!\" ); } // the datetime of when the webhook was sent console . log ( req . body . created ); // the data the webhook transferred, e.g. a block struct console . log ( req . body . data ); // the type of event that was sent, e.g. block.forged console . log ( req . body . type ); // do something with the above req.body data return res . status ( 200 ). send ( \"Hello Webhook!\" ); }); package main import ( \"fmt\" \"log\" \"net/http\" ) const ( webhookToken = \"fe944e318edb02b979d6bf0c87978b640c8e74e1cbfe36404386d33a5bbd8b66\" verification = \"0c8e74e1cbfe36404386d33a5bbd8b66\" ) func validateOrigin ( next http . Handler ) http . Handler { return func ( w http . ResponseWriter , r * http . Request ) { if r . Header . Get ( \"authorization\" ) + verification != webhookToken { w . WriteHeader ( http . StatusUnauthorized ) w . Write ([] byte ( \"Unauthorized!\" )) return } return next ( w , r ) } } func handler ( w http . ResponseWriter , r * http . Request ) { decoder := json . NewDecoder ( r . Body ) var resp Response // some defined DTO err := decoder . Decode ( & resp ) if err != nil { handle ( w , err ) } // do something with the received block/transaction/wallet } func main () { http . HandleFunc ( \"/blocks\" , validateOrigin ( handler )) log . Fatal ( http . ListenAndServe ( \":8080\" , nil )) } import pickle import hashlib from flask import Flask , request from werkzeug.exceptions import Unauthorized from functools import wraps app = Flask ( __name__ ) def dump_webhook_token ( token ): authorisation = token [: 32 ] # \"fe944e318edb02b979d6bf0c87978b64\" verification = token [ 32 :] # \"0c8e74e1cbfe36404386d33a5bbd8b66\" filename = hashlib . md5 ( authorisation . encode ( \"utf-8\" )) . hexdigest () with open ( filename , \"wb\" ) as out : pickle . dump ( { \"verification\" : verification , \"hash\" : hashlib . sha256 ( token . encode ( \"utf-8\" )) . hexdigest () }, out ) def check_webhook_token ( authorisation ): filename = hashlib . md5 ( authorisation . encode ( \"utf-8\" )) . hexdigest () try : with open ( filename , \"rb\" ) as in_ : data = pickle . load ( in_ ) except Exception : return False else : token = authorisation + data [ \"verification\" ] return hashlib . sha256 ( token . encode ( \"utf-8\" ) ) . hexdigest () == data [ \"hash\" ] # ... # Somewhere On Webhook Subscription dump_webhook_token ( \"fe944e318edb02b979d6bf0c87978b640c8e74e1cbfe36404386d33a5bbd8b66\" ) # verification = \"0c8e74e1cbfe36404386d33a5bbd8b66\" # token = \"fe944e318edb02b979d6bf0c87978b640c8e74e1cbfe36404386d33a5bbd8b66\" #... # This Should Be Middleware if This App Is Dedicated to Webhooks def token_required ( f ): @wraps ( f ) def decorated_function ( * args , ** kwargs ): # if request.headers.get(\"authorisation\") + verification != token: if not check_webhook_token ( request . headers . get ( \"authorization\" )): raise Unauthorised ( \"Unauthorized!\" ) return f ( * args , ** kwargs ) return decorated_function @app . route ( \"/blocks\" ) @token_required def handle_block (): block = request . get_json () # do something with the block if __name__ == \"__main__\" : app . run ( debug = True , port = 5000 ) Let's break down the steps we took here: Grab the Authorization header. Create the full token based on the Authorization header and Verification string. Deny access if the full token does not equal the webhook token . Log and process the request body if the full token is valid.","title":"Handling Webhooks"},{"location":"api/webhook-api/usage/#authentication","text":"To communicate with the Webhooks API, you will need to provide the token you configured on your node through the Authorization header. Authenticating with an invalid token will return 401 Unauthorized .","title":"Authentication"},{"location":"api/webhook-api/usage/#headers","text":"Name Type Description Required Authorization string The webhook token defined in the node configuration. Yes","title":"Headers"},{"location":"brand/intro/","text":"This page is under construction and more content will be added over time. \u00b6 The Solar Network has a specific guideline on creating and managing the brand. Click on the items below to learn more. Brand-Guidelines Download Mediakit Download Github Banners","title":"Introduction"},{"location":"brand/intro/#this-page-is-under-construction-and-more-content-will-be-added-over-time","text":"The Solar Network has a specific guideline on creating and managing the brand. Click on the items below to learn more. Brand-Guidelines Download Mediakit Download Github Banners","title":"This page is under construction and more content will be added over time."},{"location":"core/intro/","text":"Welcome to Solar Core \u00b6 Installation Introduction Requirements Database Variables Installation Steps Transactions Understanding the Lifecycle Understanding the Nonce Transaction Types Updates 4.1.1 4.0.1 3.3.0","title":"Welcome to Solar Core"},{"location":"core/intro/#welcome-to-solar-core","text":"Installation Introduction Requirements Database Variables Installation Steps Transactions Understanding the Lifecycle Understanding the Nonce Transaction Types Updates 4.1.1 4.0.1 3.3.0","title":"Welcome to Solar Core"},{"location":"core/installation/intro/","text":"Introduction \u00b6 Solar Core is written in TypeScript , and it has been using Lerna to manage the development and publication of its packages and uses Node.js as execution environment. This guide will take you through the basic steps of setting up a Solar Core installation.","title":"Introduction"},{"location":"core/installation/intro/#introduction","text":"Solar Core is written in TypeScript , and it has been using Lerna to manage the development and publication of its packages and uses Node.js as execution environment. This guide will take you through the basic steps of setting up a Solar Core installation.","title":"Introduction"},{"location":"core/installation/requirements/","text":"Server Requirements \u00b6 Supported OS Release Ubuntu >= 20.x Debian >= 10.x Ubuntu < = 18.x and Debian < = 9 are no longer supported Relay Requirements Recommended Minimum CPUs 4 2 RAM 8GB 4GB HDD 100GB - 120GB 80GB Forger Requirements Recommended Minimum CPUs 4 ( dedicated ) 2 ( dedicated ) RAM 16GB 8GB HDD 100GB - 120GB ( SSD ) 80GB ( SSD )","title":"Requirements"},{"location":"core/installation/requirements/#server-requirements","text":"Supported OS Release Ubuntu >= 20.x Debian >= 10.x Ubuntu < = 18.x and Debian < = 9 are no longer supported Relay Requirements Recommended Minimum CPUs 4 2 RAM 8GB 4GB HDD 100GB - 120GB 80GB Forger Requirements Recommended Minimum CPUs 4 ( dedicated ) 2 ( dedicated ) RAM 16GB 8GB HDD 100GB - 120GB ( SSD ) 80GB ( SSD )","title":"Server Requirements"},{"location":"core/installation/steps/","text":"Installation Steps \u00b6 A step-by-step guide on how to prepare a fully-functional environment using the install script. Getting Started \u00b6 The instructions on this page will guide you through creating a new user account with the correct privileges, installing and configuring Solar Core, then starting a relay instance and logging the output using the installation script. Directly below is a quick summary of these install commands: sudo adduser solar sudo usermod -a -G sudo solar su -l solar wget -O install.sh https://raw.githubusercontent.com/solar-network/core/main/install.sh bash install.sh solar relay:start pm2 logs Step-by-Step Installation via the Script \u00b6 If you are planning to setup a new server you can execute the following steps. Step 1: Create a New Account \u00b6 Create a new dedicated user account to manage SXP-related software. We\u2019ll illustrate this command as sudo adduser solar to create a user by the name of \u2018solar\u2019 , but you can chose something else, if preferred. On your server, type the following into the command line: sudo adduser solar You'll be asked to create and confirm a new user password, and be prompted to enter the user\u2019s full name and some other information. ( Feel free to leave them blank by pressing \u2018enter\u2019, they are all optional fields. ) When prompted to confirm, type \u2018Y\u2019 and press \u2018enter\u2019 to finish. Adding user 'solar' ... Adding new group 'solar' ( 1000 ) ... Adding new user 'solar' ( 1000 ) with group 'solar' ... Creating home directory '/home/solar' ... Copying files from '/etc/skel' ... Enter new UNIX password: Retype new UNIX password: passwd: password updated successfully Changing the user information for solar Enter the new value, or press ENTER for the default Full Name [] : Room Number [] : Work Phone [] : Home Phone [] : Other [] : Is the information correct? [ Y/n ] Y Step 2: Grant Sudo Privileges \u00b6 Next, we need to make sure that our user account has all of the necessary privileges to run Solar Core properly. This will give our user account sudo privileges. Type or copy-paste the following command into your terminal: sudo usermod -a -G sudo solar info In this example we use 'solar' for the name of the new user account, but you should use whatever username was set in the previous steps above. Step 3: Login as the New User \u00b6 We now should switch to the user account created above, this will also land us in the user's base directory ( ~/ ). Type or copy-paste the following command into your terminal: su -l solar Step 4: Run the Installation Script \u00b6 Here, we will use the install.sh script. This installs Solar Core and all of its dependencies onto your server, then publishes the configuration files for it. Run the install script by copying and pasting this one line command into your terminal: wget -O install.sh https://raw.githubusercontent.com/solar-network/core/main/install.sh bash install.sh \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551 \u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557 \u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2551 \u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d \u255a\u2550\u255d\u255a\u2550\u255d \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d Thanks for choosing to install Solar Core! Preparing the setup procedure... Step 5: Select the Core network \u00b6 Once the installation of dependencies and Solar Core is finished you will need to select which network you wish to operate on. This can be achieved by pressing the up or down arrow keys and confirming your selection by pressing enter . Mainnet is the public network, Testnet is the development network for testing. ? Which network do you want to connect to? \u203a - Use arrow-keys. Return to submit. \u276f Mainnet Testnet After you have made your selection, you will need to confirm by pressing y and confirm again with enter \u2714 Which network do you want to connect to? \u203a Mainnet ? Are you sure? \u203a ( y/N ) The installation process will then proceed. Installing Solar Core for mainnet. This process may take a few minutes \u2826 Downloading operating system dependencies \u203a Installing operating system dependencies \u203a Downloading Core 4 .1.3 \u203a Downloading Core dependencies \u203a Installing Core dependencies \u203a Building Core 4 .1.3 \u203a Saving configuration \u203a Adding plugins \u203a Setting up database warning The install process might take a while, don\u2019t interrupt it, wait for it to finish. At this point, Solar Core has been successfully installed with its configuration options properly published. Installing Solar Core for mainnet. This process may take a few minutes \u2714 Downloading operating system dependencies \u2714 Installing operating system dependencies \u2714 Downloading Core 4 .1.3 \u2714 Downloading Core dependencies \u2714 Installing Core dependencies \u2714 Building Core 4 .1.3 \u2714 Saving configuration \u2714 Adding plugins \u2714 Setting up database Solar Core has been successfully installed! To get started, type solar To run a command as administrator ( user \"root\" ) , use \"sudo <command>\" . See \"man sudo_root\" for details. Success \u00b6 Your installation is all set! \ud83c\udf89 That\u2019s it, you may now start your relay and view its logs using the following command: solar relay:start && pm2 logs \u2714 Starting solar-relay ... 1 | solar-relay | [ 2022 -11-06 22 :36:49.742 ] INFO: Connecting to database: solar_mainnet 1 | solar-relay | [ 2022 -11-06 22 :36:49.803 ] DEBUG: Database migration: Creating rounds table 1 | solar-relay | [ 2022 -11-06 22 :36:49.809 ] DEBUG: Database migration: Creating blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.816 ] DEBUG: Database migration: Creating transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.821 ] DEBUG: Database migration: Adding block_id index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.823 ] DEBUG: Database migration: Adding generator_public_key index to blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.825 ] DEBUG: Database migration: Adding timestamp index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.827 ] DEBUG: Database migration: Adding sender_public_key index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.829 ] DEBUG: Database migration: Adding recipient_id index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.832 ] DEBUG: Database migration: Adding block_id constraint to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.834 ] DEBUG: Database migration: Dropping id from rounds table 1 | solar-relay | [ 2022 -11-06 22 :36:49.836 ] DEBUG: Database migration: Adding chained_blocks constraint to blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.838 ] DEBUG: Database migration: Adding type_group to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.839 ] DEBUG: Database migration: Adding nonce to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.843 ] DEBUG: Database migration: Adding nonce trigger to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.845 ] DEBUG: Database migration: Adding asset to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.846 ] DEBUG: Database migration: Renaming and converting vendor_field_hex to vendor_field in transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.851 ] DEBUG: Database migration: Adding type index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.853 ] DEBUG: Database migration: Adding type_group index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.855 ] DEBUG: Database migration: Adding indexes to blocks and transactions tables 1 | solar-relay | [ 2022 -11-06 22 :36:49.880 ] DEBUG: Database migration: Adding block_height to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.885 ] DEBUG: Database migration: Creating wallets table 1 | solar-relay | [ 2022 -11-06 22 :36:49.889 ] DEBUG: Database migration: Adding payments asset index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.890 ] DEBUG: Database migration: Configuring autovacuum on all tables 1 | solar-relay | [ 2022 -11-06 22 :36:49.891 ] DEBUG: Database migration: Adding generator_public_key index to blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.893 ] DEBUG: Database migration: Adding burned_fee to blocks and transactions tables 1 | solar-relay | [ 2022 -11-06 22 :36:49.898 ] DEBUG: Database migration: Adding dev_fund to blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.901 ] DEBUG: Database migration: Disabling fastupdate on indexes in transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.902 ] DEBUG: Database migration: Renaming serialized to serialised in transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.903 ] DEBUG: Database migration: Renaming payments asset to transfers in transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.905 ] DEBUG: Database migration: Setting empty recipient_id to null in transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.906 ] DEBUG: Database migration: Setting zero amount to null in transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.907 ] DEBUG: Database migration: Renaming vendor_field to memo in transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.908 ] DEBUG: Database migration: Adding username to blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.911 ] DEBUG: Database migration: Creating missed_blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.913 ] DEBUG: Database migration: Adding sender_id to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.915 ] DEBUG: Database migration: Adding id index with operator class to blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.917 ] DEBUG: Database migration: Adding id index with operator class to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.918 ] DEBUG: Database migration: Renaming dev_fund to donations in blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.921 ] DEBUG: Database migration: Adding timestamp, username index to blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.923 ] DEBUG: Database migration: Adding type, type_group index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.926 ] DEBUG: Updating database configuration \ud83d\udcda 1 | solar-relay | [ 2022 -11-06 22 :36:49.928 ] DEBUG: Connection established 1 | solar-relay | [ 2022 -11-06 22 :36:49.938 ] INFO: Loaded SXP Swap Plugin 1 | solar-relay | [ 2022 -11-06 22 :36:50.192 ] WARNING: No block found in database \ud83d\ude2f 1 | solar-relay | [ 2022 -11-06 22 :36:50.236 ] NOTICE: Milestone change 1 | solar-relay | [ 2022 -11-06 22 :36:50.303 ] INFO: P2P Server started at http://suitable-wagtail:6001 1 | solar-relay | [ 2022 -11-06 22 :36:50.304 ] INFO: Starting Blockchain Manager \u26d3\ufe0f 1 | solar-relay | [ 2022 -11-06 22 :36:50.309 ] DEBUG: event 'START' : \"uninitialised\" -> \"initialise\" -> actions: [ initialise ] 1 | solar-relay | [ 2022 -11-06 22 :36:50.313 ] INFO: Last block in database: 1 1 | solar-relay | [ 2022 -11-06 22 :36:50.314 ] INFO: No saved states exist so a fresh state will now be generated \u203c\ufe0f 1 | solar-relay | [ 2022 -11-06 22 :36:50.314 ] INFO: Verifying database integrity \u23f3 1 | solar-relay | [ 2022 -11-06 22 :36:50.345 ] INFO: Verified database integrity \ud83d\ude38 1 | solar-relay | [ 2022 -11-06 22 :36:50.350 ] INFO: State Generation - Step 1 of 16 : LegacyTransfer 1 | solar-relay | [ 2022 -11-06 22 :36:50.359 ] INFO: State Generation - Step 2 of 16 : SecondSignature 1 | solar-relay | [ 2022 -11-06 22 :36:50.361 ] INFO: State Generation - Step 3 of 16 : DelegateRegistration 1 | solar-relay | [ 2022 -11-06 22 :36:50.374 ] INFO: State Generation - Step 4 of 16 : LegacyVote 1 | solar-relay | [ 2022 -11-06 22 :36:50.384 ] INFO: State Generation - Step 5 of 16 : MultiSignature 1 | solar-relay | [ 2022 -11-06 22 :36:50.391 ] INFO: State Generation - Step 6 of 16 : Ipfs 1 | solar-relay | [ 2022 -11-06 22 :36:50.393 ] INFO: State Generation - Step 7 of 16 : Transfer 1 | solar-relay | [ 2022 -11-06 22 :36:50.396 ] INFO: State Generation - Step 8 of 16 : DelegateResignation 1 | solar-relay | [ 2022 -11-06 22 :36:50.397 ] INFO: State Generation - Step 9 of 16 : HtlcLock 1 | solar-relay | [ 2022 -11-06 22 :36:50.401 ] INFO: State Generation - Step 10 of 16 : HtlcClaim 1 | solar-relay | [ 2022 -11-06 22 :36:50.404 ] INFO: State Generation - Step 11 of 16 : HtlcRefund 1 | solar-relay | [ 2022 -11-06 22 :36:50.407 ] INFO: State Generation - Step 12 of 16 : Burn 1 | solar-relay | [ 2022 -11-06 22 :36:50.409 ] INFO: State Generation - Step 13 of 16 : Vote 1 | solar-relay | [ 2022 -11-06 22 :36:50.410 ] INFO: State Generation - Step 14 of 16 : Fees & Nonces 1 | solar-relay | [ 2022 -11-06 22 :36:50.412 ] INFO: State Generation - Step 15 of 16 : Block Rewards 1 | solar-relay | [ 2022 -11-06 22 :36:50.414 ] INFO: State Generation - Step 16 of 16 : Vote Balances & Delegate Ranking 1 | solar-relay | [ 2022 -11-06 22 :36:50.418 ] INFO: Number of registered delegates: 53 1 | solar-relay | [ 2022 -11-06 22 :36:50.420 ] INFO: Calculating productivity data \ud83e\uddee 1 | solar-relay | [ 2022 -11-06 22 :36:50.440 ] DEBUG: Loaded 53 active delegates 1 | solar-relay | [ 2022 -11-06 22 :36:50.446 ] INFO: Starting Round 1 \ud83d\udd4a\ufe0f 1 | solar-relay | [ 2022 -11-06 22 :36:50.448 ] DEBUG: Loaded 53 active delegates 1 | solar-relay | [ 2022 -11-06 22 :36:50.449 ] INFO: Saving round 1 1 | solar-relay | [ 2022 -11-06 22 :36:50.655 ] INFO: Your network connectivity has been verified by 8 .8.4.4 \u2705 ... 1 | solar-re | [ 2022 -11-06 22 :40:46.370 ] DEBUG: Delegate bfx is allowed to forge block 76 ,805 \ud83d\udc4d 1 | solar-re | [ 2022 -11-06 22 :40:46.371 ] DEBUG: Delegate sxp is allowed to forge block 76 ,807 \ud83d\udc4d 1 | solar-re | [ 2022 -11-06 22 :40:46.372 ] DEBUG: Delegate sl33p is allowed to forge block 76 ,809 \ud83d\udc4d 1 | solar-re | [ 2022 -11-06 22 :40:46.373 ] DEBUG: Delegate advin is allowed to forge block 76 ,816 \ud83d\udc4d 1 | solar-re | [ 2022 -11-06 22 :40:46.383 ] DEBUG: Delegate cactus1549 is allowed to forge block 76 ,819 \ud83d\udc4d ... info Synchronisation of the blockchain can take some time. Once synchronised, the `allowed to forge block ...` messages will be logged every ~8 seconds \u2014 as opposed to milliseconds apart shown during sync. A single round consists of 53 delegates, each forging a single block.","title":"Installation Steps"},{"location":"core/installation/steps/#installation-steps","text":"A step-by-step guide on how to prepare a fully-functional environment using the install script.","title":"Installation Steps"},{"location":"core/installation/steps/#getting-started","text":"The instructions on this page will guide you through creating a new user account with the correct privileges, installing and configuring Solar Core, then starting a relay instance and logging the output using the installation script. Directly below is a quick summary of these install commands: sudo adduser solar sudo usermod -a -G sudo solar su -l solar wget -O install.sh https://raw.githubusercontent.com/solar-network/core/main/install.sh bash install.sh solar relay:start pm2 logs","title":"Getting Started"},{"location":"core/installation/steps/#step-by-step-installation-via-the-script","text":"If you are planning to setup a new server you can execute the following steps.","title":"Step-by-Step Installation via the Script"},{"location":"core/installation/steps/#step-1-create-a-new-account","text":"Create a new dedicated user account to manage SXP-related software. We\u2019ll illustrate this command as sudo adduser solar to create a user by the name of \u2018solar\u2019 , but you can chose something else, if preferred. On your server, type the following into the command line: sudo adduser solar You'll be asked to create and confirm a new user password, and be prompted to enter the user\u2019s full name and some other information. ( Feel free to leave them blank by pressing \u2018enter\u2019, they are all optional fields. ) When prompted to confirm, type \u2018Y\u2019 and press \u2018enter\u2019 to finish. Adding user 'solar' ... Adding new group 'solar' ( 1000 ) ... Adding new user 'solar' ( 1000 ) with group 'solar' ... Creating home directory '/home/solar' ... Copying files from '/etc/skel' ... Enter new UNIX password: Retype new UNIX password: passwd: password updated successfully Changing the user information for solar Enter the new value, or press ENTER for the default Full Name [] : Room Number [] : Work Phone [] : Home Phone [] : Other [] : Is the information correct? [ Y/n ] Y","title":"Step 1: Create a New Account"},{"location":"core/installation/steps/#step-2-grant-sudo-privileges","text":"Next, we need to make sure that our user account has all of the necessary privileges to run Solar Core properly. This will give our user account sudo privileges. Type or copy-paste the following command into your terminal: sudo usermod -a -G sudo solar info In this example we use 'solar' for the name of the new user account, but you should use whatever username was set in the previous steps above.","title":"Step 2: Grant Sudo Privileges"},{"location":"core/installation/steps/#step-3-login-as-the-new-user","text":"We now should switch to the user account created above, this will also land us in the user's base directory ( ~/ ). Type or copy-paste the following command into your terminal: su -l solar","title":"Step 3: Login as the New User"},{"location":"core/installation/steps/#step-4-run-the-installation-script","text":"Here, we will use the install.sh script. This installs Solar Core and all of its dependencies onto your server, then publishes the configuration files for it. Run the install script by copying and pasting this one line command into your terminal: wget -O install.sh https://raw.githubusercontent.com/solar-network/core/main/install.sh bash install.sh \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551 \u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557 \u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2551 \u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d \u255a\u2550\u255d\u255a\u2550\u255d \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d Thanks for choosing to install Solar Core! Preparing the setup procedure...","title":"Step 4: Run the Installation Script"},{"location":"core/installation/steps/#step-5-select-the-core-network","text":"Once the installation of dependencies and Solar Core is finished you will need to select which network you wish to operate on. This can be achieved by pressing the up or down arrow keys and confirming your selection by pressing enter . Mainnet is the public network, Testnet is the development network for testing. ? Which network do you want to connect to? \u203a - Use arrow-keys. Return to submit. \u276f Mainnet Testnet After you have made your selection, you will need to confirm by pressing y and confirm again with enter \u2714 Which network do you want to connect to? \u203a Mainnet ? Are you sure? \u203a ( y/N ) The installation process will then proceed. Installing Solar Core for mainnet. This process may take a few minutes \u2826 Downloading operating system dependencies \u203a Installing operating system dependencies \u203a Downloading Core 4 .1.3 \u203a Downloading Core dependencies \u203a Installing Core dependencies \u203a Building Core 4 .1.3 \u203a Saving configuration \u203a Adding plugins \u203a Setting up database warning The install process might take a while, don\u2019t interrupt it, wait for it to finish. At this point, Solar Core has been successfully installed with its configuration options properly published. Installing Solar Core for mainnet. This process may take a few minutes \u2714 Downloading operating system dependencies \u2714 Installing operating system dependencies \u2714 Downloading Core 4 .1.3 \u2714 Downloading Core dependencies \u2714 Installing Core dependencies \u2714 Building Core 4 .1.3 \u2714 Saving configuration \u2714 Adding plugins \u2714 Setting up database Solar Core has been successfully installed! To get started, type solar To run a command as administrator ( user \"root\" ) , use \"sudo <command>\" . See \"man sudo_root\" for details.","title":"Step 5: Select the Core network"},{"location":"core/installation/steps/#success","text":"Your installation is all set! \ud83c\udf89 That\u2019s it, you may now start your relay and view its logs using the following command: solar relay:start && pm2 logs \u2714 Starting solar-relay ... 1 | solar-relay | [ 2022 -11-06 22 :36:49.742 ] INFO: Connecting to database: solar_mainnet 1 | solar-relay | [ 2022 -11-06 22 :36:49.803 ] DEBUG: Database migration: Creating rounds table 1 | solar-relay | [ 2022 -11-06 22 :36:49.809 ] DEBUG: Database migration: Creating blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.816 ] DEBUG: Database migration: Creating transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.821 ] DEBUG: Database migration: Adding block_id index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.823 ] DEBUG: Database migration: Adding generator_public_key index to blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.825 ] DEBUG: Database migration: Adding timestamp index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.827 ] DEBUG: Database migration: Adding sender_public_key index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.829 ] DEBUG: Database migration: Adding recipient_id index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.832 ] DEBUG: Database migration: Adding block_id constraint to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.834 ] DEBUG: Database migration: Dropping id from rounds table 1 | solar-relay | [ 2022 -11-06 22 :36:49.836 ] DEBUG: Database migration: Adding chained_blocks constraint to blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.838 ] DEBUG: Database migration: Adding type_group to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.839 ] DEBUG: Database migration: Adding nonce to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.843 ] DEBUG: Database migration: Adding nonce trigger to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.845 ] DEBUG: Database migration: Adding asset to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.846 ] DEBUG: Database migration: Renaming and converting vendor_field_hex to vendor_field in transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.851 ] DEBUG: Database migration: Adding type index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.853 ] DEBUG: Database migration: Adding type_group index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.855 ] DEBUG: Database migration: Adding indexes to blocks and transactions tables 1 | solar-relay | [ 2022 -11-06 22 :36:49.880 ] DEBUG: Database migration: Adding block_height to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.885 ] DEBUG: Database migration: Creating wallets table 1 | solar-relay | [ 2022 -11-06 22 :36:49.889 ] DEBUG: Database migration: Adding payments asset index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.890 ] DEBUG: Database migration: Configuring autovacuum on all tables 1 | solar-relay | [ 2022 -11-06 22 :36:49.891 ] DEBUG: Database migration: Adding generator_public_key index to blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.893 ] DEBUG: Database migration: Adding burned_fee to blocks and transactions tables 1 | solar-relay | [ 2022 -11-06 22 :36:49.898 ] DEBUG: Database migration: Adding dev_fund to blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.901 ] DEBUG: Database migration: Disabling fastupdate on indexes in transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.902 ] DEBUG: Database migration: Renaming serialized to serialised in transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.903 ] DEBUG: Database migration: Renaming payments asset to transfers in transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.905 ] DEBUG: Database migration: Setting empty recipient_id to null in transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.906 ] DEBUG: Database migration: Setting zero amount to null in transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.907 ] DEBUG: Database migration: Renaming vendor_field to memo in transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.908 ] DEBUG: Database migration: Adding username to blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.911 ] DEBUG: Database migration: Creating missed_blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.913 ] DEBUG: Database migration: Adding sender_id to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.915 ] DEBUG: Database migration: Adding id index with operator class to blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.917 ] DEBUG: Database migration: Adding id index with operator class to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.918 ] DEBUG: Database migration: Renaming dev_fund to donations in blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.921 ] DEBUG: Database migration: Adding timestamp, username index to blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.923 ] DEBUG: Database migration: Adding type, type_group index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.926 ] DEBUG: Updating database configuration \ud83d\udcda 1 | solar-relay | [ 2022 -11-06 22 :36:49.928 ] DEBUG: Connection established 1 | solar-relay | [ 2022 -11-06 22 :36:49.938 ] INFO: Loaded SXP Swap Plugin 1 | solar-relay | [ 2022 -11-06 22 :36:50.192 ] WARNING: No block found in database \ud83d\ude2f 1 | solar-relay | [ 2022 -11-06 22 :36:50.236 ] NOTICE: Milestone change 1 | solar-relay | [ 2022 -11-06 22 :36:50.303 ] INFO: P2P Server started at http://suitable-wagtail:6001 1 | solar-relay | [ 2022 -11-06 22 :36:50.304 ] INFO: Starting Blockchain Manager \u26d3\ufe0f 1 | solar-relay | [ 2022 -11-06 22 :36:50.309 ] DEBUG: event 'START' : \"uninitialised\" -> \"initialise\" -> actions: [ initialise ] 1 | solar-relay | [ 2022 -11-06 22 :36:50.313 ] INFO: Last block in database: 1 1 | solar-relay | [ 2022 -11-06 22 :36:50.314 ] INFO: No saved states exist so a fresh state will now be generated \u203c\ufe0f 1 | solar-relay | [ 2022 -11-06 22 :36:50.314 ] INFO: Verifying database integrity \u23f3 1 | solar-relay | [ 2022 -11-06 22 :36:50.345 ] INFO: Verified database integrity \ud83d\ude38 1 | solar-relay | [ 2022 -11-06 22 :36:50.350 ] INFO: State Generation - Step 1 of 16 : LegacyTransfer 1 | solar-relay | [ 2022 -11-06 22 :36:50.359 ] INFO: State Generation - Step 2 of 16 : SecondSignature 1 | solar-relay | [ 2022 -11-06 22 :36:50.361 ] INFO: State Generation - Step 3 of 16 : DelegateRegistration 1 | solar-relay | [ 2022 -11-06 22 :36:50.374 ] INFO: State Generation - Step 4 of 16 : LegacyVote 1 | solar-relay | [ 2022 -11-06 22 :36:50.384 ] INFO: State Generation - Step 5 of 16 : MultiSignature 1 | solar-relay | [ 2022 -11-06 22 :36:50.391 ] INFO: State Generation - Step 6 of 16 : Ipfs 1 | solar-relay | [ 2022 -11-06 22 :36:50.393 ] INFO: State Generation - Step 7 of 16 : Transfer 1 | solar-relay | [ 2022 -11-06 22 :36:50.396 ] INFO: State Generation - Step 8 of 16 : DelegateResignation 1 | solar-relay | [ 2022 -11-06 22 :36:50.397 ] INFO: State Generation - Step 9 of 16 : HtlcLock 1 | solar-relay | [ 2022 -11-06 22 :36:50.401 ] INFO: State Generation - Step 10 of 16 : HtlcClaim 1 | solar-relay | [ 2022 -11-06 22 :36:50.404 ] INFO: State Generation - Step 11 of 16 : HtlcRefund 1 | solar-relay | [ 2022 -11-06 22 :36:50.407 ] INFO: State Generation - Step 12 of 16 : Burn 1 | solar-relay | [ 2022 -11-06 22 :36:50.409 ] INFO: State Generation - Step 13 of 16 : Vote 1 | solar-relay | [ 2022 -11-06 22 :36:50.410 ] INFO: State Generation - Step 14 of 16 : Fees & Nonces 1 | solar-relay | [ 2022 -11-06 22 :36:50.412 ] INFO: State Generation - Step 15 of 16 : Block Rewards 1 | solar-relay | [ 2022 -11-06 22 :36:50.414 ] INFO: State Generation - Step 16 of 16 : Vote Balances & Delegate Ranking 1 | solar-relay | [ 2022 -11-06 22 :36:50.418 ] INFO: Number of registered delegates: 53 1 | solar-relay | [ 2022 -11-06 22 :36:50.420 ] INFO: Calculating productivity data \ud83e\uddee 1 | solar-relay | [ 2022 -11-06 22 :36:50.440 ] DEBUG: Loaded 53 active delegates 1 | solar-relay | [ 2022 -11-06 22 :36:50.446 ] INFO: Starting Round 1 \ud83d\udd4a\ufe0f 1 | solar-relay | [ 2022 -11-06 22 :36:50.448 ] DEBUG: Loaded 53 active delegates 1 | solar-relay | [ 2022 -11-06 22 :36:50.449 ] INFO: Saving round 1 1 | solar-relay | [ 2022 -11-06 22 :36:50.655 ] INFO: Your network connectivity has been verified by 8 .8.4.4 \u2705 ... 1 | solar-re | [ 2022 -11-06 22 :40:46.370 ] DEBUG: Delegate bfx is allowed to forge block 76 ,805 \ud83d\udc4d 1 | solar-re | [ 2022 -11-06 22 :40:46.371 ] DEBUG: Delegate sxp is allowed to forge block 76 ,807 \ud83d\udc4d 1 | solar-re | [ 2022 -11-06 22 :40:46.372 ] DEBUG: Delegate sl33p is allowed to forge block 76 ,809 \ud83d\udc4d 1 | solar-re | [ 2022 -11-06 22 :40:46.373 ] DEBUG: Delegate advin is allowed to forge block 76 ,816 \ud83d\udc4d 1 | solar-re | [ 2022 -11-06 22 :40:46.383 ] DEBUG: Delegate cactus1549 is allowed to forge block 76 ,819 \ud83d\udc4d ... info Synchronisation of the blockchain can take some time. Once synchronised, the `allowed to forge block ...` messages will be logged every ~8 seconds \u2014 as opposed to milliseconds apart shown during sync. A single round consists of 53 delegates, each forging a single block.","title":"Success"},{"location":"core/installation/variables/","text":"Database Variables \u00b6 CORE_API_CACHE \u00b6 This variable determines if the API makes use of caching to improve performance. CORE_API_DISABLED \u00b6 This variable determines if the API is enabled. CORE_API_HOST \u00b6 This variable determines the host at which the API will listen for traffic. CORE_API_NO_ESTIMATED_TOTAL_COUNT \u00b6 This variable determines if estimated counts should be used. This greatly enhanced performance will yield in inaccurate counts. CORE_API_PORT \u00b6 This variable determines the port at which the API will listen for traffic. CORE_API_RATE_LIMIT_BLACKLIST \u00b6 This variable determines which IP addresses are unable to send any requests to the API. CORE_API_RATE_LIMIT_DISABLED \u00b6 This variable determines if rate limiting is disabled. CORE_API_RATE_LIMIT_USER_EXPIRES \u00b6 This variable determines how long it takes before the rate limiting expires. CORE_API_RATE_LIMIT_USER_LIMIT \u00b6 This variable determines how many requests a user can send for any given period. CORE_API_RATE_LIMIT_WHITELIST \u00b6 This variable determines which user are exempted from rate limiting. CORE_API_SSL \u00b6 This variable determines if SSL (HTTPS) is enabled. CORE_API_SSL_CERT \u00b6 This variable determines where the SSL Certification is located. CORE_API_SSL_HOST \u00b6 This variable determines the host at which the HTTPS API will listen for traffic. CORE_API_SSL_KEY \u00b6 This variable determines where the SSL Key is located. CORE_API_SSL_PORT \u00b6 This variable determines the host at which the HTTPS API will listen for traffic. CORE_DB_DATABASE \u00b6 This variable determines what database will be used for database communication. CORE_DB_HOST \u00b6 This variable determines what host will be used for database communication. CORE_DB_PASSWORD \u00b6 This variable determines what password will be used for database communication. CORE_DB_PORT \u00b6 This variable determines what port will be used for database communication. CORE_DB_USERNAME \u00b6 This variable determines what username will be used for database communication. CORE_LOG_LEVEL \u00b6 This variable determines the severity of messages that are logged. CORE_LOG_LEVEL_FILE \u00b6 This variable determines where the log files are stored. CORE_MAX_TRANSACTIONS_IN_POOL \u00b6 This variable determines how many transactions can be in the transaction pool at any given time. CORE_MANAGER_ARCHIVE_FORMAT \u00b6 This variable determines which archive format is used for storing logs. CORE_MANAGER_DISABLED \u00b6 This variable determines if the Manager API is disabled. CORE_MANAGER_HOST \u00b6 This variable determines the host at which the Manager API will be listening for traffic. CORE_MANAGER_PORT \u00b6 This variable determines the port at which the Manager API will be listening for traffic. CORE_MANAGER_PUBLIC_IP \u00b6 This variable determines the public ip of host. CORE_MANAGER_SSL \u00b6 This variable determines if SSL (HTTPS) is enabled for the Manager API. CORE_MANAGER_SSL_CERT \u00b6 This variable determines where the SSL Certification is located. CORE_MANAGER_SSL_HOST \u00b6 This variable determines the host at which the HTTPS Manager API will be listening for traffic. CORE_MANAGER_SSL_KEY \u00b6 This variable determines where the SSL Key is located. CORE_MANAGER_SSL_PORT \u00b6 This variable determines the port at which the HTTPS Manager API will be listening for traffic. CORE_NETWORK_NAME \u00b6 This variable is exposed by core and cannot be manually configured. This variable exposes the name of the network that has been configured. CORE_NPM_REGISTRY \u00b6 This variable determines which NPM registry url should be used. CORE_P2P_HOST \u00b6 This variable determines the host at which the P2P API will be listening for traffic. CORE_P2P_MAX_PEER_SEQUENTIAL_ERRORS \u00b6 This variable determines how many errors a peer can cause before it is disconnected. CORE_P2P_MAX_PEERS_SAME_SUBNET \u00b6 This variable determines how many peers from the same subnet are allowed to connect. CORE_P2P_MIN_NETWORK_REACH \u00b6 This variable determines minimum number of peers that should be connected. CORE_P2P_PORT \u00b6 This variable determines the port at which the P2P API will be listening for traffic. CORE_P2P_RATE_LIMIT \u00b6 This variable determines how many requests per second can be sent by a peer. CORE_P2P_RATE_LIMIT_POST_TRANSACTIONS \u00b6 This variable determines how many transaction requests per second can be sent by a peer. CORE_PATH_DATA \u00b6 This variable is exposed by core and cannot be manually configured. This variable exposes the path at which core stores application data. CORE_RESET_DATABASE \u00b6 This variable determines if database should be truncated at boot. CORE_TOKEN \u00b6 This variable is exposed by core and cannot be manually configured. This variable determines the name of the token. CORE_TRANSACTION_POOL_DISABLED \u00b6 This variable determines if the transaction pool should be disabled. CORE_TRANSACTION_POOL_MAX_PER_REQUEST \u00b6 This variable determines how many transactions can be broadcast in a single request. CORE_TRANSACTION_POOL_MAX_PER_SENDER \u00b6 This variable determines how many transactions can be in the transaction pool by a single sender. CORE_WALLET_SYNC_ENABLED \u00b6 This variable determines if wallets should be synced to the database. CORE_WATCH_BLOCKS_DISABLED \u00b6 This variable determines if monitoring of blocks is disabled. CORE_WATCH_ERRORS_DISABLED \u00b6 This variable determines if monitoring of errors is disabled. CORE_WATCH_LOGS_DISABLED \u00b6 This variable determines if monitoring of logs is disabled. CORE_WATCH_QUERIES_DISABLED \u00b6 This variable determines if monitoring of queries is disabled. CORE_WATCH_QUEUES_DISABLED \u00b6 This variable determines if monitoring of queues is disabled. CORE_WATCH_ROUNDS_DISABLED \u00b6 This variable determines if monitoring of rounds is disabled. CORE_WATCH_SCHEDULES_DISABLED \u00b6 This variable determines if monitoring of schedules is disabled. CORE_WATCH_TRANSACTIONS_DISABLED \u00b6 This variable determines if monitoring of transactions is disabled. CORE_WATCH_WALLETS_DISABLED \u00b6 This variable determines if monitoring of wallets is disabled. CORE_WATCH_WEBHOOKS_DISABLED \u00b6 This variable determines if monitoring of webhooks is disabled. CORE_WATCHER_ENABLED \u00b6 This variable determines if monitoring is enabled. CORE_WEBHOOKS_ENABLED \u00b6 This variable determines if webhooks are enabled. CORE_WEBHOOKS_HOST \u00b6 This variable determines the host at which the Webhook API will be listening for traffic. CORE_WEBHOOKS_PORT \u00b6 This variable determines the port at which the Webhook API will be listening for traffic. CORE_WEBHOOKS_TIMEOUT \u00b6 This variable determines how long it will take for a request to timeout when trying to transmit a webhook payload.","title":"Database Variables"},{"location":"core/installation/variables/#database-variables","text":"","title":"Database Variables"},{"location":"core/installation/variables/#core_api_cache","text":"This variable determines if the API makes use of caching to improve performance.","title":"CORE_API_CACHE"},{"location":"core/installation/variables/#core_api_disabled","text":"This variable determines if the API is enabled.","title":"CORE_API_DISABLED"},{"location":"core/installation/variables/#core_api_host","text":"This variable determines the host at which the API will listen for traffic.","title":"CORE_API_HOST"},{"location":"core/installation/variables/#core_api_no_estimated_total_count","text":"This variable determines if estimated counts should be used. This greatly enhanced performance will yield in inaccurate counts.","title":"CORE_API_NO_ESTIMATED_TOTAL_COUNT"},{"location":"core/installation/variables/#core_api_port","text":"This variable determines the port at which the API will listen for traffic.","title":"CORE_API_PORT"},{"location":"core/installation/variables/#core_api_rate_limit_blacklist","text":"This variable determines which IP addresses are unable to send any requests to the API.","title":"CORE_API_RATE_LIMIT_BLACKLIST"},{"location":"core/installation/variables/#core_api_rate_limit_disabled","text":"This variable determines if rate limiting is disabled.","title":"CORE_API_RATE_LIMIT_DISABLED"},{"location":"core/installation/variables/#core_api_rate_limit_user_expires","text":"This variable determines how long it takes before the rate limiting expires.","title":"CORE_API_RATE_LIMIT_USER_EXPIRES"},{"location":"core/installation/variables/#core_api_rate_limit_user_limit","text":"This variable determines how many requests a user can send for any given period.","title":"CORE_API_RATE_LIMIT_USER_LIMIT"},{"location":"core/installation/variables/#core_api_rate_limit_whitelist","text":"This variable determines which user are exempted from rate limiting.","title":"CORE_API_RATE_LIMIT_WHITELIST"},{"location":"core/installation/variables/#core_api_ssl","text":"This variable determines if SSL (HTTPS) is enabled.","title":"CORE_API_SSL"},{"location":"core/installation/variables/#core_api_ssl_cert","text":"This variable determines where the SSL Certification is located.","title":"CORE_API_SSL_CERT"},{"location":"core/installation/variables/#core_api_ssl_host","text":"This variable determines the host at which the HTTPS API will listen for traffic.","title":"CORE_API_SSL_HOST"},{"location":"core/installation/variables/#core_api_ssl_key","text":"This variable determines where the SSL Key is located.","title":"CORE_API_SSL_KEY"},{"location":"core/installation/variables/#core_api_ssl_port","text":"This variable determines the host at which the HTTPS API will listen for traffic.","title":"CORE_API_SSL_PORT"},{"location":"core/installation/variables/#core_db_database","text":"This variable determines what database will be used for database communication.","title":"CORE_DB_DATABASE"},{"location":"core/installation/variables/#core_db_host","text":"This variable determines what host will be used for database communication.","title":"CORE_DB_HOST"},{"location":"core/installation/variables/#core_db_password","text":"This variable determines what password will be used for database communication.","title":"CORE_DB_PASSWORD"},{"location":"core/installation/variables/#core_db_port","text":"This variable determines what port will be used for database communication.","title":"CORE_DB_PORT"},{"location":"core/installation/variables/#core_db_username","text":"This variable determines what username will be used for database communication.","title":"CORE_DB_USERNAME"},{"location":"core/installation/variables/#core_log_level","text":"This variable determines the severity of messages that are logged.","title":"CORE_LOG_LEVEL"},{"location":"core/installation/variables/#core_log_level_file","text":"This variable determines where the log files are stored.","title":"CORE_LOG_LEVEL_FILE"},{"location":"core/installation/variables/#core_max_transactions_in_pool","text":"This variable determines how many transactions can be in the transaction pool at any given time.","title":"CORE_MAX_TRANSACTIONS_IN_POOL"},{"location":"core/installation/variables/#core_manager_archive_format","text":"This variable determines which archive format is used for storing logs.","title":"CORE_MANAGER_ARCHIVE_FORMAT"},{"location":"core/installation/variables/#core_manager_disabled","text":"This variable determines if the Manager API is disabled.","title":"CORE_MANAGER_DISABLED"},{"location":"core/installation/variables/#core_manager_host","text":"This variable determines the host at which the Manager API will be listening for traffic.","title":"CORE_MANAGER_HOST"},{"location":"core/installation/variables/#core_manager_port","text":"This variable determines the port at which the Manager API will be listening for traffic.","title":"CORE_MANAGER_PORT"},{"location":"core/installation/variables/#core_manager_public_ip","text":"This variable determines the public ip of host.","title":"CORE_MANAGER_PUBLIC_IP"},{"location":"core/installation/variables/#core_manager_ssl","text":"This variable determines if SSL (HTTPS) is enabled for the Manager API.","title":"CORE_MANAGER_SSL"},{"location":"core/installation/variables/#core_manager_ssl_cert","text":"This variable determines where the SSL Certification is located.","title":"CORE_MANAGER_SSL_CERT"},{"location":"core/installation/variables/#core_manager_ssl_host","text":"This variable determines the host at which the HTTPS Manager API will be listening for traffic.","title":"CORE_MANAGER_SSL_HOST"},{"location":"core/installation/variables/#core_manager_ssl_key","text":"This variable determines where the SSL Key is located.","title":"CORE_MANAGER_SSL_KEY"},{"location":"core/installation/variables/#core_manager_ssl_port","text":"This variable determines the port at which the HTTPS Manager API will be listening for traffic.","title":"CORE_MANAGER_SSL_PORT"},{"location":"core/installation/variables/#core_network_name","text":"This variable is exposed by core and cannot be manually configured. This variable exposes the name of the network that has been configured.","title":"CORE_NETWORK_NAME"},{"location":"core/installation/variables/#core_npm_registry","text":"This variable determines which NPM registry url should be used.","title":"CORE_NPM_REGISTRY"},{"location":"core/installation/variables/#core_p2p_host","text":"This variable determines the host at which the P2P API will be listening for traffic.","title":"CORE_P2P_HOST"},{"location":"core/installation/variables/#core_p2p_max_peer_sequential_errors","text":"This variable determines how many errors a peer can cause before it is disconnected.","title":"CORE_P2P_MAX_PEER_SEQUENTIAL_ERRORS"},{"location":"core/installation/variables/#core_p2p_max_peers_same_subnet","text":"This variable determines how many peers from the same subnet are allowed to connect.","title":"CORE_P2P_MAX_PEERS_SAME_SUBNET"},{"location":"core/installation/variables/#core_p2p_min_network_reach","text":"This variable determines minimum number of peers that should be connected.","title":"CORE_P2P_MIN_NETWORK_REACH"},{"location":"core/installation/variables/#core_p2p_port","text":"This variable determines the port at which the P2P API will be listening for traffic.","title":"CORE_P2P_PORT"},{"location":"core/installation/variables/#core_p2p_rate_limit","text":"This variable determines how many requests per second can be sent by a peer.","title":"CORE_P2P_RATE_LIMIT"},{"location":"core/installation/variables/#core_p2p_rate_limit_post_transactions","text":"This variable determines how many transaction requests per second can be sent by a peer.","title":"CORE_P2P_RATE_LIMIT_POST_TRANSACTIONS"},{"location":"core/installation/variables/#core_path_data","text":"This variable is exposed by core and cannot be manually configured. This variable exposes the path at which core stores application data.","title":"CORE_PATH_DATA"},{"location":"core/installation/variables/#core_reset_database","text":"This variable determines if database should be truncated at boot.","title":"CORE_RESET_DATABASE"},{"location":"core/installation/variables/#core_token","text":"This variable is exposed by core and cannot be manually configured. This variable determines the name of the token.","title":"CORE_TOKEN"},{"location":"core/installation/variables/#core_transaction_pool_disabled","text":"This variable determines if the transaction pool should be disabled.","title":"CORE_TRANSACTION_POOL_DISABLED"},{"location":"core/installation/variables/#core_transaction_pool_max_per_request","text":"This variable determines how many transactions can be broadcast in a single request.","title":"CORE_TRANSACTION_POOL_MAX_PER_REQUEST"},{"location":"core/installation/variables/#core_transaction_pool_max_per_sender","text":"This variable determines how many transactions can be in the transaction pool by a single sender.","title":"CORE_TRANSACTION_POOL_MAX_PER_SENDER"},{"location":"core/installation/variables/#core_wallet_sync_enabled","text":"This variable determines if wallets should be synced to the database.","title":"CORE_WALLET_SYNC_ENABLED"},{"location":"core/installation/variables/#core_watch_blocks_disabled","text":"This variable determines if monitoring of blocks is disabled.","title":"CORE_WATCH_BLOCKS_DISABLED"},{"location":"core/installation/variables/#core_watch_errors_disabled","text":"This variable determines if monitoring of errors is disabled.","title":"CORE_WATCH_ERRORS_DISABLED"},{"location":"core/installation/variables/#core_watch_logs_disabled","text":"This variable determines if monitoring of logs is disabled.","title":"CORE_WATCH_LOGS_DISABLED"},{"location":"core/installation/variables/#core_watch_queries_disabled","text":"This variable determines if monitoring of queries is disabled.","title":"CORE_WATCH_QUERIES_DISABLED"},{"location":"core/installation/variables/#core_watch_queues_disabled","text":"This variable determines if monitoring of queues is disabled.","title":"CORE_WATCH_QUEUES_DISABLED"},{"location":"core/installation/variables/#core_watch_rounds_disabled","text":"This variable determines if monitoring of rounds is disabled.","title":"CORE_WATCH_ROUNDS_DISABLED"},{"location":"core/installation/variables/#core_watch_schedules_disabled","text":"This variable determines if monitoring of schedules is disabled.","title":"CORE_WATCH_SCHEDULES_DISABLED"},{"location":"core/installation/variables/#core_watch_transactions_disabled","text":"This variable determines if monitoring of transactions is disabled.","title":"CORE_WATCH_TRANSACTIONS_DISABLED"},{"location":"core/installation/variables/#core_watch_wallets_disabled","text":"This variable determines if monitoring of wallets is disabled.","title":"CORE_WATCH_WALLETS_DISABLED"},{"location":"core/installation/variables/#core_watch_webhooks_disabled","text":"This variable determines if monitoring of webhooks is disabled.","title":"CORE_WATCH_WEBHOOKS_DISABLED"},{"location":"core/installation/variables/#core_watcher_enabled","text":"This variable determines if monitoring is enabled.","title":"CORE_WATCHER_ENABLED"},{"location":"core/installation/variables/#core_webhooks_enabled","text":"This variable determines if webhooks are enabled.","title":"CORE_WEBHOOKS_ENABLED"},{"location":"core/installation/variables/#core_webhooks_host","text":"This variable determines the host at which the Webhook API will be listening for traffic.","title":"CORE_WEBHOOKS_HOST"},{"location":"core/installation/variables/#core_webhooks_port","text":"This variable determines the port at which the Webhook API will be listening for traffic.","title":"CORE_WEBHOOKS_PORT"},{"location":"core/installation/variables/#core_webhooks_timeout","text":"This variable determines how long it will take for a request to timeout when trying to transmit a webhook payload.","title":"CORE_WEBHOOKS_TIMEOUT"},{"location":"core/transactions/lifecycle/","text":"Understanding the Transaction Lifecycle \u00b6 Describing Transaction's Journey From Client to Core Server (Blockchain) \u2705 SUCCESS - A transaction is an atomic change in the state of the blockchain. The simplest form transfers value from address A to B, incorporating a fee for the processing. Transactions are bundled into a block. At that moment they are committed to the blockchain and become irreversible. All valid transactions are begin submitted as payload data via the Public REST API . This valid transactions end as immutable history on the blockchain (are included in blocks). While the implementation specifics will depend on the platform used to submit the transaction, SXP's extensive SDK coverage ensures that developers experience a unified workflow across languages and platforms. In the next sections we will look into the transaction lifecycle from creation to final inclusion in the blocks. Transaction Journey From Client To Blockchain \u00b6 1. Create and Sign Transaction Locally \u00b6 Transactions are generated and signed locally with one of many available SDK libraries . Locally generated and signed transactions are sent as a POST request with transaction data to the Core Server node. \ud83d\uded1 DANGER - Core Server (node) will accept a valid transaction, signed with a valid signature from a private key. Make sure you invoke the SDK builder's sign method on your transaction object using the sender's private key. 2. Receive and Validate Transaction on The Core Server \u00b6 Transactions are received at the POST transactions endpoint of the Public API. From there all requests are first validated by the API endpoint schema. Each endpoint schema defines the structure that requests should conform to. Transaction flow in short: Transaction Payload is received at the Core Server ( Public API Endpoint ) API Handler validates schema and sends transaction to the TransactionProcessor TransactionProcessor performs additional transaction payload checks in relation to the blockchain protocol. If all check are valid, transaction is added to the Transaction Pool \u2705 SUCCESS - All Client SDKs already create API requests to conform to this standard, so following the SDK guidelines will typically result in your transaction passing validation. Notably, no blockchain-level validation occurs at this earliest stage in the transaction lifecycle. Request validation ensures that your POST request can be understood by the network, not that the data it contains represents a valid transaction. This task falls to the next class to handle transaction requests: the TransactionProcessor from the core-transaction-pool package. Assuming validation is successful, the posted transactions are processed by the request handler, which passes the data to the TransactionProcessor for validation. All transactions submitted to the TransactionProcessor are returned in one of four arrays : accept broadcast excess invalid Internally, the TransactionProcessor processes transactions in its validate method by separating: transactions already in the pool transactions from blocked senders transactions from the future transactions with low fees for broadcast/pool inclusion transactions that fail to conform to their transaction type \u2139\ufe0f INFO - At this point, Core Server has a list of incoming transactions to add to the transaction pool. TransactionProcessor now checks the pool to see whether it is at capacity. If so, it compares the incoming transactions against the pooled transactions and removes the transactions with the lowest fees. 3. From TransactionPool To Transaction Inclusion Within Blocks \u00b6 Transactions move out of the pool once a forging Delegate (a forger) is ready and eligible to forge it. At the moment of forging, transactions in the forger's pool are grouped into a potential block and passed to the delegate's forge method for inclusion in a block. Inside the forge method, all transaction values, fees, and IDs within the block are added together. The values and fees are used to calculate block metadata, while the hashed IDs are concatenated and used as the block's payloadHash property. With this information in hand, the block data and sorted transactions are passed to the crypto library's Block.create method alongside the forging delegate's keys. 4. Block Creation \u00b6 A block is a collection of transactions, but also it is the incremental unit of the blockchain. Every eight seconds, a Delegate Node (Forging Node) creates a new block by bundling a bunch of transactions, verifying each transaction, and signing the block. Blocks hold quite a lot of metadata on the SXP blockchain, like: Height, an incremental ID. Timestamp. Transactions. Creator's signature. Total transfer amount. Total fee amount. The Block.create method uses the following algorithm to create a new block: Derive the delegate's public key from the function's keys parameter. Create a payload hash by serializing the block data into a binary-encoded format. Create a SHA256 hash by using the payload hash as input. Sign the SHA256 hash with the delegate's private key. Create a block ID using the hashed block data. Cast the data into a Block model using the new transaction and block ID. Return the cast Block object. Here, the cryptographic functions used by SXP to generate hashes are identical to those used by Bitcoin. These functions are battle-tested by years of use and analysis in Bitcoin. Resources to learn more about the block creation process can be found in Bitcoin educational materials as well as relevant SXP documentation on serialization. 5. Block Propagation \u00b6 With the forged block successfully returned to the forger library, the only remaining responsibility is to let the network know about the new block - block propagation. The forged block is relayed to peers through the P2P layer following blockchain protocol mechanics.","title":"Understanding the Lifecycle"},{"location":"core/transactions/lifecycle/#understanding-the-transaction-lifecycle","text":"Describing Transaction's Journey From Client to Core Server (Blockchain) \u2705 SUCCESS - A transaction is an atomic change in the state of the blockchain. The simplest form transfers value from address A to B, incorporating a fee for the processing. Transactions are bundled into a block. At that moment they are committed to the blockchain and become irreversible. All valid transactions are begin submitted as payload data via the Public REST API . This valid transactions end as immutable history on the blockchain (are included in blocks). While the implementation specifics will depend on the platform used to submit the transaction, SXP's extensive SDK coverage ensures that developers experience a unified workflow across languages and platforms. In the next sections we will look into the transaction lifecycle from creation to final inclusion in the blocks.","title":"Understanding the Transaction Lifecycle"},{"location":"core/transactions/lifecycle/#transaction-journey-from-client-to-blockchain","text":"","title":"Transaction Journey From Client To Blockchain"},{"location":"core/transactions/lifecycle/#1-create-and-sign-transaction-locally","text":"Transactions are generated and signed locally with one of many available SDK libraries . Locally generated and signed transactions are sent as a POST request with transaction data to the Core Server node. \ud83d\uded1 DANGER - Core Server (node) will accept a valid transaction, signed with a valid signature from a private key. Make sure you invoke the SDK builder's sign method on your transaction object using the sender's private key.","title":"1. Create and Sign Transaction Locally"},{"location":"core/transactions/lifecycle/#2-receive-and-validate-transaction-on-the-core-server","text":"Transactions are received at the POST transactions endpoint of the Public API. From there all requests are first validated by the API endpoint schema. Each endpoint schema defines the structure that requests should conform to. Transaction flow in short: Transaction Payload is received at the Core Server ( Public API Endpoint ) API Handler validates schema and sends transaction to the TransactionProcessor TransactionProcessor performs additional transaction payload checks in relation to the blockchain protocol. If all check are valid, transaction is added to the Transaction Pool \u2705 SUCCESS - All Client SDKs already create API requests to conform to this standard, so following the SDK guidelines will typically result in your transaction passing validation. Notably, no blockchain-level validation occurs at this earliest stage in the transaction lifecycle. Request validation ensures that your POST request can be understood by the network, not that the data it contains represents a valid transaction. This task falls to the next class to handle transaction requests: the TransactionProcessor from the core-transaction-pool package. Assuming validation is successful, the posted transactions are processed by the request handler, which passes the data to the TransactionProcessor for validation. All transactions submitted to the TransactionProcessor are returned in one of four arrays : accept broadcast excess invalid Internally, the TransactionProcessor processes transactions in its validate method by separating: transactions already in the pool transactions from blocked senders transactions from the future transactions with low fees for broadcast/pool inclusion transactions that fail to conform to their transaction type \u2139\ufe0f INFO - At this point, Core Server has a list of incoming transactions to add to the transaction pool. TransactionProcessor now checks the pool to see whether it is at capacity. If so, it compares the incoming transactions against the pooled transactions and removes the transactions with the lowest fees.","title":"2. Receive and Validate Transaction on The Core Server"},{"location":"core/transactions/lifecycle/#3-from-transactionpool-to-transaction-inclusion-within-blocks","text":"Transactions move out of the pool once a forging Delegate (a forger) is ready and eligible to forge it. At the moment of forging, transactions in the forger's pool are grouped into a potential block and passed to the delegate's forge method for inclusion in a block. Inside the forge method, all transaction values, fees, and IDs within the block are added together. The values and fees are used to calculate block metadata, while the hashed IDs are concatenated and used as the block's payloadHash property. With this information in hand, the block data and sorted transactions are passed to the crypto library's Block.create method alongside the forging delegate's keys.","title":"3. From TransactionPool To Transaction Inclusion Within Blocks"},{"location":"core/transactions/lifecycle/#4-block-creation","text":"A block is a collection of transactions, but also it is the incremental unit of the blockchain. Every eight seconds, a Delegate Node (Forging Node) creates a new block by bundling a bunch of transactions, verifying each transaction, and signing the block. Blocks hold quite a lot of metadata on the SXP blockchain, like: Height, an incremental ID. Timestamp. Transactions. Creator's signature. Total transfer amount. Total fee amount. The Block.create method uses the following algorithm to create a new block: Derive the delegate's public key from the function's keys parameter. Create a payload hash by serializing the block data into a binary-encoded format. Create a SHA256 hash by using the payload hash as input. Sign the SHA256 hash with the delegate's private key. Create a block ID using the hashed block data. Cast the data into a Block model using the new transaction and block ID. Return the cast Block object. Here, the cryptographic functions used by SXP to generate hashes are identical to those used by Bitcoin. These functions are battle-tested by years of use and analysis in Bitcoin. Resources to learn more about the block creation process can be found in Bitcoin educational materials as well as relevant SXP documentation on serialization.","title":"4. Block Creation"},{"location":"core/transactions/lifecycle/#5-block-propagation","text":"With the forged block successfully returned to the forger library, the only remaining responsibility is to let the network know about the new block - block propagation. The forged block is relayed to peers through the P2P layer following blockchain protocol mechanics.","title":"5. Block Propagation"},{"location":"core/transactions/nonce/","text":"Understanding the Transaction Nonce \u00b6 SXP transactions use a sequential nonce to protect against double-spending , long-range attacks, key-leakage as a result of signature reuse, and side-channel attacks associated with random nonces. A sequential nonce effectively counts each outgoing transaction from a given wallet. This means that the first transaction from a wallet must have a nonce of 1 , the second transaction must have a nonce of 2 , and so on. This ensures that the data contained within a particular transaction will always be unique and thus results in a distinct hash that will necessarily produce a unique signature. key facts : The 1 st transaction from a wallet must have a nonce of 1 . The nonce must increment sequentially for every subsequent transaction being sent. ( e.g. 2, 3, 4, 5, 6, 7, ... ) A nonce cannot be reused. A nonce cannot be skipped. ( a transaction with a nonce of 5 originating from a wallet with a nonce of 3 will be rejected. ) funky stuff here: The 1 st transaction from a wallet must have a nonce of 1 . The nonce must increment sequentially for every subsequent transaction being sent. e.g. 2, 3, 4, 5, 6, 7, ... A nonce cannot be skipped. a transaction with a nonce of 5 originating from a wallet with a nonce of 3 will be rejected. A nonce cannot be reused. How To Get Nonce Value For An Address? \u00b6 A sequential nonce depends on the amount of transaction a specific wallet has sent. You can find the current nonce for a wallet by utilising the Public API, more specifically the wallet endpoint . The wallet endpoint returns the wallet details, including the current wallets nonce field, like below: { \"data\" : { \"address\" : \"D8rr7B1d6TL6pf14LgMz4sKp1VBMs6YUYD\" , \"publicKey\" : \"03df6cd794a7d404db4f1b25816d8976d0e72c5177d17ac9b19a92703b62cdbbbc\" , \"nonce\" : \"123\" , // THIS IS WALLETS CURRENT NONCE VALUE \"balance\" : \"7919999400\" , \"attributes\" : { ... ... ... }, \"lockedBalance\" : \"0\" , \"isDelegate\" : false , \"isResigned\" : false } } How To Set Nonce Value? \u00b6 When you create a new transaction for that wallet, you will use the current nonce and add 1 to it to get to the new nonce value. \u2139\ufe0f INFO - If you retrieved a nonce value of 123 for a wallet, the next transaction will have to use nonce 124, (current_nonce + 1). The API will increase the nonce value once a transaction has been forged for the wallet. Sending Multiple Transactions \u00b6 You have to keep track locally of the next nonce value in case you intend to send multiple transactions in a single block. For example, we have a wallet with nonce 123 and want to send 3 transactions to be forged in the next block. These transactions will require nonce values 124, 125 and 126 respectively, and you will have to set the values, before creating transactions. After the block is forged, the API will report the current nonce of the wallet to be 126.","title":"Understanding the Nonce"},{"location":"core/transactions/nonce/#understanding-the-transaction-nonce","text":"SXP transactions use a sequential nonce to protect against double-spending , long-range attacks, key-leakage as a result of signature reuse, and side-channel attacks associated with random nonces. A sequential nonce effectively counts each outgoing transaction from a given wallet. This means that the first transaction from a wallet must have a nonce of 1 , the second transaction must have a nonce of 2 , and so on. This ensures that the data contained within a particular transaction will always be unique and thus results in a distinct hash that will necessarily produce a unique signature. key facts : The 1 st transaction from a wallet must have a nonce of 1 . The nonce must increment sequentially for every subsequent transaction being sent. ( e.g. 2, 3, 4, 5, 6, 7, ... ) A nonce cannot be reused. A nonce cannot be skipped. ( a transaction with a nonce of 5 originating from a wallet with a nonce of 3 will be rejected. ) funky stuff here: The 1 st transaction from a wallet must have a nonce of 1 . The nonce must increment sequentially for every subsequent transaction being sent. e.g. 2, 3, 4, 5, 6, 7, ... A nonce cannot be skipped. a transaction with a nonce of 5 originating from a wallet with a nonce of 3 will be rejected. A nonce cannot be reused.","title":"Understanding the Transaction Nonce"},{"location":"core/transactions/nonce/#how-to-get-nonce-value-for-an-address","text":"A sequential nonce depends on the amount of transaction a specific wallet has sent. You can find the current nonce for a wallet by utilising the Public API, more specifically the wallet endpoint . The wallet endpoint returns the wallet details, including the current wallets nonce field, like below: { \"data\" : { \"address\" : \"D8rr7B1d6TL6pf14LgMz4sKp1VBMs6YUYD\" , \"publicKey\" : \"03df6cd794a7d404db4f1b25816d8976d0e72c5177d17ac9b19a92703b62cdbbbc\" , \"nonce\" : \"123\" , // THIS IS WALLETS CURRENT NONCE VALUE \"balance\" : \"7919999400\" , \"attributes\" : { ... ... ... }, \"lockedBalance\" : \"0\" , \"isDelegate\" : false , \"isResigned\" : false } }","title":"How To Get Nonce Value For An Address?"},{"location":"core/transactions/nonce/#how-to-set-nonce-value","text":"When you create a new transaction for that wallet, you will use the current nonce and add 1 to it to get to the new nonce value. \u2139\ufe0f INFO - If you retrieved a nonce value of 123 for a wallet, the next transaction will have to use nonce 124, (current_nonce + 1). The API will increase the nonce value once a transaction has been forged for the wallet.","title":"How To Set Nonce Value?"},{"location":"core/transactions/nonce/#sending-multiple-transactions","text":"You have to keep track locally of the next nonce value in case you intend to send multiple transactions in a single block. For example, we have a wallet with nonce 123 and want to send 3 transactions to be forged in the next block. These transactions will require nonce values 124, 125 and 126 respectively, and you will have to set the values, before creating transactions. After the block is forged, the API will report the current nonce of the wallet to be 126.","title":"Sending Multiple Transactions"},{"location":"core/transactions/types/burn/","text":"Burn \u00b6 TypeGroup Type 2 0 This transaction type allows burning an arbirary amount of SXP tokens. The burned amount is deducted from the sender's wallet as well as from the chain's circulating supply. References API Endpoints Link AJV Schema Base | Burn Json \u00b6 { \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 2 , \"type\" : 0 , \"nonce\" : \"12\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"0\" , \"burnedFee\" : \"0\" , \"amount\" : \"100000000\" } Serialized \u00b6 ff033f0200000000000c00000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed19200000000000000000000e1f50500000000 Deserialized \u00b6 Key Pos. Size (bytes) Value (hex) Header Flag: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x02000000 Type: [7] 2 0x0000 Nonce: [9] 8 0x0c00000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x0000000000000000 VendorField Length: [58] 1 0x00 Amount: [59] 8 0x00e1f50500000000","title":"Transaction Types - Burn"},{"location":"core/transactions/types/burn/#burn","text":"TypeGroup Type 2 0 This transaction type allows burning an arbirary amount of SXP tokens. The burned amount is deducted from the sender's wallet as well as from the chain's circulating supply. References API Endpoints Link AJV Schema Base | Burn","title":"Burn"},{"location":"core/transactions/types/burn/#json","text":"{ \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 2 , \"type\" : 0 , \"nonce\" : \"12\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"0\" , \"burnedFee\" : \"0\" , \"amount\" : \"100000000\" }","title":"Json"},{"location":"core/transactions/types/burn/#serialized","text":"ff033f0200000000000c00000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed19200000000000000000000e1f50500000000","title":"Serialized"},{"location":"core/transactions/types/burn/#deserialized","text":"Key Pos. Size (bytes) Value (hex) Header Flag: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x02000000 Type: [7] 2 0x0000 Nonce: [9] 8 0x0c00000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x0000000000000000 VendorField Length: [58] 1 0x00 Amount: [59] 8 0x00e1f50500000000","title":"Deserialized"},{"location":"core/transactions/types/delegate-registration/","text":"Delegate Registration \u00b6 TypeGroup Type 1 3 A user or organization can register their address to become a delegate and secure the network. Upon accumulating sufficient vote weight, the delegate will begin forging transactions and receiving block rewards. The delegate assigns a custom name to their address to differentiate it from other delegates. References Improvement Proposal AIP11 API Endpoints Link AJV Schema Base | Delegate Registration Transaction Structure \u00b6 Json \u00b6 { \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 1 , \"nonce\" : \"3\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"7500000000\" , \"asset\" : { \"delegate\" : { \"username\" : \"sl33p\" } } } Serialized \u00b6 ff033f0100000002000300000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed19200eb08bf010000000005736c333370 Deserialized \u00b6 Key Pos. Size (bytes) Value (hex) Header Flag: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0200 Nonce: [9] 8 0x0300000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x00eb08bf01000000 VendorField Length: [58] 1 0x00 Username Length: [59] 1 0x05 Username: [60] 5 0x736c333370","title":"Transaction Types - Delegate Registration"},{"location":"core/transactions/types/delegate-registration/#delegate-registration","text":"TypeGroup Type 1 3 A user or organization can register their address to become a delegate and secure the network. Upon accumulating sufficient vote weight, the delegate will begin forging transactions and receiving block rewards. The delegate assigns a custom name to their address to differentiate it from other delegates. References Improvement Proposal AIP11 API Endpoints Link AJV Schema Base | Delegate Registration","title":"Delegate Registration"},{"location":"core/transactions/types/delegate-registration/#transaction-structure","text":"","title":"Transaction Structure"},{"location":"core/transactions/types/delegate-registration/#json","text":"{ \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 1 , \"nonce\" : \"3\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"7500000000\" , \"asset\" : { \"delegate\" : { \"username\" : \"sl33p\" } } }","title":"Json"},{"location":"core/transactions/types/delegate-registration/#serialized","text":"ff033f0100000002000300000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed19200eb08bf010000000005736c333370","title":"Serialized"},{"location":"core/transactions/types/delegate-registration/#deserialized","text":"Key Pos. Size (bytes) Value (hex) Header Flag: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0200 Nonce: [9] 8 0x0300000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x00eb08bf01000000 VendorField Length: [58] 1 0x00 Username Length: [59] 1 0x05 Username: [60] 5 0x736c333370","title":"Deserialized"},{"location":"core/transactions/types/delegate-resignation/","text":"Delegate Resignation \u00b6 TypeGroup Type 1 7 This transaction type enables delegates to block potential voters from voting for them if they choose to withdraw their status as delegates. A non-reversible transaction can be sent to the network to indicate that the delegate should no longer be included in any future forging rounds. This transaction acts as a \"kill command\" for delegates who wish to resign or retire their delegate. Activating a delegate resignation will mean delegates will no longer be able to receive any new votes. Plus, for actively forging delegates, enabling delegate resignation will mean they permanently drop out of the top 53. This provides a clean and simple way to retire a delegate. References Improvement Proposal AIP11 , AIP29 API Endpoints Link AJV Schema Base | Delegate Resignation Transaction Structure \u00b6 Json \u00b6 { \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 1 , \"nonce\" : \"9\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"50000000\" , } Serialized \u00b6 ff033f0100000002000900000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed19280f0fa020000000000eb08bf010000000005736c333370 Deserialized \u00b6 Key Pos. Size (bytes) Value (hex) Header Flag: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0700 Nonce: [9] 8 0x0900000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x80f0fa0200000000 VendorField Length: [58] 1 0x00","title":"Transaction Types - Delegate Resignation"},{"location":"core/transactions/types/delegate-resignation/#delegate-resignation","text":"TypeGroup Type 1 7 This transaction type enables delegates to block potential voters from voting for them if they choose to withdraw their status as delegates. A non-reversible transaction can be sent to the network to indicate that the delegate should no longer be included in any future forging rounds. This transaction acts as a \"kill command\" for delegates who wish to resign or retire their delegate. Activating a delegate resignation will mean delegates will no longer be able to receive any new votes. Plus, for actively forging delegates, enabling delegate resignation will mean they permanently drop out of the top 53. This provides a clean and simple way to retire a delegate. References Improvement Proposal AIP11 , AIP29 API Endpoints Link AJV Schema Base | Delegate Resignation","title":"Delegate Resignation"},{"location":"core/transactions/types/delegate-resignation/#transaction-structure","text":"","title":"Transaction Structure"},{"location":"core/transactions/types/delegate-resignation/#json","text":"{ \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 1 , \"nonce\" : \"9\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"50000000\" , }","title":"Json"},{"location":"core/transactions/types/delegate-resignation/#serialized","text":"ff033f0100000002000900000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed19280f0fa020000000000eb08bf010000000005736c333370","title":"Serialized"},{"location":"core/transactions/types/delegate-resignation/#deserialized","text":"Key Pos. Size (bytes) Value (hex) Header Flag: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0700 Nonce: [9] 8 0x0900000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x80f0fa0200000000 VendorField Length: [58] 1 0x00","title":"Deserialized"},{"location":"core/transactions/types/htlc-claim/","text":"HTLC Claim \u00b6 TypeGroup Type 1 9 A Hashed Time-Lock Contract (HTLC) is a set of transaction types that permits a designated party (the \"sender/seller\") to LOCK funds by disclosing the preimage (secret) of a hash. It also permits a second party (the \"recipient/buyer\") to CLAIM the funds, or after a timeout is reached enter a REFUND situation. The purpose of this transaction is for the recipient to CLAIM funds from the sender - if they know the shared secret. References Improvement Proposal AIP102 API Endpoints Link AJV Schema Base | HTLC Claim JSON \u00b6 { \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 9 , \"nonce\" : \"11\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"0\" , \"asset\" : { \"claim\" : { \"lockTransactionId\" : \"3aade2b98391ba7230252530cdd5124183a9f4e582660666ae873da48173ea5f\" , \"unlockSecret\" : \"c27f1ce845d8c29eebc9006be932b604fd06755521b1a8b0be4204c65377151a\" } } } Serialized \u00b6 ff033f0100000009000b00000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192000000000000000000003aade2b98391ba7230252530cdd5124183a9f4e582660666ae873da48173ea5f20c27f1ce845d8c29eebc9006be932b604fd06755521b1a8b0be4204c65377151a Deserialized \u00b6 Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f TypeGroup: [3] 4 0x01000000 Type: [7] 2 0x0900 Nonce: [9] 8 0x0b00000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x0000000000000000 VendorField Length: [58] 1 0x00 Hash Type: [59] 1 0x00 Lock Id: [60] 32 0x3aade2b98391ba7230252530cdd5124183a9f4e582660666ae873da48173ea5f Unlock Secret Length: [92] 1 0x20 Unlock Secret: [93] 32 0xc27f1ce845d8c29eebc9006be932b604fd06755521b1a8b0be4204c65377151a Supported Hash Types \u00b6 Hash Type Value SHA256 0 SHA384 1 SHA512 2 SHA3256 3 SHA3384 4 SHA3512 5 Keccak256 6 Keccak384 7 Keccak512 8","title":"Transaction Types - HTLC Claim"},{"location":"core/transactions/types/htlc-claim/#htlc-claim","text":"TypeGroup Type 1 9 A Hashed Time-Lock Contract (HTLC) is a set of transaction types that permits a designated party (the \"sender/seller\") to LOCK funds by disclosing the preimage (secret) of a hash. It also permits a second party (the \"recipient/buyer\") to CLAIM the funds, or after a timeout is reached enter a REFUND situation. The purpose of this transaction is for the recipient to CLAIM funds from the sender - if they know the shared secret. References Improvement Proposal AIP102 API Endpoints Link AJV Schema Base | HTLC Claim","title":"HTLC Claim"},{"location":"core/transactions/types/htlc-claim/#json","text":"{ \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 9 , \"nonce\" : \"11\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"0\" , \"asset\" : { \"claim\" : { \"lockTransactionId\" : \"3aade2b98391ba7230252530cdd5124183a9f4e582660666ae873da48173ea5f\" , \"unlockSecret\" : \"c27f1ce845d8c29eebc9006be932b604fd06755521b1a8b0be4204c65377151a\" } } }","title":"JSON"},{"location":"core/transactions/types/htlc-claim/#serialized","text":"ff033f0100000009000b00000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192000000000000000000003aade2b98391ba7230252530cdd5124183a9f4e582660666ae873da48173ea5f20c27f1ce845d8c29eebc9006be932b604fd06755521b1a8b0be4204c65377151a","title":"Serialized"},{"location":"core/transactions/types/htlc-claim/#deserialized","text":"Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f TypeGroup: [3] 4 0x01000000 Type: [7] 2 0x0900 Nonce: [9] 8 0x0b00000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x0000000000000000 VendorField Length: [58] 1 0x00 Hash Type: [59] 1 0x00 Lock Id: [60] 32 0x3aade2b98391ba7230252530cdd5124183a9f4e582660666ae873da48173ea5f Unlock Secret Length: [92] 1 0x20 Unlock Secret: [93] 32 0xc27f1ce845d8c29eebc9006be932b604fd06755521b1a8b0be4204c65377151a","title":"Deserialized"},{"location":"core/transactions/types/htlc-claim/#supported-hash-types","text":"Hash Type Value SHA256 0 SHA384 1 SHA512 2 SHA3256 3 SHA3384 4 SHA3512 5 Keccak256 6 Keccak384 7 Keccak512 8","title":"Supported Hash Types"},{"location":"core/transactions/types/htlc-lock/","text":"HTLC Lock \u00b6 TypeGroup Type 1 8 A Hashed Time-Lock Contract (HTLC) is a set of transaction types that permits a designated party (the \"sender/seller\") to LOCK funds by disclosing the preimage (secret) of a hash. It also permits a second party (the \"recipient/buyer\") to CLAIM the funds, or after a timeout is reached enter a REFUND situation. The purpose of this transaction is to LOCK funds of the sender and make them possible for retrieval by the recipient, if they know the shared secret. References Improvement Proposal AIP102 API Endpoints Link AJV Schema Base | HTLC Lock JSON \u00b6 { \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 8 , \"nonce\" : \"10\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"10000000\" , \"amount\" : \"1\" , \"recipientId\" : \"SNAgA2XCRZDKfm5Vu9h4KR1bZw5xn9EiC3\" , \"asset\" : { \"lock\" : { \"secretHash\" : \"9c1a3815d49e0c9f78b872bfb017e825ea2db708158b70815526a830c85912b4\" , \"expiration\" : { \"type\" : 1 , \"value\" : 78740307 } } } } Serialized \u00b6 ff033f0100000008000a00000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed1928096980000000000000100000000000000029c1a3815d49e0c9f78b872bfb017e825ea2db708158b70815526a830c85912b401537bb1043f0995750207ecaf0ccf251c1265b92ad84f553662 Deserialized \u00b6 Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0800 Nonce: [9] 8 0x0a00000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x8096980000000000 VendorField Length: [58] 1 0x00 Amount: [59] 8 0x0100000000000000 Secret Hash Length: [67] 8 0x20 Secret Hash: [68] 32 0x9c1a3815d49e0c9f78b872bfb017e825ea2db708158b70815526a830c85912b4 Expiration Type: [100] 1 0x01 Expiration Value: [101] 4 0x537bb104 Recipient: [105] 21 0x3f0995750207ecaf0ccf251c1265b92ad84f553662","title":"Transaction Types - HTLC Lock"},{"location":"core/transactions/types/htlc-lock/#htlc-lock","text":"TypeGroup Type 1 8 A Hashed Time-Lock Contract (HTLC) is a set of transaction types that permits a designated party (the \"sender/seller\") to LOCK funds by disclosing the preimage (secret) of a hash. It also permits a second party (the \"recipient/buyer\") to CLAIM the funds, or after a timeout is reached enter a REFUND situation. The purpose of this transaction is to LOCK funds of the sender and make them possible for retrieval by the recipient, if they know the shared secret. References Improvement Proposal AIP102 API Endpoints Link AJV Schema Base | HTLC Lock","title":"HTLC Lock"},{"location":"core/transactions/types/htlc-lock/#json","text":"{ \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 8 , \"nonce\" : \"10\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"10000000\" , \"amount\" : \"1\" , \"recipientId\" : \"SNAgA2XCRZDKfm5Vu9h4KR1bZw5xn9EiC3\" , \"asset\" : { \"lock\" : { \"secretHash\" : \"9c1a3815d49e0c9f78b872bfb017e825ea2db708158b70815526a830c85912b4\" , \"expiration\" : { \"type\" : 1 , \"value\" : 78740307 } } } }","title":"JSON"},{"location":"core/transactions/types/htlc-lock/#serialized","text":"ff033f0100000008000a00000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed1928096980000000000000100000000000000029c1a3815d49e0c9f78b872bfb017e825ea2db708158b70815526a830c85912b401537bb1043f0995750207ecaf0ccf251c1265b92ad84f553662","title":"Serialized"},{"location":"core/transactions/types/htlc-lock/#deserialized","text":"Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0800 Nonce: [9] 8 0x0a00000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x8096980000000000 VendorField Length: [58] 1 0x00 Amount: [59] 8 0x0100000000000000 Secret Hash Length: [67] 8 0x20 Secret Hash: [68] 32 0x9c1a3815d49e0c9f78b872bfb017e825ea2db708158b70815526a830c85912b4 Expiration Type: [100] 1 0x01 Expiration Value: [101] 4 0x537bb104 Recipient: [105] 21 0x3f0995750207ecaf0ccf251c1265b92ad84f553662","title":"Deserialized"},{"location":"core/transactions/types/htlc-refund/","text":"HTLC Refund \u00b6 TypeGroup Type 1 3 A Hashed Time-Lock Contract (HTLC) is a set of transaction types that permits a designated party (the \"sender/seller\") to LOCK funds by disclosing the preimage (secret) of a hash. It also permits a second party (the \"recipient/buyer\") to CLAIM the funds, or after a timeout is reached enter a REFUND situation. The purpose of this transaction is for the sender to retrieve their locked funds, in the case of the recipient not claiming them using a CLAIM transactions. References Improvement Proposal AIP102 API Endpoints Link AJV Schema Base | HTLC Refund JSON \u00b6 { \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 10 , \"nonce\" : \"11\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"0\" , \"amount\" : \"0\" , \"asset\" : { \"refund\" : { \"lockTransactionId\" : \"3aade2b98391ba7230252530cdd5124183a9f4e582660666ae873da48173ea5f\" } } } Serialized \u00b6 ff033f010000000a000b00000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed1920000000000000000003aade2b98391ba7230252530cdd5124183a9f4e582660666ae873da48173ea5f Deserialized \u00b6 Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f TypeGroup: [3] 4 0x01000000 Type: [7] 2 0x0a00 Nonce: [9] 8 0x0b00000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x0000000000000000 VendorField Length: [58] 1 0x00 Lock Id: [59] 32 0x3aade2b98391ba7230252530cdd5124183a9f4e582660666ae873da48173ea5f","title":"Transaction Types - HTLC Refund"},{"location":"core/transactions/types/htlc-refund/#htlc-refund","text":"TypeGroup Type 1 3 A Hashed Time-Lock Contract (HTLC) is a set of transaction types that permits a designated party (the \"sender/seller\") to LOCK funds by disclosing the preimage (secret) of a hash. It also permits a second party (the \"recipient/buyer\") to CLAIM the funds, or after a timeout is reached enter a REFUND situation. The purpose of this transaction is for the sender to retrieve their locked funds, in the case of the recipient not claiming them using a CLAIM transactions. References Improvement Proposal AIP102 API Endpoints Link AJV Schema Base | HTLC Refund","title":"HTLC Refund"},{"location":"core/transactions/types/htlc-refund/#json","text":"{ \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 10 , \"nonce\" : \"11\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"0\" , \"amount\" : \"0\" , \"asset\" : { \"refund\" : { \"lockTransactionId\" : \"3aade2b98391ba7230252530cdd5124183a9f4e582660666ae873da48173ea5f\" } } }","title":"JSON"},{"location":"core/transactions/types/htlc-refund/#serialized","text":"ff033f010000000a000b00000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed1920000000000000000003aade2b98391ba7230252530cdd5124183a9f4e582660666ae873da48173ea5f","title":"Serialized"},{"location":"core/transactions/types/htlc-refund/#deserialized","text":"Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f TypeGroup: [3] 4 0x01000000 Type: [7] 2 0x0a00 Nonce: [9] 8 0x0b00000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x0000000000000000 VendorField Length: [58] 1 0x00 Lock Id: [59] 32 0x3aade2b98391ba7230252530cdd5124183a9f4e582660666ae873da48173ea5f","title":"Deserialized"},{"location":"core/transactions/types/ipfs/","text":"IPFS \u00b6 TypeGroup Type 1 5 This transaction type utilizes a special data field similar to the vendor field to store Interplanetary File System data on the blockchain. This provides an easy way to timestamp and optionally encrypt and verify files. This implementation of the IPFS transaction type won\u2019t allow storing data on the blockchain - for that, special IPFS nodes are needed. References Improvement Proposal AIP11 , AIP29 API Endpoints Link AJV Schema Base | IPFS JSON \u00b6 { \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 5 , \"nonce\" : \"7\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"500000000\" , \"asset\" : { \"ipfs\" : \"QmYSK2JyM3RyDyB52caZCTKFR3HKniEcMnNJYdk8DQ6KKB\" } } Serialized \u00b6 ff033f0100000005000700000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed1920065cd1d000000000012209608184d6cee2b9af8e6c2a46fc9318adf73329aeb8a86cf8472829fff5bb89e Deserialized \u00b6 Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f TypeGroup: [3] 4 0x01000000 Type: [7] 2 0x0500 Nonce: [9] 8 0x0700000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x0065cd1d00000000 VendorField Length: [58] 1 0x00 IPFS Hash: [59] 34 0x12209608184d6cee2b9af8e6c2a46fc9318adf73329aeb8a86cf8472829fff5bb89e IPFS Hash \u00b6 Item Length (chars) Value IPFS Hash 46 QmYSK2JyM3RyDyB52caZCTKFR3HKniEcMnNJYdk8DQ6KKB Decoded Base58 34 0x12209608184d6cee2b9af8e6c2a46fc9318adf73329aeb8a86cf8472829fff5bb89e Hash Type 1 0x12 Hash Length 1 0x20 32-Byte Hash 32 0x9608184d6cee2b9af8e6c2a46fc9318adf73329aeb8a86cf8472829fff5bb89e","title":"Transaction Types - IPFS"},{"location":"core/transactions/types/ipfs/#ipfs","text":"TypeGroup Type 1 5 This transaction type utilizes a special data field similar to the vendor field to store Interplanetary File System data on the blockchain. This provides an easy way to timestamp and optionally encrypt and verify files. This implementation of the IPFS transaction type won\u2019t allow storing data on the blockchain - for that, special IPFS nodes are needed. References Improvement Proposal AIP11 , AIP29 API Endpoints Link AJV Schema Base | IPFS","title":"IPFS"},{"location":"core/transactions/types/ipfs/#json","text":"{ \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 5 , \"nonce\" : \"7\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"500000000\" , \"asset\" : { \"ipfs\" : \"QmYSK2JyM3RyDyB52caZCTKFR3HKniEcMnNJYdk8DQ6KKB\" } }","title":"JSON"},{"location":"core/transactions/types/ipfs/#serialized","text":"ff033f0100000005000700000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed1920065cd1d000000000012209608184d6cee2b9af8e6c2a46fc9318adf73329aeb8a86cf8472829fff5bb89e","title":"Serialized"},{"location":"core/transactions/types/ipfs/#deserialized","text":"Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f TypeGroup: [3] 4 0x01000000 Type: [7] 2 0x0500 Nonce: [9] 8 0x0700000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x0065cd1d00000000 VendorField Length: [58] 1 0x00 IPFS Hash: [59] 34 0x12209608184d6cee2b9af8e6c2a46fc9318adf73329aeb8a86cf8472829fff5bb89e","title":"Deserialized"},{"location":"core/transactions/types/ipfs/#ipfs-hash","text":"Item Length (chars) Value IPFS Hash 46 QmYSK2JyM3RyDyB52caZCTKFR3HKniEcMnNJYdk8DQ6KKB Decoded Base58 34 0x12209608184d6cee2b9af8e6c2a46fc9318adf73329aeb8a86cf8472829fff5bb89e Hash Type 1 0x12 Hash Length 1 0x20 32-Byte Hash 32 0x9608184d6cee2b9af8e6c2a46fc9318adf73329aeb8a86cf8472829fff5bb89e","title":"IPFS Hash"},{"location":"core/transactions/types/multipayment/","text":"Multi-Payment \u00b6 TypeGroup Type 1 6 This type is designed to reduce the payload on the blockchain by enabling multiple payments to be combined and broadcast to the network as a single transaction. This benefits the end user and delegates by lowering transaction fees per payment and reducing congestion. Initially and depending on testing, the Solar Core will allow at least 64 payments to be combined within a single transaction for APN/Mainnet. Eventually, the number of payments per transaction will be able to scale as needed. References Improvement Proposal AIP11 , AIP29 API Endpoints Link AJV Schema Base | Multi-Payment JSON \u00b6 { \"version\" : 3 , \"network\" : 63 , \"type\" : 6 , \"nonce\" : \"8\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"10000000\" , \"amount\" : \"0\" , \"asset\" : { \"payments\" : [ { \"amount\" : \"1\" , \"recipientId\" : \"SNAgA2XCRZDKfm5Vu9h4KR1bZw5xn9EiC3\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SjHT1fxVsW75eaQUPN4U2SEgFVU8ZqSVgk\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SVzKH9r6u8UGcd2Ki7tAzQtB5Pa6FRn4GA\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SVhLL7NR8WhkKRfYDzSmGxUH4Gg5k3uis7\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SeznGToSzxw7maHDWXD2eRoTBSS2BmK8nU\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SfVFPA5e2JYcgJeUmVBEsFCYCWpt5xkZ5o\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SQEDRvC79Tqqmv85FrnqG4AxAxFoYPADCa\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SX87pA6bJdQQf57JnUUkzVJxZ2n9jxDgeN\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SMMJgffKfvtERv3d4MFeypAg53UcxJ9dE1\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SefdTc8Sjx5pqSUu3TpfjFw6epyPYWoooQ\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SSB1coESUy1GHsXjxd1Qzw5e1HqMUNQzRG\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SNtHvv7fr23EcKHkXeSwCYz6w2ZLaT7y9y\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SUogQH6n5EjwFnXwDapkJ1jri13Hrj1Ppz\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SY4RAvsUTZ5q9PR9Df28vguH6LfRFrgB3a\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SPZynxFxAtSBVKQWQW8LQPtrt87CBqpn7i\" }, { \"amount\" : \"1\" , \"recipientId\" : \"Sj6YjvZYDH4xh8HsRiYzWLBpeAkx65Nc1W\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SX3XMHrMSbXLLNGcRVbMBy4WgQbS3MZzWV\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SYqJcLu2wWYHDYvSomgsDPtnteCVhpNCTQ\" }, { \"amount\" : \"1\" , \"recipientId\" : \"Sa1v9xUZaniWKiCGzEV7qYXt1pW3G3XJbi\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SQVwXdWCqouKWQhaAJMsNieZmjE3GLYYiz\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SR1ZhBPLnSvrq3SQt8zeqBshemiudGb9fe\" }, { \"amount\" : \"1\" , \"recipientId\" : \"Sd1beR5X9pKKEYSxYWc7XXozC52y8QGJSt\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SScQEYdkr5mPGD9uwFrdk15KjyKAfwHZFc\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SRMhbyiuDa14kQKE7g8NB9jrBE8Jh9NwPv\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SUwp9puY8x9GYbvq8X4eYE5UjQxCgmNJMJ\" }, { \"amount\" : \"1\" , \"recipientId\" : \"ShomZcGU7c15EUXTUAfZB2QHw17UsHxxyf\" }, { \"amount\" : \"1\" , \"recipientId\" : \"ScCTPEwY4Bz2cTJJxL4Fy388zRTrAKmV8m\" }, { \"amount\" : \"1\" , \"recipientId\" : \"ShqpcENQP4gSqRcrC1oqAzSiNscvutyQ3B\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SjcaXuPypJxUv8qg4z7SaAry9ipqkVZsV2\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SZk35koLSrjSetXda5toYEhNNv3GNbosDN\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SVBBoMW8u2TiH4C59yi5wxk5mis81NJupL\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SgZEJxkDxfDSWP38QjkDkAf9uQLwb4XL8N\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SgE9Mqj1ZX9ziL9bJUUaRXzwNibEocJm5s\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SYkqTvG2n54Fbg1hAiZDeK33DYwCYZWcuC\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SjUcnukBRT6qxLRbbyrsQxVjbMdVLYRi5a\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SNSmzTzFPmzSmaKgcDj32nz7aJp1dJqJ5a\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SRdLAGYYk8HVeL3iJxRmYxZ9qvGUdRBiub\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SQf1Dpta8b94FYjKDBu2dfFF4EdUfLMnoU\" }, { \"amount\" : \"1\" , \"recipientId\" : \"Si5KNcn97V6TZYH1ccZZpyMvCJZmKuLEzv\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SfxX8nJVJ5rUbAXPVgFMXhpEbXXp1P3aWc\" } ] } } Serialized \u00b6 ff033f0100000006000800000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192809698000000000000280001000000000000003f0995750207ecaf0ccf251c1265b92ad84f55366201000000000000003ff13809c4c5fb2b3967a9b40efc70843f7db462ad01000000000000003f5f60e0594115b71d5b136cf929c8504082ac199d01000000000000003f5c2aaead4ce542788406c54e1ae31f1afdb7f08101000000000000003fc2308975254751ead4df705fc76aa84116c5e34e01000000000000003fc792d1958bb950596d0e7cd0bef325062009684801000000000000003f2031100e628422b8409810fdb438e874765846ba01000000000000003f6bd2c24bded5fdfd7888a28b3c6990503699b5e801000000000000003f009ffbb10efc47ad00a0a29cc2ef6e6c83d8c6ec01000000000000003fbe9147febbfe462cdbfda8575c18dabe85db4f5b01000000000000003f358634b58d88abf4aef3a6fe264b4ad18b74e98b01000000000000003f11745fc47a9c58c4e6f5a74eb59411ac102c6a8801000000000000003f5265ceb5d6102474ea7d0f401d6e6b9f13864a0501000000000000003f7617b5f3b82f153e388b4b200abd8636fff73dd501000000000000003f18f5df4fe3108277bfa4e39071fead9d59b35b8f01000000000000003fef283e95c3fdf0e2df9ba8321407c5621f98687601000000000000003f6af453a17439c9c258c25c707aa9fc1f3b59d9b401000000000000003f7e94f3954665ebd80ced3d434c67cd4351966f2b01000000000000003f8b8ee88e27291e33ce5403ea9b159235887dcfa901000000000000003f232a71b6b2586d5b02b6a72db08759066ba2a92b01000000000000003f28c4b220f14f3745f3fff6d3c066ba2353393eb601000000000000003fac67d5bfbef4a7ed8149727b93a01e903d84ee0c01000000000000003f3a537bef2ed296a54adc354967efe3a5e52cdfb801000000000000003f2c939e4633bd96ccc1d1509dbe794299603aad9901000000000000003f53ef9af027797e4827d708d9ed47c511f4ea552401000000000000003fe103c02fc06140aeac275f8e579f3397d041f81701000000000000003fa37d6366d765f5e446fc18ddcc3da3fa300cf6bb01000000000000003fe1671fea563be042824751a3465a7dbbc482794201000000000000003ff4d63847bf07a9faad83bd69fed408b3b734dce801000000000000003f888e092eba4cbd5eab9e10646661f5a440915f9d01000000000000003f5677152f9d640b175894c8da0b9f30bad3801aff01000000000000003fd34bb692e52d515398d00fd57ce2c8bfd348055401000000000000003fcfafad73ebddc38d53317c80cdbf6d343c331d6201000000000000003f7dbca0c01f96de655cf41eb53e1b8d5e2ffa260701000000000000003ff354c71350a110a7b45b5095ed0a4601bf4bbf9d01000000000000003f0ca0fbbfb8e3f615ec4eedaef6281d4d60a8f2b201000000000000003f2f885faaf6a3fcc38b1f35c652bf72f0fd7ac60301000000000000003f24e14548f3874b9413a28f258c2b73d35ec2b2f901000000000000003fe3f48b5211d1f21034bc15908259901ecf972be801000000000000003fccbb32ea36fad927cb2c46cbc63930db6cda829d Deserialized \u00b6 Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f TypeGroup: [3] 4 0x01000000 Type: [7] 2 0x0600 Nonce: [9] 8 0x0800000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x8096980000000000 VendorField Length: [58] 1 0x00 Number of Payments: [59] 2 0x2800 Amount 1: [61] 8 0x0100000000000000 Recipient 1: [69] 21 0x3f0995750207ecaf0ccf251c1265b92ad84f553662 ............ .... .. .................. Amount 40: [1192] 8 0x0100000000000000 Recipient 40: [1200] 21 0x3fccbb32ea36fad927cb2c46cbc63930db6cda829d","title":"Transaction Types - Multi-Payment"},{"location":"core/transactions/types/multipayment/#multi-payment","text":"TypeGroup Type 1 6 This type is designed to reduce the payload on the blockchain by enabling multiple payments to be combined and broadcast to the network as a single transaction. This benefits the end user and delegates by lowering transaction fees per payment and reducing congestion. Initially and depending on testing, the Solar Core will allow at least 64 payments to be combined within a single transaction for APN/Mainnet. Eventually, the number of payments per transaction will be able to scale as needed. References Improvement Proposal AIP11 , AIP29 API Endpoints Link AJV Schema Base | Multi-Payment","title":"Multi-Payment"},{"location":"core/transactions/types/multipayment/#json","text":"{ \"version\" : 3 , \"network\" : 63 , \"type\" : 6 , \"nonce\" : \"8\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"10000000\" , \"amount\" : \"0\" , \"asset\" : { \"payments\" : [ { \"amount\" : \"1\" , \"recipientId\" : \"SNAgA2XCRZDKfm5Vu9h4KR1bZw5xn9EiC3\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SjHT1fxVsW75eaQUPN4U2SEgFVU8ZqSVgk\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SVzKH9r6u8UGcd2Ki7tAzQtB5Pa6FRn4GA\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SVhLL7NR8WhkKRfYDzSmGxUH4Gg5k3uis7\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SeznGToSzxw7maHDWXD2eRoTBSS2BmK8nU\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SfVFPA5e2JYcgJeUmVBEsFCYCWpt5xkZ5o\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SQEDRvC79Tqqmv85FrnqG4AxAxFoYPADCa\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SX87pA6bJdQQf57JnUUkzVJxZ2n9jxDgeN\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SMMJgffKfvtERv3d4MFeypAg53UcxJ9dE1\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SefdTc8Sjx5pqSUu3TpfjFw6epyPYWoooQ\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SSB1coESUy1GHsXjxd1Qzw5e1HqMUNQzRG\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SNtHvv7fr23EcKHkXeSwCYz6w2ZLaT7y9y\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SUogQH6n5EjwFnXwDapkJ1jri13Hrj1Ppz\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SY4RAvsUTZ5q9PR9Df28vguH6LfRFrgB3a\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SPZynxFxAtSBVKQWQW8LQPtrt87CBqpn7i\" }, { \"amount\" : \"1\" , \"recipientId\" : \"Sj6YjvZYDH4xh8HsRiYzWLBpeAkx65Nc1W\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SX3XMHrMSbXLLNGcRVbMBy4WgQbS3MZzWV\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SYqJcLu2wWYHDYvSomgsDPtnteCVhpNCTQ\" }, { \"amount\" : \"1\" , \"recipientId\" : \"Sa1v9xUZaniWKiCGzEV7qYXt1pW3G3XJbi\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SQVwXdWCqouKWQhaAJMsNieZmjE3GLYYiz\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SR1ZhBPLnSvrq3SQt8zeqBshemiudGb9fe\" }, { \"amount\" : \"1\" , \"recipientId\" : \"Sd1beR5X9pKKEYSxYWc7XXozC52y8QGJSt\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SScQEYdkr5mPGD9uwFrdk15KjyKAfwHZFc\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SRMhbyiuDa14kQKE7g8NB9jrBE8Jh9NwPv\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SUwp9puY8x9GYbvq8X4eYE5UjQxCgmNJMJ\" }, { \"amount\" : \"1\" , \"recipientId\" : \"ShomZcGU7c15EUXTUAfZB2QHw17UsHxxyf\" }, { \"amount\" : \"1\" , \"recipientId\" : \"ScCTPEwY4Bz2cTJJxL4Fy388zRTrAKmV8m\" }, { \"amount\" : \"1\" , \"recipientId\" : \"ShqpcENQP4gSqRcrC1oqAzSiNscvutyQ3B\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SjcaXuPypJxUv8qg4z7SaAry9ipqkVZsV2\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SZk35koLSrjSetXda5toYEhNNv3GNbosDN\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SVBBoMW8u2TiH4C59yi5wxk5mis81NJupL\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SgZEJxkDxfDSWP38QjkDkAf9uQLwb4XL8N\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SgE9Mqj1ZX9ziL9bJUUaRXzwNibEocJm5s\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SYkqTvG2n54Fbg1hAiZDeK33DYwCYZWcuC\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SjUcnukBRT6qxLRbbyrsQxVjbMdVLYRi5a\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SNSmzTzFPmzSmaKgcDj32nz7aJp1dJqJ5a\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SRdLAGYYk8HVeL3iJxRmYxZ9qvGUdRBiub\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SQf1Dpta8b94FYjKDBu2dfFF4EdUfLMnoU\" }, { \"amount\" : \"1\" , \"recipientId\" : \"Si5KNcn97V6TZYH1ccZZpyMvCJZmKuLEzv\" }, { \"amount\" : \"1\" , \"recipientId\" : \"SfxX8nJVJ5rUbAXPVgFMXhpEbXXp1P3aWc\" } ] } }","title":"JSON"},{"location":"core/transactions/types/multipayment/#serialized","text":"ff033f0100000006000800000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192809698000000000000280001000000000000003f0995750207ecaf0ccf251c1265b92ad84f55366201000000000000003ff13809c4c5fb2b3967a9b40efc70843f7db462ad01000000000000003f5f60e0594115b71d5b136cf929c8504082ac199d01000000000000003f5c2aaead4ce542788406c54e1ae31f1afdb7f08101000000000000003fc2308975254751ead4df705fc76aa84116c5e34e01000000000000003fc792d1958bb950596d0e7cd0bef325062009684801000000000000003f2031100e628422b8409810fdb438e874765846ba01000000000000003f6bd2c24bded5fdfd7888a28b3c6990503699b5e801000000000000003f009ffbb10efc47ad00a0a29cc2ef6e6c83d8c6ec01000000000000003fbe9147febbfe462cdbfda8575c18dabe85db4f5b01000000000000003f358634b58d88abf4aef3a6fe264b4ad18b74e98b01000000000000003f11745fc47a9c58c4e6f5a74eb59411ac102c6a8801000000000000003f5265ceb5d6102474ea7d0f401d6e6b9f13864a0501000000000000003f7617b5f3b82f153e388b4b200abd8636fff73dd501000000000000003f18f5df4fe3108277bfa4e39071fead9d59b35b8f01000000000000003fef283e95c3fdf0e2df9ba8321407c5621f98687601000000000000003f6af453a17439c9c258c25c707aa9fc1f3b59d9b401000000000000003f7e94f3954665ebd80ced3d434c67cd4351966f2b01000000000000003f8b8ee88e27291e33ce5403ea9b159235887dcfa901000000000000003f232a71b6b2586d5b02b6a72db08759066ba2a92b01000000000000003f28c4b220f14f3745f3fff6d3c066ba2353393eb601000000000000003fac67d5bfbef4a7ed8149727b93a01e903d84ee0c01000000000000003f3a537bef2ed296a54adc354967efe3a5e52cdfb801000000000000003f2c939e4633bd96ccc1d1509dbe794299603aad9901000000000000003f53ef9af027797e4827d708d9ed47c511f4ea552401000000000000003fe103c02fc06140aeac275f8e579f3397d041f81701000000000000003fa37d6366d765f5e446fc18ddcc3da3fa300cf6bb01000000000000003fe1671fea563be042824751a3465a7dbbc482794201000000000000003ff4d63847bf07a9faad83bd69fed408b3b734dce801000000000000003f888e092eba4cbd5eab9e10646661f5a440915f9d01000000000000003f5677152f9d640b175894c8da0b9f30bad3801aff01000000000000003fd34bb692e52d515398d00fd57ce2c8bfd348055401000000000000003fcfafad73ebddc38d53317c80cdbf6d343c331d6201000000000000003f7dbca0c01f96de655cf41eb53e1b8d5e2ffa260701000000000000003ff354c71350a110a7b45b5095ed0a4601bf4bbf9d01000000000000003f0ca0fbbfb8e3f615ec4eedaef6281d4d60a8f2b201000000000000003f2f885faaf6a3fcc38b1f35c652bf72f0fd7ac60301000000000000003f24e14548f3874b9413a28f258c2b73d35ec2b2f901000000000000003fe3f48b5211d1f21034bc15908259901ecf972be801000000000000003fccbb32ea36fad927cb2c46cbc63930db6cda829d","title":"Serialized"},{"location":"core/transactions/types/multipayment/#deserialized","text":"Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f TypeGroup: [3] 4 0x01000000 Type: [7] 2 0x0600 Nonce: [9] 8 0x0800000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x8096980000000000 VendorField Length: [58] 1 0x00 Number of Payments: [59] 2 0x2800 Amount 1: [61] 8 0x0100000000000000 Recipient 1: [69] 21 0x3f0995750207ecaf0ccf251c1265b92ad84f553662 ............ .... .. .................. Amount 40: [1192] 8 0x0100000000000000 Recipient 40: [1200] 21 0x3fccbb32ea36fad927cb2c46cbc63930db6cda829d","title":"Deserialized"},{"location":"core/transactions/types/multisignature-registration/","text":"MultiSignature Registration \u00b6 TypeGroup Type 1 4 Multiple publicKeys can be aggregated into one creating a unique publicKey and address. This enables the creation of transactions that must be authorized by a minimum number of participants (signatures). References Improvement Proposal AIP18 API Endpoints Link AJV Schema Base | MultiSignature JSON \u00b6 { \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 4 , \"nonce\" : \"6\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"2000000000\" , \"amount\" : \"0\" , \"asset\" : { \"multiSignature\" : { \"publicKeys\" : [ \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"03df0a1eb42d99b5de395cead145ba1ec2ea837be308c7ce3a4e8018b7efc7fdb8\" , \"03860d76b1df09659ac282cea3da5bd84fc45729f348a4a8e5f802186be72dc17f\" ], \"min\" : 2 } } } Serialized \u00b6 ff033f0100000004000600000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed1920094357700000000000203034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed19203df0a1eb42d99b5de395cead145ba1ec2ea837be308c7ce3a4e8018b7efc7fdb803860d76b1df09659ac282cea3da5bd84fc45729f348a4a8e5f802186be72dc17f Deserialized \u00b6 Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0400 Nonce: [9] 8 0x0600000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x0094357700000000 VendorField Length: [58] 1 0x00 Key Min: [59] 1 0x02 Key Count: [60] 1 0x03 Key 1: [61] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Key 2: [94] 33 0x03df0a1eb42d99b5de395cead145ba1ec2ea837be308c7ce3a4e8018b7efc7fdb8 Key 3: [127] 33 0x03860d76b1df09659ac282cea3da5bd84fc45729f348a4a8e5f802186be72dc17f","title":"Transaction Types - Multisignature Registration"},{"location":"core/transactions/types/multisignature-registration/#multisignature-registration","text":"TypeGroup Type 1 4 Multiple publicKeys can be aggregated into one creating a unique publicKey and address. This enables the creation of transactions that must be authorized by a minimum number of participants (signatures). References Improvement Proposal AIP18 API Endpoints Link AJV Schema Base | MultiSignature","title":"MultiSignature Registration"},{"location":"core/transactions/types/multisignature-registration/#json","text":"{ \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 4 , \"nonce\" : \"6\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"2000000000\" , \"amount\" : \"0\" , \"asset\" : { \"multiSignature\" : { \"publicKeys\" : [ \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"03df0a1eb42d99b5de395cead145ba1ec2ea837be308c7ce3a4e8018b7efc7fdb8\" , \"03860d76b1df09659ac282cea3da5bd84fc45729f348a4a8e5f802186be72dc17f\" ], \"min\" : 2 } } }","title":"JSON"},{"location":"core/transactions/types/multisignature-registration/#serialized","text":"ff033f0100000004000600000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed1920094357700000000000203034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed19203df0a1eb42d99b5de395cead145ba1ec2ea837be308c7ce3a4e8018b7efc7fdb803860d76b1df09659ac282cea3da5bd84fc45729f348a4a8e5f802186be72dc17f","title":"Serialized"},{"location":"core/transactions/types/multisignature-registration/#deserialized","text":"Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0400 Nonce: [9] 8 0x0600000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x0094357700000000 VendorField Length: [58] 1 0x00 Key Min: [59] 1 0x02 Key Count: [60] 1 0x03 Key 1: [61] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Key 2: [94] 33 0x03df0a1eb42d99b5de395cead145ba1ec2ea837be308c7ce3a4e8018b7efc7fdb8 Key 3: [127] 33 0x03860d76b1df09659ac282cea3da5bd84fc45729f348a4a8e5f802186be72dc17f","title":"Deserialized"},{"location":"core/transactions/types/overview/","text":"Solar Core v3 Transaction Types Overview \u00b6 This sections describes Mainnet Transaction Types and its structure related to the serde process (serialization and deserialization of transactions). \u2139\ufe0f INFO - Transactions are the heart of any blockchain, cryptocurrency or otherwise. They represent a transfer of value from one network participant to another. In SXP, transactions can be of one of multiple types, specified in AIP11, which can affect the content and data structure of each transaction's payload. Using the SXP SDKs , developers can employ the programming language of their choice to build applications utilizing the SXP blockchain. The SXP SDKs are split into two packages for each language: Client and Cryptography. Client SDKs help developers fetch information from the SXP blockchain about its current state: which delegates are currently forging, what transactions are associated with a given wallet, and so on. Cryptography SDKs, by contrast, assist developers in working with transactions: signing, serializing, deserializing, etc. For more information about SDK implementations visit SXP SDKs hub . List of Transaction Types \u00b6 TypeGroup 1 Type 0: Transfer Type 1: Second Signature Registration Type 2: Delegate Registration Type 3: Vote Type 4: MultiSignature Registration Type 5: IPFS Type 6: Multi-Payment Type 7: Delegate Resignation Type 8: HTLC Lock Type 9: HTLC Claim Type 10: HTLC Refund TypeGroup 2 Type 0: Burn","title":"Transaction Types - Overview"},{"location":"core/transactions/types/overview/#solar-core-v3-transaction-types-overview","text":"This sections describes Mainnet Transaction Types and its structure related to the serde process (serialization and deserialization of transactions). \u2139\ufe0f INFO - Transactions are the heart of any blockchain, cryptocurrency or otherwise. They represent a transfer of value from one network participant to another. In SXP, transactions can be of one of multiple types, specified in AIP11, which can affect the content and data structure of each transaction's payload. Using the SXP SDKs , developers can employ the programming language of their choice to build applications utilizing the SXP blockchain. The SXP SDKs are split into two packages for each language: Client and Cryptography. Client SDKs help developers fetch information from the SXP blockchain about its current state: which delegates are currently forging, what transactions are associated with a given wallet, and so on. Cryptography SDKs, by contrast, assist developers in working with transactions: signing, serializing, deserializing, etc. For more information about SDK implementations visit SXP SDKs hub .","title":"Solar Core v3 Transaction Types Overview"},{"location":"core/transactions/types/overview/#list-of-transaction-types","text":"TypeGroup 1 Type 0: Transfer Type 1: Second Signature Registration Type 2: Delegate Registration Type 3: Vote Type 4: MultiSignature Registration Type 5: IPFS Type 6: Multi-Payment Type 7: Delegate Resignation Type 8: HTLC Lock Type 9: HTLC Claim Type 10: HTLC Refund TypeGroup 2 Type 0: Burn","title":"List of Transaction Types"},{"location":"core/transactions/types/second-signature/","text":"Second Signature Registration \u00b6 TypeGroup Type 1 1 This transaction type enables a user to add an extra layer of security to their address by creating a second passphrase, using mnemonic code for generating deterministic keys via BIP-39 to produce an additional mnemonic. Once a second signature has been registered to a wallet, the owner of the wallet will then be required to input their primary and secondary passphrase when sending a transaction to the network. References Improvement Proposal AIP11 , AIP29 API Endpoints Link AJV Schema Base | Second Signature Json \u00b6 { \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 1 , \"nonce\" : \"2\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"2500000\" , \"asset\" : { \"signature\" : { \"publicKey\" : \"02877e4f35c76abaeb152b128670db0a7ae10b3999afcd28a42938b653fbf87ae9\" } } } Serialized \u00b6 ff033f0100000001000200000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192a0252600000000000002877e4f35c76abaeb152b128670db0a7ae10b3999afcd28a42938b653fbf87ae9 Deserialized \u00b6 Key Pos. Size (bytes) Value (hex) Header Flag: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0100 Nonce: [9] 8 0x0200000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0xa025260000000000 VendorField Length: [58] 1 0x00 Second PublicKey: [59] 33 0x02877e4f35c76abaeb152b128670db0a7ae10b3999afcd28a42938b653fbf87ae9","title":"Transaction Types - Second Signature Registration"},{"location":"core/transactions/types/second-signature/#second-signature-registration","text":"TypeGroup Type 1 1 This transaction type enables a user to add an extra layer of security to their address by creating a second passphrase, using mnemonic code for generating deterministic keys via BIP-39 to produce an additional mnemonic. Once a second signature has been registered to a wallet, the owner of the wallet will then be required to input their primary and secondary passphrase when sending a transaction to the network. References Improvement Proposal AIP11 , AIP29 API Endpoints Link AJV Schema Base | Second Signature","title":"Second Signature Registration"},{"location":"core/transactions/types/second-signature/#json","text":"{ \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 1 , \"nonce\" : \"2\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"2500000\" , \"asset\" : { \"signature\" : { \"publicKey\" : \"02877e4f35c76abaeb152b128670db0a7ae10b3999afcd28a42938b653fbf87ae9\" } } }","title":"Json"},{"location":"core/transactions/types/second-signature/#serialized","text":"ff033f0100000001000200000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192a0252600000000000002877e4f35c76abaeb152b128670db0a7ae10b3999afcd28a42938b653fbf87ae9","title":"Serialized"},{"location":"core/transactions/types/second-signature/#deserialized","text":"Key Pos. Size (bytes) Value (hex) Header Flag: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0100 Nonce: [9] 8 0x0200000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0xa025260000000000 VendorField Length: [58] 1 0x00 Second PublicKey: [59] 33 0x02877e4f35c76abaeb152b128670db0a7ae10b3999afcd28a42938b653fbf87ae9","title":"Deserialized"},{"location":"core/transactions/types/transfer/","text":"Transfer \u00b6 TypeGroup Type 1 0 The transfer transaction enables a user to broadcast a transaction to the network sending SXP tokens from one SXP wallet to another. This transaction type provides the utility of store-of-value and value transfer. It also contains a special data field of 255 bytes called the vendor field, allowing raw data, code or plain text to be stored on the blockchain. The vendor field is public and immutable, and is also utilized in SXP SmartBridge Technology. References Improvement Proposal AIP11 , AIP29 API Endpoints Link AJV Schema Base | Transfer Json \u00b6 { \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 0 , \"nonce\" : \"1\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"2500000\" , \"vendorField\" : \"This is a test vendorfield.\" , \"amount\" : \"100000000\" , \"expiration\" : 0 , \"recipientId\" : \"SNAgA2XCRZDKfm5Vu9h4KR1bZw5xn9EiC3\" } Serialized \u00b6 ff033f0100000000000100000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192a0252600000000001b54686973206973206120746573742076656e646f726669656c642e00e1f50500000000000000003f0995750207ecaf0ccf251c1265b92ad84f553662 Deserialized \u00b6 Key Pos. Size (bytes) Value (hex) Header Flag: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0000 Nonce: [9] 8 0x0100000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0xa025260000000000 VendorField Length: [58] 1 0x1b VendorField: [59] 26 0x54686973206973206120746573742076656e646f726669656c642e Amount: [85] 8 0x00e1f50500000000 Expiration: [93] 4 0x00000000 Recipient: [97] 21 0x3f0995750207ecaf0ccf251c1265b92ad84f553662","title":"Transaction Types - Transfer"},{"location":"core/transactions/types/transfer/#transfer","text":"TypeGroup Type 1 0 The transfer transaction enables a user to broadcast a transaction to the network sending SXP tokens from one SXP wallet to another. This transaction type provides the utility of store-of-value and value transfer. It also contains a special data field of 255 bytes called the vendor field, allowing raw data, code or plain text to be stored on the blockchain. The vendor field is public and immutable, and is also utilized in SXP SmartBridge Technology. References Improvement Proposal AIP11 , AIP29 API Endpoints Link AJV Schema Base | Transfer","title":"Transfer"},{"location":"core/transactions/types/transfer/#json","text":"{ \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 0 , \"nonce\" : \"1\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"2500000\" , \"vendorField\" : \"This is a test vendorfield.\" , \"amount\" : \"100000000\" , \"expiration\" : 0 , \"recipientId\" : \"SNAgA2XCRZDKfm5Vu9h4KR1bZw5xn9EiC3\" }","title":"Json"},{"location":"core/transactions/types/transfer/#serialized","text":"ff033f0100000000000100000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192a0252600000000001b54686973206973206120746573742076656e646f726669656c642e00e1f50500000000000000003f0995750207ecaf0ccf251c1265b92ad84f553662","title":"Serialized"},{"location":"core/transactions/types/transfer/#deserialized","text":"Key Pos. Size (bytes) Value (hex) Header Flag: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0000 Nonce: [9] 8 0x0100000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0xa025260000000000 VendorField Length: [58] 1 0x1b VendorField: [59] 26 0x54686973206973206120746573742076656e646f726669656c642e Amount: [85] 8 0x00e1f50500000000 Expiration: [93] 4 0x00000000 Recipient: [97] 21 0x3f0995750207ecaf0ccf251c1265b92ad84f553662","title":"Deserialized"},{"location":"core/transactions/types/vote-unvote/","text":"Vote / Unvote / Switchvote \u00b6 TypeGroup Type 1 3 A key feature of the SXP DPoS model is that each address can vote for one delegate of their choosing to secure the network. A vote and unvote transaction type is therefore necessary to enable this functionality. Once an address votes for a delegate, funds can enter and leave the address as needed, and vote weight adjusts automatically. Voting does not send funds to the delegate\u2019s SXP address in question - it only assigns vote weight Holders of SXP vote through their wallets for delegates who secure the network, insert blocks into the ledger, and create new SXP. The top 53 vote earners are named elected forging delegates. Number of delegates is related to DPOS mechanism configuration. References Improvement Proposal AIP11 , AIP29 API Endpoints Link AJV Schema Base | Vote / Unvote / Switchvote Vote \u00b6 JSON \u00b6 { \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 3 , \"nonce\" : \"4\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"10000000\" , \"asset\" : { \"count\" : 1 , \"votes\" : [ \"+cactus1549\" ] } } Serialized \u00b6 ff033f0100000003000400000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192809698000000000000010b0163616374757331353439 Deserialized \u00b6 Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0300 Nonce: [9] 8 0x0400000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x8096980000000000 VendorField Length: [58] 1 0x00 Vote Count: [59] 1 0x01 Vote Length: [60] 1 0x0b Vote Type: [61] 1 0x01 Vote: [62] 5 0x63616374757331353439 Unvote \u00b6 JSON \u00b6 { \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 3 , \"nonce\" : \"5\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"10000000\" , \"asset\" : { \"count\" : 1 , \"votes\" : [ \"-cactus1549\" ] } } Serialized \u00b6 ff033f0100000003000500000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192809698000000000000010b0063616374757331353439 Deserialized \u00b6 Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0300 Nonce: [9] 8 0x0400000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x8096980000000000 VendorField Length: [58] 1 0x00 Vote Count: [59] 1 0x01 Vote Length: [60] 1 0x0b Vote Type: [61] 1 0x00 Vote: [62] 5 0x63616374757331353439 Switch Vote \u00b6 JSON \u00b6 { \"version\" : 3 , \"network\" : 63 , \"type\" : 3 , \"nonce\" : \"5\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"10000000\" , \"asset\" : { \"count\" : 2 , \"votes\" : [ \"-cactus1549\" , \"+sl33p\" ] } } Serialized \u00b6 ff033f0100000003000500000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192809698000000000000020b00636163747573313534390601736c333370 Deserialized \u00b6 Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0300 Nonce: [9] 8 0x0200000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x8096980000000000 VendorField Length: [58] 1 0x00 Vote Count: [59] 1 0x02 Vote 1 Length: [60] 1 0x0b Vote 1 Type: [61] 1 0x00 Vote 1: [62] 10 0x63616374757331353439 Vote 2 Length: [72] 1 0x06 Vote 2 Type: [73] 1 0x01 Vote 2: [74] 10 0x736C333370","title":"Transaction Types - Vote / Unvote / Switchvote"},{"location":"core/transactions/types/vote-unvote/#vote-unvote-switchvote","text":"TypeGroup Type 1 3 A key feature of the SXP DPoS model is that each address can vote for one delegate of their choosing to secure the network. A vote and unvote transaction type is therefore necessary to enable this functionality. Once an address votes for a delegate, funds can enter and leave the address as needed, and vote weight adjusts automatically. Voting does not send funds to the delegate\u2019s SXP address in question - it only assigns vote weight Holders of SXP vote through their wallets for delegates who secure the network, insert blocks into the ledger, and create new SXP. The top 53 vote earners are named elected forging delegates. Number of delegates is related to DPOS mechanism configuration. References Improvement Proposal AIP11 , AIP29 API Endpoints Link AJV Schema Base | Vote / Unvote / Switchvote","title":"Vote / Unvote / Switchvote"},{"location":"core/transactions/types/vote-unvote/#vote","text":"","title":"Vote"},{"location":"core/transactions/types/vote-unvote/#json","text":"{ \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 3 , \"nonce\" : \"4\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"10000000\" , \"asset\" : { \"count\" : 1 , \"votes\" : [ \"+cactus1549\" ] } }","title":"JSON"},{"location":"core/transactions/types/vote-unvote/#serialized","text":"ff033f0100000003000400000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192809698000000000000010b0163616374757331353439","title":"Serialized"},{"location":"core/transactions/types/vote-unvote/#deserialized","text":"Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0300 Nonce: [9] 8 0x0400000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x8096980000000000 VendorField Length: [58] 1 0x00 Vote Count: [59] 1 0x01 Vote Length: [60] 1 0x0b Vote Type: [61] 1 0x01 Vote: [62] 5 0x63616374757331353439","title":"Deserialized"},{"location":"core/transactions/types/vote-unvote/#unvote","text":"","title":"Unvote"},{"location":"core/transactions/types/vote-unvote/#json_1","text":"{ \"version\" : 3 , \"network\" : 63 , \"typeGroup\" : 1 , \"type\" : 3 , \"nonce\" : \"5\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"10000000\" , \"asset\" : { \"count\" : 1 , \"votes\" : [ \"-cactus1549\" ] } }","title":"JSON"},{"location":"core/transactions/types/vote-unvote/#serialized_1","text":"ff033f0100000003000500000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192809698000000000000010b0063616374757331353439","title":"Serialized"},{"location":"core/transactions/types/vote-unvote/#deserialized_1","text":"Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0300 Nonce: [9] 8 0x0400000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x8096980000000000 VendorField Length: [58] 1 0x00 Vote Count: [59] 1 0x01 Vote Length: [60] 1 0x0b Vote Type: [61] 1 0x00 Vote: [62] 5 0x63616374757331353439","title":"Deserialized"},{"location":"core/transactions/types/vote-unvote/#switch-vote","text":"","title":"Switch Vote"},{"location":"core/transactions/types/vote-unvote/#json_2","text":"{ \"version\" : 3 , \"network\" : 63 , \"type\" : 3 , \"nonce\" : \"5\" , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"fee\" : \"10000000\" , \"asset\" : { \"count\" : 2 , \"votes\" : [ \"-cactus1549\" , \"+sl33p\" ] } }","title":"JSON"},{"location":"core/transactions/types/vote-unvote/#serialized_2","text":"ff033f0100000003000500000000000000034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192809698000000000000020b00636163747573313534390601736c333370","title":"Serialized"},{"location":"core/transactions/types/vote-unvote/#deserialized_2","text":"Key Pos. Size (bytes) Value (hex) Header: [0] 1 0xff Version: [1] 1 0x03 Network: [2] 1 0x3f Typegroup: [3] 4 0x01000000 Type: [7] 2 0x0300 Nonce: [9] 8 0x0200000000000000 SenderPublicKey: [17] 33 0x034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192 Fee: [50] 8 0x8096980000000000 VendorField Length: [58] 1 0x00 Vote Count: [59] 1 0x02 Vote 1 Length: [60] 1 0x0b Vote 1 Type: [61] 1 0x00 Vote 1: [62] 10 0x63616374757331353439 Vote 2 Length: [72] 1 0x06 Vote 2 Type: [73] 1 0x01 Vote 2: [74] 10 0x736C333370","title":"Deserialized"},{"location":"core/updates/3.3.0/","text":"Release 3.3.0 \u00b6 warning Note that this is not the usual solar update command! Time critical update This new release will activate new milestones at block height 671,988 (estimated at around 30th May 2022 at 00:00 UTC). Changes since 3.2.5: \u00b6 New Features \u00b6 automatic allocation of 5% of forging rewards for development funding following a governance vote on the issue bip340 schnorr signatures now used for improved security and less technical debt empty but valid wallets now show as empty wallets rather than returning an error via the api last block id string is now returned in the delegate attribute and in the api rather than the whole block more hashing algorithms included for hashed timelock contract transactions for better interoperability new voters attribute added to the api response for delegates to show how many voters each delegate has p2p port of a node can now be freely changed without any problems vendorfield is now supported in every transaction type Bug Fixes \u00b6 correct fee burning database index is now dropped last block data is correctly updated in the delegate attribute following a rollback more resilient fork recovery updater reruns pnpm install after building to resolve some dependency issues Maintenance \u00b6 added filtering by transaction version to the swagger page on the api block headers now only include specific properties blocks are now broadcasted to all peers rather than just a few blocks are only broadcasted if there are >= 2 seconds remaining in the slot core transaction handlers have been unified delegate name now used in the vote attribute rather than the public key legacy code removed or fixed where appropriate multisignature registrations reactivated and no longer use participant signatures in the registration transaction peers are always polled for blocks in case a node does not receive a block normally removed the incompatible transaction handler inherited from upstream code as it does not apply here serialised vote payloads no longer have 0xff padding in v3 transactions for the delegate name upstream wallet support is now removed due to breaking changes in core voting using the public key asset is disabled in v3 transactions Update Instructions \u00b6 Please update your mainnet node with the following command. solar plugin:update @alessiodf/rocket-boot && solar rocket:purge --force && solar update","title":"3.3.0"},{"location":"core/updates/3.3.0/#release-330","text":"warning Note that this is not the usual solar update command! Time critical update This new release will activate new milestones at block height 671,988 (estimated at around 30th May 2022 at 00:00 UTC).","title":"Release 3.3.0"},{"location":"core/updates/3.3.0/#changes-since-325","text":"","title":"Changes since 3.2.5:"},{"location":"core/updates/3.3.0/#new-features","text":"automatic allocation of 5% of forging rewards for development funding following a governance vote on the issue bip340 schnorr signatures now used for improved security and less technical debt empty but valid wallets now show as empty wallets rather than returning an error via the api last block id string is now returned in the delegate attribute and in the api rather than the whole block more hashing algorithms included for hashed timelock contract transactions for better interoperability new voters attribute added to the api response for delegates to show how many voters each delegate has p2p port of a node can now be freely changed without any problems vendorfield is now supported in every transaction type","title":"New Features"},{"location":"core/updates/3.3.0/#bug-fixes","text":"correct fee burning database index is now dropped last block data is correctly updated in the delegate attribute following a rollback more resilient fork recovery updater reruns pnpm install after building to resolve some dependency issues","title":"Bug Fixes"},{"location":"core/updates/3.3.0/#maintenance","text":"added filtering by transaction version to the swagger page on the api block headers now only include specific properties blocks are now broadcasted to all peers rather than just a few blocks are only broadcasted if there are >= 2 seconds remaining in the slot core transaction handlers have been unified delegate name now used in the vote attribute rather than the public key legacy code removed or fixed where appropriate multisignature registrations reactivated and no longer use participant signatures in the registration transaction peers are always polled for blocks in case a node does not receive a block normally removed the incompatible transaction handler inherited from upstream code as it does not apply here serialised vote payloads no longer have 0xff padding in v3 transactions for the delegate name upstream wallet support is now removed due to breaking changes in core voting using the public key asset is disabled in v3 transactions","title":"Maintenance"},{"location":"core/updates/3.3.0/#update-instructions","text":"Please update your mainnet node with the following command. solar plugin:update @alessiodf/rocket-boot && solar rocket:purge --force && solar update","title":"Update Instructions"},{"location":"core/updates/4.0.1/","text":"4.0.1 Nebula \u00b6 Time critical update The new voting mechanism, new transfers, and temporary delegate resignations will be available from block 1,175,000 on 15th July 2022. This page will provide information and guidance on the following: Changes since 3.3.0 Core 4.x Requirements Core 4.x Update Instructions v3 Transaction Changes The 'Memo' Transfer Vote Delegate Resignation Changes since 3.3.0 \u00b6 This is the first major update of Solar Core since the launch of Mainnet. Click on the following link to read a full summary of the 4.x release: https://github.com/Solar-network/core/pull/97 Highlights \u00b6 Introduction of v3 transactions, featuring: Combined Transfer and MultiPayment transactions New Vote transaction type New 'Temporary' and 'Permanent' 'Delegate Resignation' types Optional Transaction Memos Improved Core Crypto web browser compatibility Tighter schema validation Near-instantaneous fork recovery CPU count-based service worker allocation Improved logging and errors descriptions info See all of the changes -- including hundreds of improvements, optimisations, and bug fixes -- here: github.com/Solar-network/core/compare/3.3.0...4.0.1 Requirements \u00b6 Supported OS Release Ubuntu >= 20.x Debian >= 10.x Ubuntu < = 18.x and Debian < = 9 are no longer supported Relay Requirements Recommended Minimum CPUs 4 2 RAM 8GB 4GB HDD 100GB - 120GB 80GB Forger Requirements Recommended Minimum CPUs 4 ( dedicated ) 2 ( dedicated ) RAM 16GB 8GB HDD 100GB - 120GB ( SSD ) 80GB ( SSD ) Update Instructions \u00b6 warning Note that this is not the usual solar update command! Update your Mainnet node with the following command: wget -4O- https://gist.githubusercontent.com/alessiodf/4faa98978ce547c1d8e96696f1d84e97/raw/cd9e7b83de0e5ac26a2e745d9452c9ed1d5c5195/update.sh | bash v3 Transaction Changes \u00b6 There are several key transaction changes to be aware of in Solar Core 4.x . The 'Memo' \u00b6 All Solar transactions now contain a special 255-byte data field known as a 'Memo' and allows raw data, code, or plain text to be stored on the blockchain. The Memo is optional, public, and immutable. This was previously known as the vendorField and was only available on certain transaction types. v3 Transfer \u00b6 TypeGroup Type 1 6 One of the most important changes is the introduction of the new Transfer transaction type. Formerly, a single send transaction made use of v2-style Transfers (Type 0) whereas two or more sends required using a v2 MultiPayment transaction (Type 6). Under Solar Core 4.x , these have been combined under the MultiPayment pattern and are now known simply as 'Transfer' (Type 6), removing the unnecessary requirement of two separate transaction types. See the v3 Transfer structure here . TypeScript Code Example: const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://tapi.solar.org/api\" ); // Set the network configuration Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . transfer () . nonce ( senderNonce . toFixed ()) . memo ( \"This is an example memo\" ) . addTransfer ( \"Address of Recipient Wallet 1\" , 1 * 1e8 ) . addTransfer ( \"Address of Recipient Wallet 2\" , 1 * 1e8 ) . addTransfer ( \"Address of Recipient Wallet 3\" , 1 * 1e8 ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); See the Python code example here . v3 Vote \u00b6 TypeGroup Type 2 2 Voting has undergone a significant conceptual change in Core 4.x . Previously, a wallet could vote for only one delegate at a time. Under the new scheme, a wallet can vote for up to 53 delegates in total as well as optionally customise the distribution of their vote weight. For instance, the default behaviour of voting for three delegates where no custom distribution is specified would look as follows: { ... \"votes\" : { \"cactus1549\" : 33.34 , \"gym\" : 33.33 , \"sl33p\" : 33.33 } ... } note Note that the vote weight is distributed evenly and uses a natural sorting order. Because the vote weight must total 100%, the remaining 0.01% is subsequently distributed in ascending order. When manually specifying vote weight distribution, natural sorting is still used; however, vote weight is prioritised while determining the list's order. For example: { ... \"votes\" : { \"sl33p\" : 40.50 , \"cactus1549\" : 29.75 , \"gym\" : 29.75 } ... } See the v3 Vote structure here . v3 Delegate Resignation Types \u00b6 TypeGroup Type 1 7 Previously, v2-style Delegate Resignation was a permanent action. There was no way for a resigned delegate to reinstate their eligibility to receive votes and produce blocks. This was only useful in cases where a delegate no longer wanted to participate in network consensus. Solar Core 4.x adds a new 'Temporary' resignation option where their resigned status may be 'Revoked' after at least two rounds (~106 blocks). This is useful when a delegate may only wish to resign for a short time without negatively impacting the network (e.g., missing blocks) and can be for a variety of reasons, from temporary node maintenance to personal/private matters. Resignation Type Value Description Temporary 0 Resign only for a short time. Delegate will be temporarily blocked from receiving votes or forging. (the default when no resign type is declared) Permanent 1 Irreversible. Delegate will no longer be allowed to receive votes or forge. Revoke 2 Reverses a temporary resignation. See the v3 Delegate Resignation structure here .","title":"4.0.1"},{"location":"core/updates/4.0.1/#401-nebula","text":"Time critical update The new voting mechanism, new transfers, and temporary delegate resignations will be available from block 1,175,000 on 15th July 2022. This page will provide information and guidance on the following: Changes since 3.3.0 Core 4.x Requirements Core 4.x Update Instructions v3 Transaction Changes The 'Memo' Transfer Vote Delegate Resignation","title":"4.0.1 Nebula"},{"location":"core/updates/4.0.1/#changes-since-330","text":"This is the first major update of Solar Core since the launch of Mainnet. Click on the following link to read a full summary of the 4.x release: https://github.com/Solar-network/core/pull/97","title":"Changes since 3.3.0"},{"location":"core/updates/4.0.1/#highlights","text":"Introduction of v3 transactions, featuring: Combined Transfer and MultiPayment transactions New Vote transaction type New 'Temporary' and 'Permanent' 'Delegate Resignation' types Optional Transaction Memos Improved Core Crypto web browser compatibility Tighter schema validation Near-instantaneous fork recovery CPU count-based service worker allocation Improved logging and errors descriptions info See all of the changes -- including hundreds of improvements, optimisations, and bug fixes -- here: github.com/Solar-network/core/compare/3.3.0...4.0.1","title":"Highlights"},{"location":"core/updates/4.0.1/#requirements","text":"Supported OS Release Ubuntu >= 20.x Debian >= 10.x Ubuntu < = 18.x and Debian < = 9 are no longer supported Relay Requirements Recommended Minimum CPUs 4 2 RAM 8GB 4GB HDD 100GB - 120GB 80GB Forger Requirements Recommended Minimum CPUs 4 ( dedicated ) 2 ( dedicated ) RAM 16GB 8GB HDD 100GB - 120GB ( SSD ) 80GB ( SSD )","title":"Requirements"},{"location":"core/updates/4.0.1/#update-instructions","text":"warning Note that this is not the usual solar update command! Update your Mainnet node with the following command: wget -4O- https://gist.githubusercontent.com/alessiodf/4faa98978ce547c1d8e96696f1d84e97/raw/cd9e7b83de0e5ac26a2e745d9452c9ed1d5c5195/update.sh | bash","title":"Update Instructions"},{"location":"core/updates/4.0.1/#v3-transaction-changes","text":"There are several key transaction changes to be aware of in Solar Core 4.x .","title":"v3 Transaction Changes"},{"location":"core/updates/4.0.1/#the-memo","text":"All Solar transactions now contain a special 255-byte data field known as a 'Memo' and allows raw data, code, or plain text to be stored on the blockchain. The Memo is optional, public, and immutable. This was previously known as the vendorField and was only available on certain transaction types.","title":"The 'Memo'"},{"location":"core/updates/4.0.1/#v3-transfer","text":"TypeGroup Type 1 6 One of the most important changes is the introduction of the new Transfer transaction type. Formerly, a single send transaction made use of v2-style Transfers (Type 0) whereas two or more sends required using a v2 MultiPayment transaction (Type 6). Under Solar Core 4.x , these have been combined under the MultiPayment pattern and are now known simply as 'Transfer' (Type 6), removing the unnecessary requirement of two separate transaction types. See the v3 Transfer structure here . TypeScript Code Example: const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://tapi.solar.org/api\" ); // Set the network configuration Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . transfer () . nonce ( senderNonce . toFixed ()) . memo ( \"This is an example memo\" ) . addTransfer ( \"Address of Recipient Wallet 1\" , 1 * 1e8 ) . addTransfer ( \"Address of Recipient Wallet 2\" , 1 * 1e8 ) . addTransfer ( \"Address of Recipient Wallet 3\" , 1 * 1e8 ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); See the Python code example here .","title":"v3 Transfer"},{"location":"core/updates/4.0.1/#v3-vote","text":"TypeGroup Type 2 2 Voting has undergone a significant conceptual change in Core 4.x . Previously, a wallet could vote for only one delegate at a time. Under the new scheme, a wallet can vote for up to 53 delegates in total as well as optionally customise the distribution of their vote weight. For instance, the default behaviour of voting for three delegates where no custom distribution is specified would look as follows: { ... \"votes\" : { \"cactus1549\" : 33.34 , \"gym\" : 33.33 , \"sl33p\" : 33.33 } ... } note Note that the vote weight is distributed evenly and uses a natural sorting order. Because the vote weight must total 100%, the remaining 0.01% is subsequently distributed in ascending order. When manually specifying vote weight distribution, natural sorting is still used; however, vote weight is prioritised while determining the list's order. For example: { ... \"votes\" : { \"sl33p\" : 40.50 , \"cactus1549\" : 29.75 , \"gym\" : 29.75 } ... } See the v3 Vote structure here .","title":"v3 Vote"},{"location":"core/updates/4.0.1/#v3-delegate-resignation-types","text":"TypeGroup Type 1 7 Previously, v2-style Delegate Resignation was a permanent action. There was no way for a resigned delegate to reinstate their eligibility to receive votes and produce blocks. This was only useful in cases where a delegate no longer wanted to participate in network consensus. Solar Core 4.x adds a new 'Temporary' resignation option where their resigned status may be 'Revoked' after at least two rounds (~106 blocks). This is useful when a delegate may only wish to resign for a short time without negatively impacting the network (e.g., missing blocks) and can be for a variety of reasons, from temporary node maintenance to personal/private matters. Resignation Type Value Description Temporary 0 Resign only for a short time. Delegate will be temporarily blocked from receiving votes or forging. (the default when no resign type is declared) Permanent 1 Irreversible. Delegate will no longer be allowed to receive votes or forge. Revoke 2 Reverses a temporary resignation. See the v3 Delegate Resignation structure here .","title":"v3 Delegate Resignation Types"},{"location":"core/updates/4.1.1/","text":"4.1.1 Nebula \u00b6 Time critical update This new release will activate a fork after block height 1,812,866 (estimated at around 12th September 2022 at 17:00 UTC). This page will provide information and guidance on the following: Changes since 4.0.3 Upgrade Instructions Changes since 4.0.3 \u00b6 New Features \u00b6 automatic allocation of 5% of forging rewards for foundation funding following a governance vote on the issue events are emitted when delegate vote state changes new /blockchain/search api endpoint added to search the blockchain easily rolling 30 day productivity statistics are shown on the api support for bls12-381 has been added websocket api and websocket event subscriptions service introduced Bug Fixes \u00b6 better vote balance handling if there is no balance destructive snapshot actions cannot execute while core is running fork resolution checks no longer hold up the process queue htlc fee handling now works as expected multiple api bug fixes only unicast ip addresses are accepted as peers rollback edge cases are now handled better state machine transitions are handled consistently Maintenance \u00b6 block deletion on rollback is more efficient database configuration has been tuned database indexes have been added for better optimisation delegate usernames are used instead of the generator public key delegates.json now stores hexadecimal private keys instead of plain passphrase secrets legacy upstream code has been removed much code cleanup transaction handlers now have a consistent implementation transaction sender addresses are used instead of the public key various dependency changes info See all of the changes -- including hundreds of improvements, optimisations, and bug fixes -- here: github.com/Solar-network/core/pull/117 Upgrade Instructions \u00b6 If you are a delegate, please be aware that this update will perform a destructive modification to your delegates.json file, overwriting your delegate passphrase(s) with their hexadecimal private key equivalents. Please make sure you have your passphrases backed up somewhere safe prior to updating to Core 4.1.1 because you will not be able to retrieve your passphrase(s) from delegates.json anymore. Also, you should update your primary node BEFORE updating any backups. warning Note that this is not the usual solar update command! Please update your mainnet nodes now with the following command: wget -4O- https://gist.githubusercontent.com/alessiodf/5449ed2cf3ec3ff2cd23776af3404c35/raw/0de41a16ee2bf16186b70cdbf538838bc631118d/update.sh | bash","title":"4.1.1"},{"location":"core/updates/4.1.1/#411-nebula","text":"Time critical update This new release will activate a fork after block height 1,812,866 (estimated at around 12th September 2022 at 17:00 UTC). This page will provide information and guidance on the following: Changes since 4.0.3 Upgrade Instructions","title":"4.1.1 Nebula"},{"location":"core/updates/4.1.1/#changes-since-403","text":"","title":"Changes since 4.0.3"},{"location":"core/updates/4.1.1/#new-features","text":"automatic allocation of 5% of forging rewards for foundation funding following a governance vote on the issue events are emitted when delegate vote state changes new /blockchain/search api endpoint added to search the blockchain easily rolling 30 day productivity statistics are shown on the api support for bls12-381 has been added websocket api and websocket event subscriptions service introduced","title":"New Features"},{"location":"core/updates/4.1.1/#bug-fixes","text":"better vote balance handling if there is no balance destructive snapshot actions cannot execute while core is running fork resolution checks no longer hold up the process queue htlc fee handling now works as expected multiple api bug fixes only unicast ip addresses are accepted as peers rollback edge cases are now handled better state machine transitions are handled consistently","title":"Bug Fixes"},{"location":"core/updates/4.1.1/#maintenance","text":"block deletion on rollback is more efficient database configuration has been tuned database indexes have been added for better optimisation delegate usernames are used instead of the generator public key delegates.json now stores hexadecimal private keys instead of plain passphrase secrets legacy upstream code has been removed much code cleanup transaction handlers now have a consistent implementation transaction sender addresses are used instead of the public key various dependency changes info See all of the changes -- including hundreds of improvements, optimisations, and bug fixes -- here: github.com/Solar-network/core/pull/117","title":"Maintenance"},{"location":"core/updates/4.1.1/#upgrade-instructions","text":"If you are a delegate, please be aware that this update will perform a destructive modification to your delegates.json file, overwriting your delegate passphrase(s) with their hexadecimal private key equivalents. Please make sure you have your passphrases backed up somewhere safe prior to updating to Core 4.1.1 because you will not be able to retrieve your passphrase(s) from delegates.json anymore. Also, you should update your primary node BEFORE updating any backups. warning Note that this is not the usual solar update command! Please update your mainnet nodes now with the following command: wget -4O- https://gist.githubusercontent.com/alessiodf/5449ed2cf3ec3ff2cd23776af3404c35/raw/0de41a16ee2bf16186b70cdbf538838bc631118d/update.sh | bash","title":"Upgrade Instructions"},{"location":"desktop-wallet/intro/","text":"Introduction \u00b6 What Is It? \u00b6 The SXP Desktop Wallet is an application which allows you to manage SXP transactions. It provides an extensive set of functionalities, including management of profiles and wallets, the creation of both online and offline transactions, wallet summary, stylistic customizations, multilingual support, various currency integrations including BTC and much more! Getting Started \u00b6 To get started with the SXP Desktop Wallet, follow the documentation below for guides on Installation, Wallet Navigation, Creating Wallets and more... Transactions \u00b6 The SXP Desktop Wallet enables you to send a wide variety of transactions on the SXP Blockchain and other Solar Core based blockchains. Follow the guides below for information on each transaction. Developer Guides \u00b6 The SXP Desktop Wallet offers a wide range of customization which empowers developers to create Plugins to enhance the experience within the Wallet from Games, Utilities and Theme's. Follow the guides below to get started with development within the SXP Desktop Wallet. Support \u00b6","title":"Introduction"},{"location":"desktop-wallet/intro/#introduction","text":"","title":"Introduction"},{"location":"desktop-wallet/intro/#what-is-it","text":"The SXP Desktop Wallet is an application which allows you to manage SXP transactions. It provides an extensive set of functionalities, including management of profiles and wallets, the creation of both online and offline transactions, wallet summary, stylistic customizations, multilingual support, various currency integrations including BTC and much more!","title":"What Is It?"},{"location":"desktop-wallet/intro/#getting-started","text":"To get started with the SXP Desktop Wallet, follow the documentation below for guides on Installation, Wallet Navigation, Creating Wallets and more...","title":"Getting Started"},{"location":"desktop-wallet/intro/#transactions","text":"The SXP Desktop Wallet enables you to send a wide variety of transactions on the SXP Blockchain and other Solar Core based blockchains. Follow the guides below for information on each transaction.","title":"Transactions"},{"location":"desktop-wallet/intro/#developer-guides","text":"The SXP Desktop Wallet offers a wide range of customization which empowers developers to create Plugins to enhance the experience within the Wallet from Games, Utilities and Theme's. Follow the guides below to get started with development within the SXP Desktop Wallet.","title":"Developer Guides"},{"location":"desktop-wallet/intro/#support","text":"","title":"Support"},{"location":"desktop-wallet/rewards/","text":"An Introduction to SXP Rewards (Staking) \u00b6 Solar is a sovereign blockchain with a native cryptoasset called SXP. It is based on the Delegated-Proof-of-Stake (DPoS) consensus mechanism and has 53 active Delegates (Validators) who secure the network. In this article, we will discuss how block rewards work within the Solar blockchain and how you can earn a portion of the rewards by becoming an active delegate or voting with your SXP coins. Staking Considerations \u00b6 SXP Staking is unique in that user funds are not required to be sent or locked. When a user casts a vote, their vote-weight is assigned to the network Validator (Delegate) of their choice. A user\u2019s vote-weight adjusts automatically as funds are sent and received, and there is no need to re-vote or un-stake. To change a vote, a user simply un-votes their current Validator and elects another by casting a new vote transaction. For more information about voting and unvoting, please visit: How to Vote or Unvote a Delegate Staking Fees \u00b6 The cost of a vote covers the transaction itself. There is no requirement to send or lock additional funds in order to participate in consensus. This transaction fee is awarded to the Validator who forges the transaction in a given block. For more information about fees, please visit: Transaction Fees Block Rewards \u00b6 Solar is a sovereign blockchain that is validated by 53 active Delegates. Each Delegate will submit (1) block per round. A round consists of 53 blocks. Each block on Solar has a block time of 8 seconds. Each block awards the active delegate who submits the block a dynamic and rank-based block reward with the 10% any transaction fees from that block. Block Rewards are inflationary coins, meaning the total SXP supply is increased by between x and x SXP every block. This serves as a form of consistent inflation that reduces over time due to the non-fluctuating rate of rewards. On Solar, 100% of the block reward goes to the Validator. Note: There are no \"halvenings\" of block rewards on Solar . Reward Sharing on Solar \u00b6 As previously stated, block rewards and transaction fees are awarded to the active delegate responsible for reporting a given block. We call this combination of the block reward and 10% of any fees the total reward. On Solar, many of these delegates choose to take a small commission from the total reward and share the remaining after commission reward (ACR) with their voters. This form of reward sharing is completely optional and not all delegates will share their rewards. Reward sharing can vary wildly with delegates taking commissions of anywhere from 0-100% of the total rewards. You can also view current Solar delegates on the Delegates page inside the SXP Explorer . Contact Us \u00b6 If you still have questions or need more information, please feel free to ask the community .","title":"An Introduction to SXP Rewards (Staking)"},{"location":"desktop-wallet/rewards/#an-introduction-to-sxp-rewards-staking","text":"Solar is a sovereign blockchain with a native cryptoasset called SXP. It is based on the Delegated-Proof-of-Stake (DPoS) consensus mechanism and has 53 active Delegates (Validators) who secure the network. In this article, we will discuss how block rewards work within the Solar blockchain and how you can earn a portion of the rewards by becoming an active delegate or voting with your SXP coins.","title":"An Introduction to SXP Rewards (Staking)"},{"location":"desktop-wallet/rewards/#staking-considerations","text":"SXP Staking is unique in that user funds are not required to be sent or locked. When a user casts a vote, their vote-weight is assigned to the network Validator (Delegate) of their choice. A user\u2019s vote-weight adjusts automatically as funds are sent and received, and there is no need to re-vote or un-stake. To change a vote, a user simply un-votes their current Validator and elects another by casting a new vote transaction. For more information about voting and unvoting, please visit: How to Vote or Unvote a Delegate","title":"Staking Considerations"},{"location":"desktop-wallet/rewards/#staking-fees","text":"The cost of a vote covers the transaction itself. There is no requirement to send or lock additional funds in order to participate in consensus. This transaction fee is awarded to the Validator who forges the transaction in a given block. For more information about fees, please visit: Transaction Fees","title":"Staking Fees"},{"location":"desktop-wallet/rewards/#block-rewards","text":"Solar is a sovereign blockchain that is validated by 53 active Delegates. Each Delegate will submit (1) block per round. A round consists of 53 blocks. Each block on Solar has a block time of 8 seconds. Each block awards the active delegate who submits the block a dynamic and rank-based block reward with the 10% any transaction fees from that block. Block Rewards are inflationary coins, meaning the total SXP supply is increased by between x and x SXP every block. This serves as a form of consistent inflation that reduces over time due to the non-fluctuating rate of rewards. On Solar, 100% of the block reward goes to the Validator. Note: There are no \"halvenings\" of block rewards on Solar .","title":"Block Rewards"},{"location":"desktop-wallet/rewards/#reward-sharing-on-solar","text":"As previously stated, block rewards and transaction fees are awarded to the active delegate responsible for reporting a given block. We call this combination of the block reward and 10% of any fees the total reward. On Solar, many of these delegates choose to take a small commission from the total reward and share the remaining after commission reward (ACR) with their voters. This form of reward sharing is completely optional and not all delegates will share their rewards. Reward sharing can vary wildly with delegates taking commissions of anywhere from 0-100% of the total rewards. You can also view current Solar delegates on the Delegates page inside the SXP Explorer .","title":"Reward Sharing on Solar"},{"location":"desktop-wallet/rewards/#contact-us","text":"If you still have questions or need more information, please feel free to ask the community .","title":"Contact Us"},{"location":"desktop-wallet/support/troubleshooting/","text":"title: Troubleshooting # Troubleshooting This page will cover common issues related to the SXP Desktop Wallet v2.x . If your issue is not covered here, ask the community here ! ## Getting Started A user experiencing unexpected errors should first check that their apps and software are up-to-date. ### Desktop Wallet Software First, check that the latest version of the SXP Desktop Wallet is installed. All official Desktop Wallet releases can be found here If your issue is not covered here, please contact us using the \u2018Technical Support\u2019 form found here !","title":"Troubleshooting"},{"location":"desktop-wallet/user-guides/add-contact/","text":"How to Add a Contact? \u00b6 The application provides you a neat interface to add addresses to your contact list. This feature enables you to aggregate all of the addresses which you may transact with or be interested in. Adding a Contact \u00b6","title":"How to Add a Contact?"},{"location":"desktop-wallet/user-guides/add-contact/#how-to-add-a-contact","text":"The application provides you a neat interface to add addresses to your contact list. This feature enables you to aggregate all of the addresses which you may transact with or be interested in.","title":"How to Add a Contact?"},{"location":"desktop-wallet/user-guides/add-contact/#adding-a-contact","text":"","title":"Adding a Contact"},{"location":"desktop-wallet/user-guides/create-import-wallets/","text":"How to Create or Import a Wallet? \u00b6 The SXP Desktop Wallet allows you to both create new wallets and import existing ones. You can begin either process by clicking the appropriate button at the top of the sidebar when on the app dashboard. Creating a New Wallet \u00b6 Go to your Portfolio Click on \"Create\" button Select SXP as Cryptoasset Save your passphrase. Be sure it's a safe place! Confirm your passphrase, by selecting the prompted words. Great! You created a new wallet. Importing Your Wallet \u00b6 Provide the mnemonic of the wallet Click on continue, and your wallet is imported!","title":"How to Create or Import a Wallet?"},{"location":"desktop-wallet/user-guides/create-import-wallets/#how-to-create-or-import-a-wallet","text":"The SXP Desktop Wallet allows you to both create new wallets and import existing ones. You can begin either process by clicking the appropriate button at the top of the sidebar when on the app dashboard.","title":"How to Create or Import a Wallet?"},{"location":"desktop-wallet/user-guides/create-import-wallets/#creating-a-new-wallet","text":"Go to your Portfolio Click on \"Create\" button Select SXP as Cryptoasset Save your passphrase. Be sure it's a safe place! Confirm your passphrase, by selecting the prompted words. Great! You created a new wallet.","title":"Creating a New Wallet"},{"location":"desktop-wallet/user-guides/create-import-wallets/#importing-your-wallet","text":"Provide the mnemonic of the wallet Click on continue, and your wallet is imported!","title":"Importing Your Wallet"},{"location":"desktop-wallet/user-guides/register-second-passphrase/","text":"How to Register a Second Passphrase? \u00b6 Security is critical. By issuing a second signature transaction, you tell network nodes to verify that every transaction coming from your wallet is also signed by another Passphrase. Register a Second Passphrase \u00b6 For more information about fees, please visit: Transaction Fees","title":"How to Register a Second Passphrase?"},{"location":"desktop-wallet/user-guides/register-second-passphrase/#how-to-register-a-second-passphrase","text":"Security is critical. By issuing a second signature transaction, you tell network nodes to verify that every transaction coming from your wallet is also signed by another Passphrase.","title":"How to Register a Second Passphrase?"},{"location":"desktop-wallet/user-guides/register-second-passphrase/#register-a-second-passphrase","text":"For more information about fees, please visit: Transaction Fees","title":"Register a Second Passphrase"},{"location":"desktop-wallet/user-guides/send/","text":"How to Send an SXP Transfer? \u00b6 Transferring SXP from your wallet is the most common type of transaction. You can quickly send a transfer by clicking on the Send button in the header of the wallet detail page. This will bring up a prompt, on which you can fill in the required information to create a transfer transaction. For more information about fees, please visit: Transaction Fees Upon clicking Next , you will have to review the transfer transaction's details and can proceed by clicking the \"Continue\" button. Enter your mnemonic or passsword and voila!","title":"How to Send an SXP Transfer?"},{"location":"desktop-wallet/user-guides/send/#how-to-send-an-sxp-transfer","text":"Transferring SXP from your wallet is the most common type of transaction. You can quickly send a transfer by clicking on the Send button in the header of the wallet detail page. This will bring up a prompt, on which you can fill in the required information to create a transfer transaction. For more information about fees, please visit: Transaction Fees Upon clicking Next , you will have to review the transfer transaction's details and can proceed by clicking the \"Continue\" button. Enter your mnemonic or passsword and voila!","title":"How to Send an SXP Transfer?"},{"location":"desktop-wallet/user-guides/sign-verify/","text":"How to Sign and Verify Messages? \u00b6 The wallet allows you to create and sign a message that other users will be able to verify as authentically yours. Message signing and verifying is all done under the Sign tab of the wallet detail page. Signing a Message \u00b6 With a signed message, others can verify that a given message and signature combination originate from you. Verifying a Message \u00b6 To verify a message that was signed by a different wallet, you need the wallet's public key, the original message, and the resulting signature. The public key of a wallet is much like the address, except it doesn't follow the same format and is not shown by default in the Desktop Wallet. You can view your wallet's public key by clicking the key icon next to your wallet's address in the wallet detail page's header. The SXP network will only know your public key once you have sent a transaction. For demonstration purposes, the images below are shown from the perspective of a second wallet, assuming the necessary details to verify the message were provided to the verifying user.","title":"How to Sign and Verify Messages?"},{"location":"desktop-wallet/user-guides/sign-verify/#how-to-sign-and-verify-messages","text":"The wallet allows you to create and sign a message that other users will be able to verify as authentically yours. Message signing and verifying is all done under the Sign tab of the wallet detail page.","title":"How to Sign and Verify Messages?"},{"location":"desktop-wallet/user-guides/sign-verify/#signing-a-message","text":"With a signed message, others can verify that a given message and signature combination originate from you.","title":"Signing a Message"},{"location":"desktop-wallet/user-guides/sign-verify/#verifying-a-message","text":"To verify a message that was signed by a different wallet, you need the wallet's public key, the original message, and the resulting signature. The public key of a wallet is much like the address, except it doesn't follow the same format and is not shown by default in the Desktop Wallet. You can view your wallet's public key by clicking the key icon next to your wallet's address in the wallet detail page's header. The SXP network will only know your public key once you have sent a transaction. For demonstration purposes, the images below are shown from the perspective of a second wallet, assuming the necessary details to verify the message were provided to the verifying user.","title":"Verifying a Message"},{"location":"desktop-wallet/user-guides/transaction-fees/","text":"SXP Transaction Fees \u00b6 The fee associated with a transaction is awarded to the Validator who forges the transaction in a given block. Though dynamic fees allow setting a custom amount, there is no reason to increase a transaction fee above the \u2018average\u2019 at this time. A user may enter a lower fee if desired, though there is no guarantee the transaction will be forged. Fortunately, rejected transactions do not forfeit the fee as with Ethereum and its \"gas fee\". Since the SXP transaction failed and funds never technically left the user's wallet, the Desktop Wallet and Solar simply behave as if the transaction never existed.","title":"Transaction Fees"},{"location":"desktop-wallet/user-guides/transaction-fees/#sxp-transaction-fees","text":"The fee associated with a transaction is awarded to the Validator who forges the transaction in a given block. Though dynamic fees allow setting a custom amount, there is no reason to increase a transaction fee above the \u2018average\u2019 at this time. A user may enter a lower fee if desired, though there is no guarantee the transaction will be forged. Fortunately, rejected transactions do not forfeit the fee as with Ethereum and its \"gas fee\". Since the SXP transaction failed and funds never technically left the user's wallet, the Desktop Wallet and Solar simply behave as if the transaction never existed.","title":"SXP Transaction Fees"},{"location":"desktop-wallet/user-guides/vote/","text":"How to Vote in the Desktop Wallet? \u00b6 General Information \u00b6 You can use your SXP to vote or a delegate. Some basic voting info: 1 SXP address can vote for only one delegate at a time \u00b6 If you wish to vote for more than one delegate you can create multiple wallets, split your SXP among those wallets and vote for a different delegate with each wallet. For example, if you have 1000 SXP, you can vote for one delegate with all of your SXP in one wallet, or you can divide your SXP into two wallets of 500 SXP each and vote for two different delegates. You can create as many wallets as you want and divide your SXP among them in any proportion you choose. 1 SXP equals a voting weight of 1 \u00b6 The more SXP you hold, the more voting weight you possess. If you split your SXP into multiple wallets, your voting power divides proportionally among those wallets. For example, if you have 1,000 SXP your voting power is equal to 1,000 SXP. If you split your SXP into two wallets, each will have a voting power of 500 SXP. Each vote or comes with a fee \u00b6 Each transaction in the SXP network costs a certain amount of SXP. With the implementation of dynamic fees, this cost will become adjustable. You can choose how much you want to spend for each specific transaction, even for voting and for un-voting. For more information about staking, please visit: SXP Rewards (Staking) Whom to Vote For? \u00b6 Visit SXP Delegates , our community-run delegate resource, for more information on delegate proposals. From the current list of delegates, vote according to your preferences. You can also see the list of currently active delegates on our delegate monitor . Voting for a Delegate \u00b6 For more information about fees, please visit: Transaction Fees Remember that you can always change your vote!","title":"How to Vote or Unvote in the Desktop Wallet?"},{"location":"desktop-wallet/user-guides/vote/#how-to-vote-in-the-desktop-wallet","text":"","title":"How to Vote in the Desktop Wallet?"},{"location":"desktop-wallet/user-guides/vote/#general-information","text":"You can use your SXP to vote or a delegate. Some basic voting info:","title":"General Information"},{"location":"desktop-wallet/user-guides/vote/#1-sxp-address-can-vote-for-only-one-delegate-at-a-time","text":"If you wish to vote for more than one delegate you can create multiple wallets, split your SXP among those wallets and vote for a different delegate with each wallet. For example, if you have 1000 SXP, you can vote for one delegate with all of your SXP in one wallet, or you can divide your SXP into two wallets of 500 SXP each and vote for two different delegates. You can create as many wallets as you want and divide your SXP among them in any proportion you choose.","title":"1 SXP address can vote for only one delegate at a time"},{"location":"desktop-wallet/user-guides/vote/#1-sxp-equals-a-voting-weight-of-1","text":"The more SXP you hold, the more voting weight you possess. If you split your SXP into multiple wallets, your voting power divides proportionally among those wallets. For example, if you have 1,000 SXP your voting power is equal to 1,000 SXP. If you split your SXP into two wallets, each will have a voting power of 500 SXP.","title":"1 SXP equals a voting weight of 1"},{"location":"desktop-wallet/user-guides/vote/#each-vote-or-comes-with-a-fee","text":"Each transaction in the SXP network costs a certain amount of SXP. With the implementation of dynamic fees, this cost will become adjustable. You can choose how much you want to spend for each specific transaction, even for voting and for un-voting. For more information about staking, please visit: SXP Rewards (Staking)","title":"Each vote or comes with a fee"},{"location":"desktop-wallet/user-guides/vote/#whom-to-vote-for","text":"Visit SXP Delegates , our community-run delegate resource, for more information on delegate proposals. From the current list of delegates, vote according to your preferences. You can also see the list of currently active delegates on our delegate monitor .","title":"Whom to Vote For?"},{"location":"desktop-wallet/user-guides/vote/#voting-for-a-delegate","text":"For more information about fees, please visit: Transaction Fees Remember that you can always change your vote!","title":"Voting for a Delegate"},{"location":"exchanges/api-guide/","text":"Exchanges API Guide \u00b6 Connecting to the PUBLIC API is done via the Crypto and Client SDKs . Many queries can be performed using the Client SDK alone, while the Crypto SDK performs any actions requiring cryptographic functionality (i.e., signing transactions). At a surface level, the two SDKs are separated by their functions and intended use cases: The Crypto SDK provides the cryptographic functions necessary to verify and validate Solar transactions. The Client SDK provides wrapper functions to unify and streamline API calls between your application and the Solar blockchain. Put another way, the Crypto SDK structures your data in a format that all Solar nodes can understand, while the Client SDK handles the actual communication between your application and an Solar node. Where the Crypto SDK is internal, the Client SDK is external, as the below diagram illustrates: note The Public API is only available after a node has fully synced. This ensures your data on the blockchain is up to date. Setup \u00b6 These quick actions will all assume you've loaded a Client instance with the IP address of your node and the API version you're requesting. const { Connection } = require ( \"@solar-network/client\" ); const client = new Connection ( \"https://sxp.testnet.sh/api\" ); Check Wallet Balance \u00b6 Checking a wallet balance involves using the wallets resource to GET the wallet corresponding to a given Solar address. const wallet = await client . api ( \"wallets\" ). get ( \"SN52X5W9U2JWj3P6jd3ZHnSddUo7UJ4ASd\" ); console . log ( wallet . body . data . balance ); Find Block Information \u00b6 If you know the ID of the block you are looking for, you can use the GET method on the blocks resource to return information on that block. const block = await client . api ( \"blocks\" ). get ( \"b67c1c27cd37254fbec29055abe609c61dda1aecfab991a2bb284463328eb427\" ); console . log ( block ); Alternatively, if you are not sure of the block ID, or if you want to find all blocks in a range, you can make use of the blocks all method. This endpoint accepts a JSON object representing the search parameters to use when narrowing down a list of blocks. The following block properties can be used to create your range: timestamp height numberOfTransactions totalAmount totalFee reward payloadLength To use any of these properties as a range, include the relevant key in your request as an object containing from and to specifiers. For example, this code can be used to search all blocks between blockchain heights 720 and 735 with total fees between 0 and 2000 satoshi: const blocks = await client . api ( \"blocks\" ). all ({ height : { from : 720 , to : 735 }, totalFee : { from : 0 , to : 2000 } }); console . log ( blocks ); // all blocks matching the search criteria Create and Broadcast Transactions \u00b6 To create transactions, make use of the transactionBuilder module of @solar-network/crypto . First, install the package from pnpm or equivalent: pnpm install @solar-network/crypto The crypto package functionality we'll use here is the transactionBuilder, which provides a series of \"chainable\" methods that can be called, one after another, to produce a transaction object. These methods create and define your transaction: its type, its amount in satoshi, its signature, and more. Regardless of which SDK you use, every transactionBuilder contains a similar function to getStruct , which will return a completed transaction object. After making one or more of these transaction objects, you can combine them into an array to use as the transactions key in your request. With all the steps together, here is an example of how to send a transaction for approval: const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://sxp.testnet.sh/api\" ); // Set the network configuration Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . transfer () . nonce ( senderNonce . toFixed ()) . memo ( \"This is an example memo\" ) . addTransfer ( \"Address of Recipient Wallet 1\" , 1 * 1e8 ) . addTransfer ( \"Address of Recipient Wallet 2\" , 1 * 1e8 ) . addTransfer ( \"Address of Recipient Wallet 3\" , 1 * 1e8 ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); When sending your request using the client , ensure that the value of transactions is an array, even if you have only one transaction object. If your request is successful, you will receive a response with the following data key: { data : { accept : [ '96e3952b66a370d8145055b55cedc6f1435b3a71cb17334aa954f8844ad1202f' ], broadcast : [ '96e3952b66a370d8145055b55cedc6f1435b3a71cb17334aa954f8844ad1202f' ], excess : [], invalid : [] }, errors : null } Let us look at the returned data object in more depth. It is composed of four arrays, each holding zero or more transaction IDs: accept - a list of all accepted transactions broadcast - a list of all transactions broadcast to the network excess - if the node's transaction pool is full, this lists all excess transactions invalid - a list of all transactions deemed invalid by the node Our sample code above submitted one transaction, which the node accepted and broadcast and thus the accept and broadcast arrays contain precisely one item each: the ID of the transaction we submitted. If we had submitted any invalid transactions, the invalid list would have contained their IDs, and the errors key would have been populated with one error per invalid transaction. The diagram below offers a top-level overview of the transaction submission process: Check Transaction Confirmations \u00b6 Once a transaction has been created and added to the blockchain, you can access the number of confirmations it has by using the transactions resource to get the value matching the transaction ID. const transaction = await client . api ( \"transactions\" ). get ( \"2b327657495156f5a4f7ca5cefebb9d35a92c91a74debdd217a0c79110e24915\" ); console . log ( transaction ); If the transaction has been added to the blockchain, you'll receive the following data structure in your console: { data : { id : \"2b327657495156f5a4f7ca5cefebb9d35a92c91a74debdd217a0c79110e24915\" , blockHeight : 2407559 , blockId : \"0c83cde40ea873cf79ba3c747b6199512e24bf11aac262e10efe259da2588a74\" , version : 3 , type : 0 , typeGroup : 1 , amount : \"500000000000\" , fee : \"5000000\" , burnedFee : \"4500000\" , sender : \"SP77TpbBYC2nCpaCg3u1BBsYU7zqwqzGo7\" , senderPublicKey : \"02699ab620eb6088f9e88d2c1fa1fb0ea8a179c210a46de2314817dd11d3aa16a1\" , recipient : \"SS1yerXEXkf53KMvhkhNc4RUFSLu9SRR8V\" , signature : \"df15dae2b84bb19270a2d2cb15a14115b752d3967ce228e84918bdd8e90925627c4aae6b244a529303ca53777c6a81775ed8bad9ded7801b3df879ccbb388aef\" , memo : \"bsc:0x488cec5457eec7757984db50bf7d05972da1b1560cc440e2e6a4727ac762bb32\" , confirmations : 1308 , timestamp : { epoch : 19270904 , unix : 1667761304 , human : \"2022-11-06T19:01:44.000Z\" }, nonce : \"4546\" } } You can see that the confirmations key holds the number of confirmations this transaction has received from the network, in the above case 0. As the average block takes 8 seconds to forge, finality is typically established within a minute following a transaction's addition to the blockchain. Check Node Status \u00b6 Checking node status can be done by using the node resource's status method: const status = await client . api ( \"node\" ). status (); console . log ( status ); By running this code, you'd see the output in your console resembling the following object: { data : { synced : true , // whether this node is fully synchronised with the network now : 2408921 , // the current network height of this node's blockchain blocksCount : 0 , // if not synced, the number of blocks yet to be synced timestamp : 19281807 } } If synced is true, your node is operating as expected and fully synced with the Solar network. Otherwise, use the blocksCount key to get an estimation of how long your node will take to sync.","title":"Public API Guide"},{"location":"exchanges/api-guide/#exchanges-api-guide","text":"Connecting to the PUBLIC API is done via the Crypto and Client SDKs . Many queries can be performed using the Client SDK alone, while the Crypto SDK performs any actions requiring cryptographic functionality (i.e., signing transactions). At a surface level, the two SDKs are separated by their functions and intended use cases: The Crypto SDK provides the cryptographic functions necessary to verify and validate Solar transactions. The Client SDK provides wrapper functions to unify and streamline API calls between your application and the Solar blockchain. Put another way, the Crypto SDK structures your data in a format that all Solar nodes can understand, while the Client SDK handles the actual communication between your application and an Solar node. Where the Crypto SDK is internal, the Client SDK is external, as the below diagram illustrates: note The Public API is only available after a node has fully synced. This ensures your data on the blockchain is up to date.","title":"Exchanges API Guide"},{"location":"exchanges/api-guide/#setup","text":"These quick actions will all assume you've loaded a Client instance with the IP address of your node and the API version you're requesting. const { Connection } = require ( \"@solar-network/client\" ); const client = new Connection ( \"https://sxp.testnet.sh/api\" );","title":"Setup"},{"location":"exchanges/api-guide/#check-wallet-balance","text":"Checking a wallet balance involves using the wallets resource to GET the wallet corresponding to a given Solar address. const wallet = await client . api ( \"wallets\" ). get ( \"SN52X5W9U2JWj3P6jd3ZHnSddUo7UJ4ASd\" ); console . log ( wallet . body . data . balance );","title":"Check Wallet Balance"},{"location":"exchanges/api-guide/#find-block-information","text":"If you know the ID of the block you are looking for, you can use the GET method on the blocks resource to return information on that block. const block = await client . api ( \"blocks\" ). get ( \"b67c1c27cd37254fbec29055abe609c61dda1aecfab991a2bb284463328eb427\" ); console . log ( block ); Alternatively, if you are not sure of the block ID, or if you want to find all blocks in a range, you can make use of the blocks all method. This endpoint accepts a JSON object representing the search parameters to use when narrowing down a list of blocks. The following block properties can be used to create your range: timestamp height numberOfTransactions totalAmount totalFee reward payloadLength To use any of these properties as a range, include the relevant key in your request as an object containing from and to specifiers. For example, this code can be used to search all blocks between blockchain heights 720 and 735 with total fees between 0 and 2000 satoshi: const blocks = await client . api ( \"blocks\" ). all ({ height : { from : 720 , to : 735 }, totalFee : { from : 0 , to : 2000 } }); console . log ( blocks ); // all blocks matching the search criteria","title":"Find Block Information"},{"location":"exchanges/api-guide/#create-and-broadcast-transactions","text":"To create transactions, make use of the transactionBuilder module of @solar-network/crypto . First, install the package from pnpm or equivalent: pnpm install @solar-network/crypto The crypto package functionality we'll use here is the transactionBuilder, which provides a series of \"chainable\" methods that can be called, one after another, to produce a transaction object. These methods create and define your transaction: its type, its amount in satoshi, its signature, and more. Regardless of which SDK you use, every transactionBuilder contains a similar function to getStruct , which will return a completed transaction object. After making one or more of these transaction objects, you can combine them into an array to use as the transactions key in your request. With all the steps together, here is an example of how to send a transaction for approval: const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://sxp.testnet.sh/api\" ); // Set the network configuration Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . transfer () . nonce ( senderNonce . toFixed ()) . memo ( \"This is an example memo\" ) . addTransfer ( \"Address of Recipient Wallet 1\" , 1 * 1e8 ) . addTransfer ( \"Address of Recipient Wallet 2\" , 1 * 1e8 ) . addTransfer ( \"Address of Recipient Wallet 3\" , 1 * 1e8 ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); When sending your request using the client , ensure that the value of transactions is an array, even if you have only one transaction object. If your request is successful, you will receive a response with the following data key: { data : { accept : [ '96e3952b66a370d8145055b55cedc6f1435b3a71cb17334aa954f8844ad1202f' ], broadcast : [ '96e3952b66a370d8145055b55cedc6f1435b3a71cb17334aa954f8844ad1202f' ], excess : [], invalid : [] }, errors : null } Let us look at the returned data object in more depth. It is composed of four arrays, each holding zero or more transaction IDs: accept - a list of all accepted transactions broadcast - a list of all transactions broadcast to the network excess - if the node's transaction pool is full, this lists all excess transactions invalid - a list of all transactions deemed invalid by the node Our sample code above submitted one transaction, which the node accepted and broadcast and thus the accept and broadcast arrays contain precisely one item each: the ID of the transaction we submitted. If we had submitted any invalid transactions, the invalid list would have contained their IDs, and the errors key would have been populated with one error per invalid transaction. The diagram below offers a top-level overview of the transaction submission process:","title":"Create and Broadcast Transactions"},{"location":"exchanges/api-guide/#check-transaction-confirmations","text":"Once a transaction has been created and added to the blockchain, you can access the number of confirmations it has by using the transactions resource to get the value matching the transaction ID. const transaction = await client . api ( \"transactions\" ). get ( \"2b327657495156f5a4f7ca5cefebb9d35a92c91a74debdd217a0c79110e24915\" ); console . log ( transaction ); If the transaction has been added to the blockchain, you'll receive the following data structure in your console: { data : { id : \"2b327657495156f5a4f7ca5cefebb9d35a92c91a74debdd217a0c79110e24915\" , blockHeight : 2407559 , blockId : \"0c83cde40ea873cf79ba3c747b6199512e24bf11aac262e10efe259da2588a74\" , version : 3 , type : 0 , typeGroup : 1 , amount : \"500000000000\" , fee : \"5000000\" , burnedFee : \"4500000\" , sender : \"SP77TpbBYC2nCpaCg3u1BBsYU7zqwqzGo7\" , senderPublicKey : \"02699ab620eb6088f9e88d2c1fa1fb0ea8a179c210a46de2314817dd11d3aa16a1\" , recipient : \"SS1yerXEXkf53KMvhkhNc4RUFSLu9SRR8V\" , signature : \"df15dae2b84bb19270a2d2cb15a14115b752d3967ce228e84918bdd8e90925627c4aae6b244a529303ca53777c6a81775ed8bad9ded7801b3df879ccbb388aef\" , memo : \"bsc:0x488cec5457eec7757984db50bf7d05972da1b1560cc440e2e6a4727ac762bb32\" , confirmations : 1308 , timestamp : { epoch : 19270904 , unix : 1667761304 , human : \"2022-11-06T19:01:44.000Z\" }, nonce : \"4546\" } } You can see that the confirmations key holds the number of confirmations this transaction has received from the network, in the above case 0. As the average block takes 8 seconds to forge, finality is typically established within a minute following a transaction's addition to the blockchain.","title":"Check Transaction Confirmations"},{"location":"exchanges/api-guide/#check-node-status","text":"Checking node status can be done by using the node resource's status method: const status = await client . api ( \"node\" ). status (); console . log ( status ); By running this code, you'd see the output in your console resembling the following object: { data : { synced : true , // whether this node is fully synchronised with the network now : 2408921 , // the current network height of this node's blockchain blocksCount : 0 , // if not synced, the number of blocks yet to be synced timestamp : 19281807 } } If synced is true, your node is operating as expected and fully synced with the Solar network. Otherwise, use the blocksCount key to get an estimation of how long your node will take to sync.","title":"Check Node Status"},{"location":"exchanges/intro/","text":"Welcome to Solar \u00b6 This section is tailored for institutional/production usage of Solar Core The Solar Blockchain provides a Public API for interacting with the chain and its native SXP token. The proceeding pages describe the process of interacting with the Solar Blockchain and offers examples for accomplishing the most common chain-related tasks. Try the Public APIs now! Mainnet - api.solar.org Testnet - tapi.solar.org","title":"Welcome to Solar"},{"location":"exchanges/intro/#welcome-to-solar","text":"This section is tailored for institutional/production usage of Solar Core The Solar Blockchain provides a Public API for interacting with the chain and its native SXP token. The proceeding pages describe the process of interacting with the Solar Blockchain and offers examples for accomplishing the most common chain-related tasks. Try the Public APIs now! Mainnet - api.solar.org Testnet - tapi.solar.org","title":"Welcome to Solar"},{"location":"exchanges/rate-limits/","text":"Configuring Rate Limits \u00b6 Solar Core is mainly used in the context of public services, providing desktop wallets with the necessary endpoints to function. Since they serve anonymous users and to protect against DDoS attacks, Solar Core nodes have strict rate limits. Enterprise users (such as exchanges) might encounter a problem creating large batches of transactions and broadcasting them. The rate limit can be configured in multiple ways to solve these problems. Exceeding the Rate Limit \u00b6 By default, rate limits are enabled on Solar Core nodes. When the rate limit is exceeded; a 429 HTTP status is returned. Configuring the Rate Limit \u00b6 You can fine tune or completely disable the node's rate limit by editing the .env file found at ~/.config/solar-core/{network}/.env . Find most important parameters below: CORE_API_RATE_LIMIT_DISABLED = true CORE_API_RATE_LIMIT_USER_LIMIT = 300 CORE_API_RATE_LIMIT_WHITELIST = 127.0.0.1 , 192.168.1.1 , 172.31.255.1 Setting CORE_API_RATE_LIMIT_DISABLED=true will globally disable all rate limits. For internal use this is safe. More fine-grained control may be exerted by using CORE_API_RATE_LIMIT_USER_LIMIT , which uses IP addresses to assign rate limits. The unit is requests/minute (default: 100 requests/per minute/per IP). Excluding certain IP addresses from rate limiting can be achieved by setting CORE_API_RATE_LIMIT_WHITELIST= followed by comma separated list of IP addresses (default: 172.0.0.1). Use case 1: Disable Rate Limits \u00b6 warning Make sure API is accessible only to your internal network and not visible to the outside world. CORE_API_RATE_LIMIT_DISABLED = true Use case 2: Whitelisting \u00b6 info Instead of globally disabling rate limits it is possible to exclude certain IP addresses from rate limits and raise the global limits. CORE_API_RATE_LIMIT_WHITELIST = 127.0.0.1 , 192.168.1.1 , 172.31.255.1 CORE_API_RATE_LIMIT_USER_LIMIT = 300","title":"Rate Limits"},{"location":"exchanges/rate-limits/#configuring-rate-limits","text":"Solar Core is mainly used in the context of public services, providing desktop wallets with the necessary endpoints to function. Since they serve anonymous users and to protect against DDoS attacks, Solar Core nodes have strict rate limits. Enterprise users (such as exchanges) might encounter a problem creating large batches of transactions and broadcasting them. The rate limit can be configured in multiple ways to solve these problems.","title":"Configuring Rate Limits"},{"location":"exchanges/rate-limits/#exceeding-the-rate-limit","text":"By default, rate limits are enabled on Solar Core nodes. When the rate limit is exceeded; a 429 HTTP status is returned.","title":"Exceeding the Rate Limit "},{"location":"exchanges/rate-limits/#configuring-the-rate-limit","text":"You can fine tune or completely disable the node's rate limit by editing the .env file found at ~/.config/solar-core/{network}/.env . Find most important parameters below: CORE_API_RATE_LIMIT_DISABLED = true CORE_API_RATE_LIMIT_USER_LIMIT = 300 CORE_API_RATE_LIMIT_WHITELIST = 127.0.0.1 , 192.168.1.1 , 172.31.255.1 Setting CORE_API_RATE_LIMIT_DISABLED=true will globally disable all rate limits. For internal use this is safe. More fine-grained control may be exerted by using CORE_API_RATE_LIMIT_USER_LIMIT , which uses IP addresses to assign rate limits. The unit is requests/minute (default: 100 requests/per minute/per IP). Excluding certain IP addresses from rate limiting can be achieved by setting CORE_API_RATE_LIMIT_WHITELIST= followed by comma separated list of IP addresses (default: 172.0.0.1).","title":"Configuring the Rate Limit "},{"location":"exchanges/rate-limits/#use-case-1-disable-rate-limits","text":"warning Make sure API is accessible only to your internal network and not visible to the outside world. CORE_API_RATE_LIMIT_DISABLED = true","title":"Use case 1: Disable Rate Limits  "},{"location":"exchanges/rate-limits/#use-case-2-whitelisting","text":"info Instead of globally disabling rate limits it is possible to exclude certain IP addresses from rate limits and raise the global limits. CORE_API_RATE_LIMIT_WHITELIST = 127.0.0.1 , 192.168.1.1 , 172.31.255.1 CORE_API_RATE_LIMIT_USER_LIMIT = 300","title":"Use case 2: Whitelisting  "},{"location":"exchanges/node-installation/baremetal/","text":"Installation Steps \u00b6 A step-by-step guide on how to prepare a fully-functional environment using the install script. Getting Started \u00b6 The instructions on this page will guide you through creating a new user account with the correct privileges, installing and configuring Solar Core, then starting a relay instance and logging the output using the installation script. Directly below is a quick summary of these install commands: sudo adduser solar sudo usermod -a -G sudo solar su -l solar wget -O install.sh https://raw.githubusercontent.com/solar-network/core/main/install.sh bash install.sh solar relay:start pm2 logs Step-by-Step Installation via the Script \u00b6 If you are planning to setup a new server you can execute the following steps. Step 1: Create a New Account \u00b6 Create a new dedicated user account to manage SXP-related software. We\u2019ll illustrate this command as sudo adduser solar to create a user by the name of \u2018solar\u2019 , but you can chose something else, if preferred. On your server, type the following into the command line: sudo adduser solar You'll be asked to create and confirm a new user password, and be prompted to enter the user\u2019s full name and some other information. ( Feel free to leave them blank by pressing \u2018enter\u2019, they are all optional fields. ) When prompted to confirm, type \u2018Y\u2019 and press \u2018enter\u2019 to finish. Adding user 'solar' ... Adding new group 'solar' ( 1000 ) ... Adding new user 'solar' ( 1000 ) with group 'solar' ... Creating home directory '/home/solar' ... Copying files from '/etc/skel' ... Enter new UNIX password: Retype new UNIX password: passwd: password updated successfully Changing the user information for solar Enter the new value, or press ENTER for the default Full Name [] : Room Number [] : Work Phone [] : Home Phone [] : Other [] : Is the information correct? [ Y/n ] Y Step 2: Grant Sudo Privileges \u00b6 Next, we need to make sure that our user account has all of the necessary privileges to run Solar Core properly. This will give our user account sudo privileges. Type or copy-paste the following command into your terminal: sudo usermod -a -G sudo solar info In this example we use 'solar' for the name of the new user account, but you should use whatever username was set in the previous steps above. Step 3: Login as the New User \u00b6 We now should switch to the user account created above, this will also land us in the user's base directory ( ~/ ). Type or copy-paste the following command into your terminal: su -l solar Step 4: Run the Installation Script \u00b6 Here, we will use the install.sh script. This installs Solar Core and all of its dependencies onto your server, then publishes the configuration files for it. Run the install script by copying and pasting this one line command into your terminal: wget -O install.sh https://raw.githubusercontent.com/solar-network/core/main/install.sh bash install.sh \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551 \u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557 \u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2551 \u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d \u255a\u2550\u255d\u255a\u2550\u255d \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d Thanks for choosing to install Solar Core! Preparing the setup procedure... Step 5: Select the Core network \u00b6 Once the installation of dependencies and Solar Core is finished you will need to select which network you wish to operate on. This can be achieved by pressing the up or down arrow keys and confirming your selection by pressing enter . Mainnet is the public network, Testnet is the development network for testing. ? Which network do you want to connect to? \u203a - Use arrow-keys. Return to submit. \u276f Mainnet Testnet After you have made your selection, you will need to confirm by pressing y and confirm again with enter \u2714 Which network do you want to connect to? \u203a Mainnet ? Are you sure? \u203a ( y/N ) The installation process will then proceed. Installing Solar Core for mainnet. This process may take a few minutes \u2826 Downloading operating system dependencies \u203a Installing operating system dependencies \u203a Downloading Core 4 .1.3 \u203a Downloading Core dependencies \u203a Installing Core dependencies \u203a Building Core 4 .1.3 \u203a Saving configuration \u203a Adding plugins \u203a Setting up database warning The install process might take a while, don\u2019t interrupt it, wait for it to finish. At this point, Solar Core has been successfully installed with its configuration options properly published. Installing Solar Core for mainnet. This process may take a few minutes \u2714 Downloading operating system dependencies \u2714 Installing operating system dependencies \u2714 Downloading Core 4 .1.3 \u2714 Downloading Core dependencies \u2714 Installing Core dependencies \u2714 Building Core 4 .1.3 \u2714 Saving configuration \u2714 Adding plugins \u2714 Setting up database Solar Core has been successfully installed! To get started, type solar To run a command as administrator ( user \"root\" ) , use \"sudo <command>\" . See \"man sudo_root\" for details. Success \u00b6 Your installation is all set! \ud83c\udf89 That\u2019s it, you may now start your relay and view its logs using the following command: solar relay:start && pm2 logs \u2714 Starting solar-relay ... 1 | solar-relay | [ 2022 -11-06 22 :36:49.742 ] INFO: Connecting to database: solar_mainnet 1 | solar-relay | [ 2022 -11-06 22 :36:49.803 ] DEBUG: Database migration: Creating rounds table 1 | solar-relay | [ 2022 -11-06 22 :36:49.809 ] DEBUG: Database migration: Creating blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.816 ] DEBUG: Database migration: Creating transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.821 ] DEBUG: Database migration: Adding block_id index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.823 ] DEBUG: Database migration: Adding generator_public_key index to blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.825 ] DEBUG: Database migration: Adding timestamp index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.827 ] DEBUG: Database migration: Adding sender_public_key index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.829 ] DEBUG: Database migration: Adding recipient_id index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.832 ] DEBUG: Database migration: Adding block_id constraint to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.834 ] DEBUG: Database migration: Dropping id from rounds table 1 | solar-relay | [ 2022 -11-06 22 :36:49.836 ] DEBUG: Database migration: Adding chained_blocks constraint to blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.838 ] DEBUG: Database migration: Adding type_group to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.839 ] DEBUG: Database migration: Adding nonce to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.843 ] DEBUG: Database migration: Adding nonce trigger to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.845 ] DEBUG: Database migration: Adding asset to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.846 ] DEBUG: Database migration: Renaming and converting vendor_field_hex to vendor_field in transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.851 ] DEBUG: Database migration: Adding type index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.853 ] DEBUG: Database migration: Adding type_group index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.855 ] DEBUG: Database migration: Adding indexes to blocks and transactions tables 1 | solar-relay | [ 2022 -11-06 22 :36:49.880 ] DEBUG: Database migration: Adding block_height to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.885 ] DEBUG: Database migration: Creating wallets table 1 | solar-relay | [ 2022 -11-06 22 :36:49.889 ] DEBUG: Database migration: Adding payments asset index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.890 ] DEBUG: Database migration: Configuring autovacuum on all tables 1 | solar-relay | [ 2022 -11-06 22 :36:49.891 ] DEBUG: Database migration: Adding generator_public_key index to blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.893 ] DEBUG: Database migration: Adding burned_fee to blocks and transactions tables 1 | solar-relay | [ 2022 -11-06 22 :36:49.898 ] DEBUG: Database migration: Adding dev_fund to blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.901 ] DEBUG: Database migration: Disabling fastupdate on indexes in transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.902 ] DEBUG: Database migration: Renaming serialized to serialised in transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.903 ] DEBUG: Database migration: Renaming payments asset to transfers in transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.905 ] DEBUG: Database migration: Setting empty recipient_id to null in transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.906 ] DEBUG: Database migration: Setting zero amount to null in transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.907 ] DEBUG: Database migration: Renaming vendor_field to memo in transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.908 ] DEBUG: Database migration: Adding username to blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.911 ] DEBUG: Database migration: Creating missed_blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.913 ] DEBUG: Database migration: Adding sender_id to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.915 ] DEBUG: Database migration: Adding id index with operator class to blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.917 ] DEBUG: Database migration: Adding id index with operator class to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.918 ] DEBUG: Database migration: Renaming dev_fund to donations in blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.921 ] DEBUG: Database migration: Adding timestamp, username index to blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.923 ] DEBUG: Database migration: Adding type, type_group index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.926 ] DEBUG: Updating database configuration \ud83d\udcda 1 | solar-relay | [ 2022 -11-06 22 :36:49.928 ] DEBUG: Connection established 1 | solar-relay | [ 2022 -11-06 22 :36:49.938 ] INFO: Loaded SXP Swap Plugin 1 | solar-relay | [ 2022 -11-06 22 :36:50.192 ] WARNING: No block found in database \ud83d\ude2f 1 | solar-relay | [ 2022 -11-06 22 :36:50.236 ] NOTICE: Milestone change 1 | solar-relay | [ 2022 -11-06 22 :36:50.303 ] INFO: P2P Server started at http://suitable-wagtail:6001 1 | solar-relay | [ 2022 -11-06 22 :36:50.304 ] INFO: Starting Blockchain Manager \u26d3\ufe0f 1 | solar-relay | [ 2022 -11-06 22 :36:50.309 ] DEBUG: event 'START' : \"uninitialised\" -> \"initialise\" -> actions: [ initialise ] 1 | solar-relay | [ 2022 -11-06 22 :36:50.313 ] INFO: Last block in database: 1 1 | solar-relay | [ 2022 -11-06 22 :36:50.314 ] INFO: No saved states exist so a fresh state will now be generated \u203c\ufe0f 1 | solar-relay | [ 2022 -11-06 22 :36:50.314 ] INFO: Verifying database integrity \u23f3 1 | solar-relay | [ 2022 -11-06 22 :36:50.345 ] INFO: Verified database integrity \ud83d\ude38 1 | solar-relay | [ 2022 -11-06 22 :36:50.350 ] INFO: State Generation - Step 1 of 16 : LegacyTransfer 1 | solar-relay | [ 2022 -11-06 22 :36:50.359 ] INFO: State Generation - Step 2 of 16 : SecondSignature 1 | solar-relay | [ 2022 -11-06 22 :36:50.361 ] INFO: State Generation - Step 3 of 16 : DelegateRegistration 1 | solar-relay | [ 2022 -11-06 22 :36:50.374 ] INFO: State Generation - Step 4 of 16 : LegacyVote 1 | solar-relay | [ 2022 -11-06 22 :36:50.384 ] INFO: State Generation - Step 5 of 16 : MultiSignature 1 | solar-relay | [ 2022 -11-06 22 :36:50.391 ] INFO: State Generation - Step 6 of 16 : Ipfs 1 | solar-relay | [ 2022 -11-06 22 :36:50.393 ] INFO: State Generation - Step 7 of 16 : Transfer 1 | solar-relay | [ 2022 -11-06 22 :36:50.396 ] INFO: State Generation - Step 8 of 16 : DelegateResignation 1 | solar-relay | [ 2022 -11-06 22 :36:50.397 ] INFO: State Generation - Step 9 of 16 : HtlcLock 1 | solar-relay | [ 2022 -11-06 22 :36:50.401 ] INFO: State Generation - Step 10 of 16 : HtlcClaim 1 | solar-relay | [ 2022 -11-06 22 :36:50.404 ] INFO: State Generation - Step 11 of 16 : HtlcRefund 1 | solar-relay | [ 2022 -11-06 22 :36:50.407 ] INFO: State Generation - Step 12 of 16 : Burn 1 | solar-relay | [ 2022 -11-06 22 :36:50.409 ] INFO: State Generation - Step 13 of 16 : Vote 1 | solar-relay | [ 2022 -11-06 22 :36:50.410 ] INFO: State Generation - Step 14 of 16 : Fees & Nonces 1 | solar-relay | [ 2022 -11-06 22 :36:50.412 ] INFO: State Generation - Step 15 of 16 : Block Rewards 1 | solar-relay | [ 2022 -11-06 22 :36:50.414 ] INFO: State Generation - Step 16 of 16 : Vote Balances & Delegate Ranking 1 | solar-relay | [ 2022 -11-06 22 :36:50.418 ] INFO: Number of registered delegates: 53 1 | solar-relay | [ 2022 -11-06 22 :36:50.420 ] INFO: Calculating productivity data \ud83e\uddee 1 | solar-relay | [ 2022 -11-06 22 :36:50.440 ] DEBUG: Loaded 53 active delegates 1 | solar-relay | [ 2022 -11-06 22 :36:50.446 ] INFO: Starting Round 1 \ud83d\udd4a\ufe0f 1 | solar-relay | [ 2022 -11-06 22 :36:50.448 ] DEBUG: Loaded 53 active delegates 1 | solar-relay | [ 2022 -11-06 22 :36:50.449 ] INFO: Saving round 1 1 | solar-relay | [ 2022 -11-06 22 :36:50.655 ] INFO: Your network connectivity has been verified by 8 .8.4.4 \u2705 ... 1 | solar-re | [ 2022 -11-06 22 :40:46.370 ] DEBUG: Delegate bfx is allowed to forge block 76 ,805 \ud83d\udc4d 1 | solar-re | [ 2022 -11-06 22 :40:46.371 ] DEBUG: Delegate sxp is allowed to forge block 76 ,807 \ud83d\udc4d 1 | solar-re | [ 2022 -11-06 22 :40:46.372 ] DEBUG: Delegate sl33p is allowed to forge block 76 ,809 \ud83d\udc4d 1 | solar-re | [ 2022 -11-06 22 :40:46.373 ] DEBUG: Delegate advin is allowed to forge block 76 ,816 \ud83d\udc4d 1 | solar-re | [ 2022 -11-06 22 :40:46.383 ] DEBUG: Delegate cactus1549 is allowed to forge block 76 ,819 \ud83d\udc4d ... info Synchronisation of the blockchain can take some time. Once synchronised, the `allowed to forge block ...` messages will be logged every ~8 seconds \u2014 as opposed to milliseconds apart shown during sync. A single round consists of 53 delegates, each forging a single block.","title":"Installation Steps"},{"location":"exchanges/node-installation/baremetal/#installation-steps","text":"A step-by-step guide on how to prepare a fully-functional environment using the install script.","title":"Installation Steps"},{"location":"exchanges/node-installation/baremetal/#getting-started","text":"The instructions on this page will guide you through creating a new user account with the correct privileges, installing and configuring Solar Core, then starting a relay instance and logging the output using the installation script. Directly below is a quick summary of these install commands: sudo adduser solar sudo usermod -a -G sudo solar su -l solar wget -O install.sh https://raw.githubusercontent.com/solar-network/core/main/install.sh bash install.sh solar relay:start pm2 logs","title":"Getting Started"},{"location":"exchanges/node-installation/baremetal/#step-by-step-installation-via-the-script","text":"If you are planning to setup a new server you can execute the following steps.","title":"Step-by-Step Installation via the Script"},{"location":"exchanges/node-installation/baremetal/#step-1-create-a-new-account","text":"Create a new dedicated user account to manage SXP-related software. We\u2019ll illustrate this command as sudo adduser solar to create a user by the name of \u2018solar\u2019 , but you can chose something else, if preferred. On your server, type the following into the command line: sudo adduser solar You'll be asked to create and confirm a new user password, and be prompted to enter the user\u2019s full name and some other information. ( Feel free to leave them blank by pressing \u2018enter\u2019, they are all optional fields. ) When prompted to confirm, type \u2018Y\u2019 and press \u2018enter\u2019 to finish. Adding user 'solar' ... Adding new group 'solar' ( 1000 ) ... Adding new user 'solar' ( 1000 ) with group 'solar' ... Creating home directory '/home/solar' ... Copying files from '/etc/skel' ... Enter new UNIX password: Retype new UNIX password: passwd: password updated successfully Changing the user information for solar Enter the new value, or press ENTER for the default Full Name [] : Room Number [] : Work Phone [] : Home Phone [] : Other [] : Is the information correct? [ Y/n ] Y","title":"Step 1: Create a New Account"},{"location":"exchanges/node-installation/baremetal/#step-2-grant-sudo-privileges","text":"Next, we need to make sure that our user account has all of the necessary privileges to run Solar Core properly. This will give our user account sudo privileges. Type or copy-paste the following command into your terminal: sudo usermod -a -G sudo solar info In this example we use 'solar' for the name of the new user account, but you should use whatever username was set in the previous steps above.","title":"Step 2: Grant Sudo Privileges"},{"location":"exchanges/node-installation/baremetal/#step-3-login-as-the-new-user","text":"We now should switch to the user account created above, this will also land us in the user's base directory ( ~/ ). Type or copy-paste the following command into your terminal: su -l solar","title":"Step 3: Login as the New User"},{"location":"exchanges/node-installation/baremetal/#step-4-run-the-installation-script","text":"Here, we will use the install.sh script. This installs Solar Core and all of its dependencies onto your server, then publishes the configuration files for it. Run the install script by copying and pasting this one line command into your terminal: wget -O install.sh https://raw.githubusercontent.com/solar-network/core/main/install.sh bash install.sh \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551 \u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557 \u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2551 \u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d \u255a\u2550\u255d\u255a\u2550\u255d \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d Thanks for choosing to install Solar Core! Preparing the setup procedure...","title":"Step 4: Run the Installation Script"},{"location":"exchanges/node-installation/baremetal/#step-5-select-the-core-network","text":"Once the installation of dependencies and Solar Core is finished you will need to select which network you wish to operate on. This can be achieved by pressing the up or down arrow keys and confirming your selection by pressing enter . Mainnet is the public network, Testnet is the development network for testing. ? Which network do you want to connect to? \u203a - Use arrow-keys. Return to submit. \u276f Mainnet Testnet After you have made your selection, you will need to confirm by pressing y and confirm again with enter \u2714 Which network do you want to connect to? \u203a Mainnet ? Are you sure? \u203a ( y/N ) The installation process will then proceed. Installing Solar Core for mainnet. This process may take a few minutes \u2826 Downloading operating system dependencies \u203a Installing operating system dependencies \u203a Downloading Core 4 .1.3 \u203a Downloading Core dependencies \u203a Installing Core dependencies \u203a Building Core 4 .1.3 \u203a Saving configuration \u203a Adding plugins \u203a Setting up database warning The install process might take a while, don\u2019t interrupt it, wait for it to finish. At this point, Solar Core has been successfully installed with its configuration options properly published. Installing Solar Core for mainnet. This process may take a few minutes \u2714 Downloading operating system dependencies \u2714 Installing operating system dependencies \u2714 Downloading Core 4 .1.3 \u2714 Downloading Core dependencies \u2714 Installing Core dependencies \u2714 Building Core 4 .1.3 \u2714 Saving configuration \u2714 Adding plugins \u2714 Setting up database Solar Core has been successfully installed! To get started, type solar To run a command as administrator ( user \"root\" ) , use \"sudo <command>\" . See \"man sudo_root\" for details.","title":"Step 5: Select the Core network"},{"location":"exchanges/node-installation/baremetal/#success","text":"Your installation is all set! \ud83c\udf89 That\u2019s it, you may now start your relay and view its logs using the following command: solar relay:start && pm2 logs \u2714 Starting solar-relay ... 1 | solar-relay | [ 2022 -11-06 22 :36:49.742 ] INFO: Connecting to database: solar_mainnet 1 | solar-relay | [ 2022 -11-06 22 :36:49.803 ] DEBUG: Database migration: Creating rounds table 1 | solar-relay | [ 2022 -11-06 22 :36:49.809 ] DEBUG: Database migration: Creating blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.816 ] DEBUG: Database migration: Creating transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.821 ] DEBUG: Database migration: Adding block_id index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.823 ] DEBUG: Database migration: Adding generator_public_key index to blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.825 ] DEBUG: Database migration: Adding timestamp index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.827 ] DEBUG: Database migration: Adding sender_public_key index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.829 ] DEBUG: Database migration: Adding recipient_id index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.832 ] DEBUG: Database migration: Adding block_id constraint to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.834 ] DEBUG: Database migration: Dropping id from rounds table 1 | solar-relay | [ 2022 -11-06 22 :36:49.836 ] DEBUG: Database migration: Adding chained_blocks constraint to blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.838 ] DEBUG: Database migration: Adding type_group to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.839 ] DEBUG: Database migration: Adding nonce to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.843 ] DEBUG: Database migration: Adding nonce trigger to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.845 ] DEBUG: Database migration: Adding asset to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.846 ] DEBUG: Database migration: Renaming and converting vendor_field_hex to vendor_field in transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.851 ] DEBUG: Database migration: Adding type index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.853 ] DEBUG: Database migration: Adding type_group index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.855 ] DEBUG: Database migration: Adding indexes to blocks and transactions tables 1 | solar-relay | [ 2022 -11-06 22 :36:49.880 ] DEBUG: Database migration: Adding block_height to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.885 ] DEBUG: Database migration: Creating wallets table 1 | solar-relay | [ 2022 -11-06 22 :36:49.889 ] DEBUG: Database migration: Adding payments asset index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.890 ] DEBUG: Database migration: Configuring autovacuum on all tables 1 | solar-relay | [ 2022 -11-06 22 :36:49.891 ] DEBUG: Database migration: Adding generator_public_key index to blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.893 ] DEBUG: Database migration: Adding burned_fee to blocks and transactions tables 1 | solar-relay | [ 2022 -11-06 22 :36:49.898 ] DEBUG: Database migration: Adding dev_fund to blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.901 ] DEBUG: Database migration: Disabling fastupdate on indexes in transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.902 ] DEBUG: Database migration: Renaming serialized to serialised in transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.903 ] DEBUG: Database migration: Renaming payments asset to transfers in transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.905 ] DEBUG: Database migration: Setting empty recipient_id to null in transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.906 ] DEBUG: Database migration: Setting zero amount to null in transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.907 ] DEBUG: Database migration: Renaming vendor_field to memo in transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.908 ] DEBUG: Database migration: Adding username to blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.911 ] DEBUG: Database migration: Creating missed_blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.913 ] DEBUG: Database migration: Adding sender_id to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.915 ] DEBUG: Database migration: Adding id index with operator class to blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.917 ] DEBUG: Database migration: Adding id index with operator class to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.918 ] DEBUG: Database migration: Renaming dev_fund to donations in blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.921 ] DEBUG: Database migration: Adding timestamp, username index to blocks table 1 | solar-relay | [ 2022 -11-06 22 :36:49.923 ] DEBUG: Database migration: Adding type, type_group index to transactions table 1 | solar-relay | [ 2022 -11-06 22 :36:49.926 ] DEBUG: Updating database configuration \ud83d\udcda 1 | solar-relay | [ 2022 -11-06 22 :36:49.928 ] DEBUG: Connection established 1 | solar-relay | [ 2022 -11-06 22 :36:49.938 ] INFO: Loaded SXP Swap Plugin 1 | solar-relay | [ 2022 -11-06 22 :36:50.192 ] WARNING: No block found in database \ud83d\ude2f 1 | solar-relay | [ 2022 -11-06 22 :36:50.236 ] NOTICE: Milestone change 1 | solar-relay | [ 2022 -11-06 22 :36:50.303 ] INFO: P2P Server started at http://suitable-wagtail:6001 1 | solar-relay | [ 2022 -11-06 22 :36:50.304 ] INFO: Starting Blockchain Manager \u26d3\ufe0f 1 | solar-relay | [ 2022 -11-06 22 :36:50.309 ] DEBUG: event 'START' : \"uninitialised\" -> \"initialise\" -> actions: [ initialise ] 1 | solar-relay | [ 2022 -11-06 22 :36:50.313 ] INFO: Last block in database: 1 1 | solar-relay | [ 2022 -11-06 22 :36:50.314 ] INFO: No saved states exist so a fresh state will now be generated \u203c\ufe0f 1 | solar-relay | [ 2022 -11-06 22 :36:50.314 ] INFO: Verifying database integrity \u23f3 1 | solar-relay | [ 2022 -11-06 22 :36:50.345 ] INFO: Verified database integrity \ud83d\ude38 1 | solar-relay | [ 2022 -11-06 22 :36:50.350 ] INFO: State Generation - Step 1 of 16 : LegacyTransfer 1 | solar-relay | [ 2022 -11-06 22 :36:50.359 ] INFO: State Generation - Step 2 of 16 : SecondSignature 1 | solar-relay | [ 2022 -11-06 22 :36:50.361 ] INFO: State Generation - Step 3 of 16 : DelegateRegistration 1 | solar-relay | [ 2022 -11-06 22 :36:50.374 ] INFO: State Generation - Step 4 of 16 : LegacyVote 1 | solar-relay | [ 2022 -11-06 22 :36:50.384 ] INFO: State Generation - Step 5 of 16 : MultiSignature 1 | solar-relay | [ 2022 -11-06 22 :36:50.391 ] INFO: State Generation - Step 6 of 16 : Ipfs 1 | solar-relay | [ 2022 -11-06 22 :36:50.393 ] INFO: State Generation - Step 7 of 16 : Transfer 1 | solar-relay | [ 2022 -11-06 22 :36:50.396 ] INFO: State Generation - Step 8 of 16 : DelegateResignation 1 | solar-relay | [ 2022 -11-06 22 :36:50.397 ] INFO: State Generation - Step 9 of 16 : HtlcLock 1 | solar-relay | [ 2022 -11-06 22 :36:50.401 ] INFO: State Generation - Step 10 of 16 : HtlcClaim 1 | solar-relay | [ 2022 -11-06 22 :36:50.404 ] INFO: State Generation - Step 11 of 16 : HtlcRefund 1 | solar-relay | [ 2022 -11-06 22 :36:50.407 ] INFO: State Generation - Step 12 of 16 : Burn 1 | solar-relay | [ 2022 -11-06 22 :36:50.409 ] INFO: State Generation - Step 13 of 16 : Vote 1 | solar-relay | [ 2022 -11-06 22 :36:50.410 ] INFO: State Generation - Step 14 of 16 : Fees & Nonces 1 | solar-relay | [ 2022 -11-06 22 :36:50.412 ] INFO: State Generation - Step 15 of 16 : Block Rewards 1 | solar-relay | [ 2022 -11-06 22 :36:50.414 ] INFO: State Generation - Step 16 of 16 : Vote Balances & Delegate Ranking 1 | solar-relay | [ 2022 -11-06 22 :36:50.418 ] INFO: Number of registered delegates: 53 1 | solar-relay | [ 2022 -11-06 22 :36:50.420 ] INFO: Calculating productivity data \ud83e\uddee 1 | solar-relay | [ 2022 -11-06 22 :36:50.440 ] DEBUG: Loaded 53 active delegates 1 | solar-relay | [ 2022 -11-06 22 :36:50.446 ] INFO: Starting Round 1 \ud83d\udd4a\ufe0f 1 | solar-relay | [ 2022 -11-06 22 :36:50.448 ] DEBUG: Loaded 53 active delegates 1 | solar-relay | [ 2022 -11-06 22 :36:50.449 ] INFO: Saving round 1 1 | solar-relay | [ 2022 -11-06 22 :36:50.655 ] INFO: Your network connectivity has been verified by 8 .8.4.4 \u2705 ... 1 | solar-re | [ 2022 -11-06 22 :40:46.370 ] DEBUG: Delegate bfx is allowed to forge block 76 ,805 \ud83d\udc4d 1 | solar-re | [ 2022 -11-06 22 :40:46.371 ] DEBUG: Delegate sxp is allowed to forge block 76 ,807 \ud83d\udc4d 1 | solar-re | [ 2022 -11-06 22 :40:46.372 ] DEBUG: Delegate sl33p is allowed to forge block 76 ,809 \ud83d\udc4d 1 | solar-re | [ 2022 -11-06 22 :40:46.373 ] DEBUG: Delegate advin is allowed to forge block 76 ,816 \ud83d\udc4d 1 | solar-re | [ 2022 -11-06 22 :40:46.383 ] DEBUG: Delegate cactus1549 is allowed to forge block 76 ,819 \ud83d\udc4d ... info Synchronisation of the blockchain can take some time. Once synchronised, the `allowed to forge block ...` messages will be logged every ~8 seconds \u2014 as opposed to milliseconds apart shown during sync. A single round consists of 53 delegates, each forging a single block.","title":"Success"},{"location":"exchanges/node-installation/requirements/","text":"Hardware Requirements \u00b6 A Relay Node is a full node in the Solar network; it maintains a complete copy of the ledger (blockchain). These nodes serve as Public API endpoint, use an internal service discovery mechanism to locate other nodes and keep each other in sync. Requirements \u00b6 Supported NodeJS Version 18 Supported OS Release Ubuntu >= 20.x Debian >= 10.x Ubuntu < = 18.x and Debian < = 9 are no longer supported Relay Requirements Recommended Minimum CPUs 4 2 RAM 8GB 4GB HDD 100GB - 120GB 80GB SXP Nodes execute many query intensive operations. The most cost-effective approach for running a high-performance node is choosing SSD over HDD. Increasing the total RAM improves cache performance. Configuration Requirements \u00b6 Stable internet connection Access to multiple open ports (actual ports may be configured) Service Port Required Enabled by default Documentation P2P 6001 \u2705 \u2705 reference Public API 6003 \u274c \u2705 reference Webhooks 6004 \u274c \u274c reference","title":"Requirements"},{"location":"exchanges/node-installation/requirements/#hardware-requirements","text":"A Relay Node is a full node in the Solar network; it maintains a complete copy of the ledger (blockchain). These nodes serve as Public API endpoint, use an internal service discovery mechanism to locate other nodes and keep each other in sync.","title":"Hardware Requirements"},{"location":"exchanges/node-installation/requirements/#requirements","text":"Supported NodeJS Version 18 Supported OS Release Ubuntu >= 20.x Debian >= 10.x Ubuntu < = 18.x and Debian < = 9 are no longer supported Relay Requirements Recommended Minimum CPUs 4 2 RAM 8GB 4GB HDD 100GB - 120GB 80GB SXP Nodes execute many query intensive operations. The most cost-effective approach for running a high-performance node is choosing SSD over HDD. Increasing the total RAM improves cache performance.","title":"Requirements"},{"location":"exchanges/node-installation/requirements/#configuration-requirements","text":"Stable internet connection Access to multiple open ports (actual ports may be configured) Service Port Required Enabled by default Documentation P2P 6001 \u2705 \u2705 reference Public API 6003 \u274c \u2705 reference Webhooks 6004 \u274c \u274c reference","title":"Configuration Requirements"},{"location":"project/intro/","text":"Solar \u00b6 1. What is Solar? \u00b6 A decentralized community-driven blockchain project. Solar is focused on creating an ecosystem with true governance. An ecosystem with open-source developers and community involvement. 1.2 Project Mission \u00b6 Solar is a blockchain with its own native SXP coin. The SXP blockchain offers a wide variety of features and tools that allows us to level with enterprise-grade applications. 1.3 Project Key Highlights \u00b6 Community-focused Competing with top tier crypto projects Open-source tools with many use-cases Scalable and secure using the latest blockchain technology Deflationary and inflationary at the same time 2. Solar products and technical infrastructure \u00b6 2.1 Existing products \u00b6 Solar Wallet The main software to interact directly with the SXP blockchain is by using the so-called Solar wallets. The initial Solar wallets are forked from the ARK repositories and it offers basic functions to send and receive SXP coins and to vote for delegates on the SXP blockchain. New desktop, mobile, and browser wallets are currently being developed to interact with all the features that the SXP blockchain has to offer, such as creating tokens, interacting with the metaverse, tools to monitor the blockchain and a lot more. 2.2 Technical Infrastructure \u00b6 Solar is powered by Solar Core. A safe and secure Layer-1 Blockchain Framework. Solar utilizes the Delegated Proof of Stake Consensus, also known as DPoS. The Blockchain with its own native coin named SXP is fast, modular, sustainable, efficient and fully decentralized without the known issues and vulnerabilities from traditional Proof of Work (PoW) blockchains. Issues and vulnerabilities such as being energy intensive or the risk of taking part in 51% attack vectors. The Blockchain Framework has been forked from ARK Core. Solar Core improved on the security of the Blockchain Framework by fully utilizing Schnorr for signatures. Solar Core entirely drops all support for ECDSA due to persistent signature malleability vectors. Solar Core also provides a more robust block production routine to minimise the likelihood of nodes missing blocks and therefore creating a more stable and operational blockchain. Security first. The blockchain framework is open-source and actively maintained on Github by dedicated Core developers. Anyone is able to create a PR or open an issue on our Github repositories to discuss or point at a potential vulnerability in our code. These issues will always have the highest priority and will be taken seriously to ensure that the framework will always be safe to use for our users and for anyone participating in the Solar DAO. The Solar Core has several enhancements such as the Side Ledger Protocol for token issuing with and without metadata and custom transaction types to allow \u201cburning\u201d and \u201cSolContract\u201d which allows the creation of Solidity Smart Contracts on the SXP Blockchain. The Solar Core also enables dynamic forging rewards based on the position of a delegate. 3. SXP Coin Overview & Use Cases \u00b6 SXP utilizes a Delegated Proof of Stake concensus, from which the forging rewards are distributed to delegates. The delegates are able to further distribute these rewards to their voters and keep a percentage as reward for the contribution to the network. 90% of the transaction fees are automatically burned on the network and 10% are rewarded to delegates that forge the block with the fees. Users may use the SXP coin in the following ways: Payments Create fungible and non-fungible tokens Use SXP in the Metaverse Staking Funding projects on the launchpad Voting in Governance Proposals 4. Team \u00b6 The Solar Project mainly consists of open-source developers from several top tier projects with Nayiem Willems as the project leader for 2022. At time of writing, the Solar team has 25 developers working on the initial start of the project. With the delegating consensus, Solar aims to bring more developers or contributors to the project and reward them with the forging rewards generated by the delegates. Solar will also additionally have a Community Fund to fund individual projects that are using the SXP blockchain. More information about the developers can be obtained from this Github Page .","title":"Solar"},{"location":"project/intro/#solar","text":"","title":"Solar"},{"location":"project/intro/#1-what-is-solar","text":"A decentralized community-driven blockchain project. Solar is focused on creating an ecosystem with true governance. An ecosystem with open-source developers and community involvement.","title":"1. What is Solar?"},{"location":"project/intro/#12-project-mission","text":"Solar is a blockchain with its own native SXP coin. The SXP blockchain offers a wide variety of features and tools that allows us to level with enterprise-grade applications.","title":"1.2 Project Mission"},{"location":"project/intro/#13-project-key-highlights","text":"Community-focused Competing with top tier crypto projects Open-source tools with many use-cases Scalable and secure using the latest blockchain technology Deflationary and inflationary at the same time","title":"1.3 Project Key Highlights"},{"location":"project/intro/#2-solar-products-and-technical-infrastructure","text":"","title":"2. Solar products and technical infrastructure"},{"location":"project/intro/#21-existing-products","text":"Solar Wallet The main software to interact directly with the SXP blockchain is by using the so-called Solar wallets. The initial Solar wallets are forked from the ARK repositories and it offers basic functions to send and receive SXP coins and to vote for delegates on the SXP blockchain. New desktop, mobile, and browser wallets are currently being developed to interact with all the features that the SXP blockchain has to offer, such as creating tokens, interacting with the metaverse, tools to monitor the blockchain and a lot more.","title":"2.1 Existing products"},{"location":"project/intro/#22-technical-infrastructure","text":"Solar is powered by Solar Core. A safe and secure Layer-1 Blockchain Framework. Solar utilizes the Delegated Proof of Stake Consensus, also known as DPoS. The Blockchain with its own native coin named SXP is fast, modular, sustainable, efficient and fully decentralized without the known issues and vulnerabilities from traditional Proof of Work (PoW) blockchains. Issues and vulnerabilities such as being energy intensive or the risk of taking part in 51% attack vectors. The Blockchain Framework has been forked from ARK Core. Solar Core improved on the security of the Blockchain Framework by fully utilizing Schnorr for signatures. Solar Core entirely drops all support for ECDSA due to persistent signature malleability vectors. Solar Core also provides a more robust block production routine to minimise the likelihood of nodes missing blocks and therefore creating a more stable and operational blockchain. Security first. The blockchain framework is open-source and actively maintained on Github by dedicated Core developers. Anyone is able to create a PR or open an issue on our Github repositories to discuss or point at a potential vulnerability in our code. These issues will always have the highest priority and will be taken seriously to ensure that the framework will always be safe to use for our users and for anyone participating in the Solar DAO. The Solar Core has several enhancements such as the Side Ledger Protocol for token issuing with and without metadata and custom transaction types to allow \u201cburning\u201d and \u201cSolContract\u201d which allows the creation of Solidity Smart Contracts on the SXP Blockchain. The Solar Core also enables dynamic forging rewards based on the position of a delegate.","title":"2.2 Technical Infrastructure"},{"location":"project/intro/#3-sxp-coin-overview-use-cases","text":"SXP utilizes a Delegated Proof of Stake concensus, from which the forging rewards are distributed to delegates. The delegates are able to further distribute these rewards to their voters and keep a percentage as reward for the contribution to the network. 90% of the transaction fees are automatically burned on the network and 10% are rewarded to delegates that forge the block with the fees. Users may use the SXP coin in the following ways: Payments Create fungible and non-fungible tokens Use SXP in the Metaverse Staking Funding projects on the launchpad Voting in Governance Proposals","title":"3. SXP Coin Overview &amp; Use Cases"},{"location":"project/intro/#4-team","text":"The Solar Project mainly consists of open-source developers from several top tier projects with Nayiem Willems as the project leader for 2022. At time of writing, the Solar team has 25 developers working on the initial start of the project. With the delegating consensus, Solar aims to bring more developers or contributors to the project and reward them with the forging rewards generated by the delegates. Solar will also additionally have a Community Fund to fund individual projects that are using the SXP blockchain. More information about the developers can be obtained from this Github Page .","title":"4. Team"},{"location":"project/whitepaper/","text":"Initial Whitepaper by Solar (February 2022) \u00b6 The following whitepaper is referred to goals and mission statements made by Solar. Click on the link below to view or download the whitepaper. Please keep in mind that the Whitepaper will be updated with more detailed information upon mainnet release. English Whitepaper February 2022 Korean Whitepaper February 2022 Turkish Whitepaper February 2022 Vietnamese Whitepaper February 2022","title":"Whitepaper"},{"location":"project/whitepaper/#initial-whitepaper-by-solar-february-2022","text":"The following whitepaper is referred to goals and mission statements made by Solar. Click on the link below to view or download the whitepaper. Please keep in mind that the Whitepaper will be updated with more detailed information upon mainnet release. English Whitepaper February 2022 Korean Whitepaper February 2022 Turkish Whitepaper February 2022 Vietnamese Whitepaper February 2022","title":"Initial Whitepaper by Solar (February 2022)"},{"location":"sdk/documentation/","text":"Introduction \u00b6 Using the Solar SDKs, developers can build applications utilising the Solar blockchain. The SXP SDKs are split into two packages for each language: Client and Cryptography. Client SDKs - help developers fetch information from the SXP blockchain about its current state: which delegates are currently forging, what transactions are associated with a given wallet, and so on. Cryptography SDKs - assist developers in working with transactions: signing, serialising, deserialising, etc. If your application doesn't involve sending transactions, you can most likely build your application using the Client SDK alone. Otherwise, applications looking to leverage the full spectrum of SXP APIs should make use of both Client and Cryptography SDKs. Usage guides are included for each supported language, and examples of how to use these libraries can be found in the Examples section of each specific library. Supported Languages & Frameworks \u00b6 Crypto Client TypeScript TypeScript Python Python","title":"Introduction"},{"location":"sdk/documentation/#introduction","text":"Using the Solar SDKs, developers can build applications utilising the Solar blockchain. The SXP SDKs are split into two packages for each language: Client and Cryptography. Client SDKs - help developers fetch information from the SXP blockchain about its current state: which delegates are currently forging, what transactions are associated with a given wallet, and so on. Cryptography SDKs - assist developers in working with transactions: signing, serialising, deserialising, etc. If your application doesn't involve sending transactions, you can most likely build your application using the Client SDK alone. Otherwise, applications looking to leverage the full spectrum of SXP APIs should make use of both Client and Cryptography SDKs. Usage guides are included for each supported language, and examples of how to use these libraries can be found in the Examples section of each specific library.","title":"Introduction"},{"location":"sdk/documentation/#supported-languages-frameworks","text":"Crypto Client TypeScript TypeScript Python Python","title":"Supported Languages &amp; Frameworks"},{"location":"sdk/guidelines/client/","text":"Client Libraries \u00b6 info The following is a guide for implementing a new SXP Client SDK. It covers the required functionalities as well as guidelines for how clients should typically look and behave. These guidelines are to be strictly followed if you are implementing or modifying an API client for the Solar Network. Following these guidelines is required to provide a streamlined experience across different languages to make it easier for new developers to get started with developing a new package or modify an existing one without lowering the quality of the already existing implementation. Carefully read those guidelines and abide by them while developing an API client Required Functionality \u00b6 Connection \u00b6 Accept configuration for the base URI and API version. Optional: Allow to pass in a custom HTTP client. Connection Manager \u00b6 This can be omitted in languages which have no concept of objects and thus making it impossible to store connection objects. Connect Connect to the given connection. Disconnect Disconnect from the given connection. Connection Get a connection instance. GetDefaultConnection Get the default connection name. SetDefaultConnection Set the default connection name. GetConnections Return all of the created connections. Public API Support \u00b6 Blocks Delegates Node Peers Transactions Votes Wallets Things to Keep in Mind \u00b6 Do not assume what the developer is going to do with the output. If your programming language of choice allows you to return the raw response without any mapping, do so. If you work with a programming language like Go that is strict and requires you to provide a struct you should fully reflect the original API response in your struct. Do not incorporate any cryptography functionality. An example of this would be to have a createTransaction method that sends a signed transaction to the API and the method itself would create the signed transaction instead of expecting it as an argument. Do not integrate the P2P API as it is out of scope. In solar-node it is required to send your transactions to the P2P API because there is no Public API endpoint for doing this. With the introduction of solar-core and the revamped Public API, there is no longer the need to use the P2P API. Terminology & Phrasing \u00b6 If you need to use the SXP name, keep these 2 use-cases in mind. The first one is SXP which is used in financial contexts like 10 SXP . The second is SXP which used for everything else that is not talking about SXP , the financial unit. If you need to namespace something with a numerical value in it, write out the numerical value. An example would be App\\Versions\\One instead of App\\V1 ._ If you work with a language that provides standard interfaces for HTTP messaging, implement them to provide a standardised and compliant interface which allows other developers to inject dependencies. An example of this would be PSR-7 for PHP which allows developers to create HTTP clients that follow a standardised interface which allows switching implementations while knowing it will work. Implementation \u00b6 Depending on if you are working with an Object Oriented Programming Language or Functional Programming Language the tools at your disposal for how to implement the required functionality will differ. If you for example work with an OOP language you will be able to isolate functionality into Objects whereas you won't be able to do that with a Functional language but instead need to think of everything as Functions . There are already a few implementations of cryptography packages available, so take a look at them and decide which approach is the right one for your language. Object Oriented Programming \u00b6 https://github.com/solar-network/client https://github.com/solar-network/python-client","title":"Client"},{"location":"sdk/guidelines/client/#client-libraries","text":"info The following is a guide for implementing a new SXP Client SDK. It covers the required functionalities as well as guidelines for how clients should typically look and behave. These guidelines are to be strictly followed if you are implementing or modifying an API client for the Solar Network. Following these guidelines is required to provide a streamlined experience across different languages to make it easier for new developers to get started with developing a new package or modify an existing one without lowering the quality of the already existing implementation. Carefully read those guidelines and abide by them while developing an API client","title":"Client Libraries"},{"location":"sdk/guidelines/client/#required-functionality","text":"","title":"Required Functionality"},{"location":"sdk/guidelines/client/#connection","text":"Accept configuration for the base URI and API version. Optional: Allow to pass in a custom HTTP client.","title":"Connection"},{"location":"sdk/guidelines/client/#connection-manager","text":"This can be omitted in languages which have no concept of objects and thus making it impossible to store connection objects. Connect Connect to the given connection. Disconnect Disconnect from the given connection. Connection Get a connection instance. GetDefaultConnection Get the default connection name. SetDefaultConnection Set the default connection name. GetConnections Return all of the created connections.","title":"Connection Manager"},{"location":"sdk/guidelines/client/#public-api-support","text":"Blocks Delegates Node Peers Transactions Votes Wallets","title":"Public API Support"},{"location":"sdk/guidelines/client/#things-to-keep-in-mind","text":"Do not assume what the developer is going to do with the output. If your programming language of choice allows you to return the raw response without any mapping, do so. If you work with a programming language like Go that is strict and requires you to provide a struct you should fully reflect the original API response in your struct. Do not incorporate any cryptography functionality. An example of this would be to have a createTransaction method that sends a signed transaction to the API and the method itself would create the signed transaction instead of expecting it as an argument. Do not integrate the P2P API as it is out of scope. In solar-node it is required to send your transactions to the P2P API because there is no Public API endpoint for doing this. With the introduction of solar-core and the revamped Public API, there is no longer the need to use the P2P API.","title":"Things to Keep in Mind"},{"location":"sdk/guidelines/client/#terminology-phrasing","text":"If you need to use the SXP name, keep these 2 use-cases in mind. The first one is SXP which is used in financial contexts like 10 SXP . The second is SXP which used for everything else that is not talking about SXP , the financial unit. If you need to namespace something with a numerical value in it, write out the numerical value. An example would be App\\Versions\\One instead of App\\V1 ._ If you work with a language that provides standard interfaces for HTTP messaging, implement them to provide a standardised and compliant interface which allows other developers to inject dependencies. An example of this would be PSR-7 for PHP which allows developers to create HTTP clients that follow a standardised interface which allows switching implementations while knowing it will work.","title":"Terminology &amp; Phrasing"},{"location":"sdk/guidelines/client/#implementation","text":"Depending on if you are working with an Object Oriented Programming Language or Functional Programming Language the tools at your disposal for how to implement the required functionality will differ. If you for example work with an OOP language you will be able to isolate functionality into Objects whereas you won't be able to do that with a Functional language but instead need to think of everything as Functions . There are already a few implementations of cryptography packages available, so take a look at them and decide which approach is the right one for your language.","title":"Implementation"},{"location":"sdk/guidelines/client/#object-oriented-programming","text":"https://github.com/solar-network/client https://github.com/solar-network/python-client","title":"Object Oriented Programming"},{"location":"sdk/guidelines/crypto/","text":"Crypto Libraries \u00b6 info The following is a guide for implementing a new SXP Cryptography SDK. It covers the required functionalities as well as guidelines for how cryptography should typically look and behave. These guidelines are to be strictly followed if you are implementing or modifying a cryptography package for the Solar Network. Following these guidelines is required to provide a streamlined experience across different languages to make it easier for new developers to get started with developing a new package or modify an existing one without lowering the quality of the already existing implementation. Carefully read those guidelines and abide by them while developing a cryptography package. Required Functionality \u00b6 Transaction \u00b6 getId Compute the unique transaction ID. sign Sign the transaction using a passphrase. secondSign Sign the transaction using a second passphrase. verify Verify the transaction. secondVerify Verify the transaction using a second public key. parseSignatures Parse the signature, second signature, and multi signatures. serialize Serialize the object via AIP11. deserialize Deserialize the given hex string via AIP11. fromJson Map the JSON to a new transaction object. toBytes Turn the transaction into its v1 byte representation. toArray Turn the transaction into a standardized array. toJson Turn the transaction into a JSON string using the toArray data as the source. Message \u00b6 sign Create a signed message using the given message and passphrase. verify Verify the given message, public key and signature combination. toArray Turn the message into a standardized array. toJson Turn the message into a JSON string using the toArray data as the source. Private Key \u00b6 fromPassphrase Derive a private key from the given passphrase. fromHex Get a private key instance from a private key hex string. Public Key \u00b6 fromPassphrase Derive a public key from the given passphrase. fromHex Get a public key instance from a public key hex string. Address \u00b6 fromPassphrase Derive an address from the given passphrase. fromPublicKey Derive an address from the given public key. fromPrivateKey Derive an address from the given private key. validate Validate the given address against the given network. WIF \u00b6 fromPassphrase Derive a WIF from the given passphrase. Configuration \u00b6 getNetwork Get the default network used by all functions. setNetwork Set the default network used by all functions. getFee Get a default fee by type used by all functions. setFee Set a default fee by type used by all functions. Slot \u00b6 time Get the time elapsed since network start. epoch Get the timestamp of the network start. Networks (Mainnet, Testnet) \u00b6 epoch Get the epoch of the network. version Get the version of the network. nethash Get the nethash of the network. wif Get the wif prefix of the network. Things to Keep in Mind \u00b6 Do not assume what the developer is going to do with the output. If you are working with a buffer, return the buffer instead of a hex encoded value. Add optional helper methods to easily convert identities between binary and hex . An example of this would be to be able to do privateKey.toHex() instead of having to encode the private key bytes to hex manually. Do not add functionality outside of the required functionality. An example would be to add helper methods for very niche use-cases just because they seem like a nice-to-have. Add optional helper methods to derive identities from multiple sources easily. An example would be methods like AddressFromPassphrase , PublicKeyFromPassphrase or PublicKeyFromPrivateKey . Terminology & Phrasing \u00b6 If you need to use the SXP name, keep these 2 use-cases in mind. The first one is SXP which is used in financial contexts like 10 SXP . The second is SXP which used for everything else that is not talking about SXP , the financial unit. If you work with functions that require a secret , passphrase , or mnemonic name the variables passphrase and secondPassphrase . If you work with serialisation , be sure to use the serialisation variant with s to name methods and variables. If you work with deserialisation , be sure to use the deserialisation variant with s to name methods and variables. File & Directory Structure \u00b6 The structure outlined here should be followed as closely as possible. If you work with an Object Oriented Programming Language you should be able to implement this structure as is, small adjustments might be required for languages like Go as nested packages can get hacky. You can check https://github.com/Solar-network/core/tree/main/packages/crypto for an example of how this structure looks like when implemented and how it is reflected in the structure of tests. [src | lib | crypto] \u251c\u2500\u2500 Configuration \u2502 \u251c\u2500\u2500 Fee \u2502 \u2514\u2500\u2500 Network \u251c\u2500\u2500 Enums \u2502 \u251c\u2500\u2500 Fees \u2502 \u2514\u2500\u2500 Types \u251c\u2500\u2500 Identities \u2502 \u251c\u2500\u2500 Address \u2502 \u251c\u2500\u2500 PrivateKey \u2502 \u251c\u2500\u2500 PublicKey \u2502 \u2514\u2500\u2500 WIF \u251c\u2500\u2500 Networks \u2502 \u251c\u2500\u2500 Mainnet \u2502 \u2514\u2500\u2500 Testnet \u251c\u2500\u2500 Transactions \u2502 \u251c\u2500\u2500 Builder \u2502 \u2502 \u251c\u2500\u2500 DelegateRegistration \u2502 \u2502 \u251c\u2500\u2500 DelegateResignation \u2502 \u2502 \u251c\u2500\u2500 IPFS \u2502 \u2502 \u251c\u2500\u2500 MultiPayment \u2502 \u2502 \u251c\u2500\u2500 MultiSignatureRegistration \u2502 \u2502 \u251c\u2500\u2500 SecondSignatureRegistration \u2502 \u2502 \u251c\u2500\u2500 TimelockTransfer \u2502 \u2502 \u251c\u2500\u2500 Transfer \u2502 \u2502 \u2514\u2500\u2500 Vote \u2502 \u251c\u2500\u2500 Deserializer \u2502 \u251c\u2500\u2500 Deserializers \u2502 \u2502 \u251c\u2500\u2500 DelegateRegistration \u2502 \u2502 \u251c\u2500\u2500 DelegateResignation \u2502 \u2502 \u251c\u2500\u2500 IPFS \u2502 \u2502 \u251c\u2500\u2500 MultiPayment \u2502 \u2502 \u251c\u2500\u2500 MultiSignatureRegistration \u2502 \u2502 \u251c\u2500\u2500 SecondSignatureRegistration \u2502 \u2502 \u251c\u2500\u2500 TimelockTransfer \u2502 \u2502 \u251c\u2500\u2500 Transfer \u2502 \u2502 \u2514\u2500\u2500 Vote \u2502 \u251c\u2500\u2500 Serializer \u2502 \u251c\u2500\u2500 Serializers \u2502 \u2502 \u251c\u2500\u2500 DelegateRegistration \u2502 \u2502 \u251c\u2500\u2500 DelegateResignation \u2502 \u2502 \u251c\u2500\u2500 IPFS \u2502 \u2502 \u251c\u2500\u2500 MultiPayment \u2502 \u2502 \u251c\u2500\u2500 MultiSignatureRegistration \u2502 \u2502 \u251c\u2500\u2500 SecondSignatureRegistration \u2502 \u2502 \u251c\u2500\u2500 TimelockTransfer \u2502 \u2502 \u251c\u2500\u2500 Transfer \u2502 \u2502 \u2514\u2500\u2500 Vote \u2502 \u2514\u2500\u2500 Transaction \u2514\u2500\u2500 Utils \u251c\u2500\u2500 Message \u2514\u2500\u2500 Slot Implementation \u00b6 Depending on if you are working with an Object Oriented Programming Language or Functional Programming Language the tools at your disposal for how to implement the required functionality will differ. If you for example work with an OOP language you will be able to isolate functionality into Objects whereas you won't be able to do that with a Functional language but instead need to think of everything as Functions . There are already a few implementations of cryptography packages available, so take a look at them and decide which approach is the right one for your language. Object Oriented Programming \u00b6 https://github.com/Solar-network/core/tree/main/packages/crypto https://github.com/solar-network/python-crypto","title":"Crypto"},{"location":"sdk/guidelines/crypto/#crypto-libraries","text":"info The following is a guide for implementing a new SXP Cryptography SDK. It covers the required functionalities as well as guidelines for how cryptography should typically look and behave. These guidelines are to be strictly followed if you are implementing or modifying a cryptography package for the Solar Network. Following these guidelines is required to provide a streamlined experience across different languages to make it easier for new developers to get started with developing a new package or modify an existing one without lowering the quality of the already existing implementation. Carefully read those guidelines and abide by them while developing a cryptography package.","title":"Crypto Libraries"},{"location":"sdk/guidelines/crypto/#required-functionality","text":"","title":"Required Functionality"},{"location":"sdk/guidelines/crypto/#transaction","text":"getId Compute the unique transaction ID. sign Sign the transaction using a passphrase. secondSign Sign the transaction using a second passphrase. verify Verify the transaction. secondVerify Verify the transaction using a second public key. parseSignatures Parse the signature, second signature, and multi signatures. serialize Serialize the object via AIP11. deserialize Deserialize the given hex string via AIP11. fromJson Map the JSON to a new transaction object. toBytes Turn the transaction into its v1 byte representation. toArray Turn the transaction into a standardized array. toJson Turn the transaction into a JSON string using the toArray data as the source.","title":"Transaction"},{"location":"sdk/guidelines/crypto/#message","text":"sign Create a signed message using the given message and passphrase. verify Verify the given message, public key and signature combination. toArray Turn the message into a standardized array. toJson Turn the message into a JSON string using the toArray data as the source.","title":"Message"},{"location":"sdk/guidelines/crypto/#private-key","text":"fromPassphrase Derive a private key from the given passphrase. fromHex Get a private key instance from a private key hex string.","title":"Private Key"},{"location":"sdk/guidelines/crypto/#public-key","text":"fromPassphrase Derive a public key from the given passphrase. fromHex Get a public key instance from a public key hex string.","title":"Public Key"},{"location":"sdk/guidelines/crypto/#address","text":"fromPassphrase Derive an address from the given passphrase. fromPublicKey Derive an address from the given public key. fromPrivateKey Derive an address from the given private key. validate Validate the given address against the given network.","title":"Address"},{"location":"sdk/guidelines/crypto/#wif","text":"fromPassphrase Derive a WIF from the given passphrase.","title":"WIF"},{"location":"sdk/guidelines/crypto/#configuration","text":"getNetwork Get the default network used by all functions. setNetwork Set the default network used by all functions. getFee Get a default fee by type used by all functions. setFee Set a default fee by type used by all functions.","title":"Configuration"},{"location":"sdk/guidelines/crypto/#slot","text":"time Get the time elapsed since network start. epoch Get the timestamp of the network start.","title":"Slot"},{"location":"sdk/guidelines/crypto/#networks-mainnet-testnet","text":"epoch Get the epoch of the network. version Get the version of the network. nethash Get the nethash of the network. wif Get the wif prefix of the network.","title":"Networks (Mainnet, Testnet)"},{"location":"sdk/guidelines/crypto/#things-to-keep-in-mind","text":"Do not assume what the developer is going to do with the output. If you are working with a buffer, return the buffer instead of a hex encoded value. Add optional helper methods to easily convert identities between binary and hex . An example of this would be to be able to do privateKey.toHex() instead of having to encode the private key bytes to hex manually. Do not add functionality outside of the required functionality. An example would be to add helper methods for very niche use-cases just because they seem like a nice-to-have. Add optional helper methods to derive identities from multiple sources easily. An example would be methods like AddressFromPassphrase , PublicKeyFromPassphrase or PublicKeyFromPrivateKey .","title":"Things to Keep in Mind"},{"location":"sdk/guidelines/crypto/#terminology-phrasing","text":"If you need to use the SXP name, keep these 2 use-cases in mind. The first one is SXP which is used in financial contexts like 10 SXP . The second is SXP which used for everything else that is not talking about SXP , the financial unit. If you work with functions that require a secret , passphrase , or mnemonic name the variables passphrase and secondPassphrase . If you work with serialisation , be sure to use the serialisation variant with s to name methods and variables. If you work with deserialisation , be sure to use the deserialisation variant with s to name methods and variables.","title":"Terminology &amp; Phrasing"},{"location":"sdk/guidelines/crypto/#file-directory-structure","text":"The structure outlined here should be followed as closely as possible. If you work with an Object Oriented Programming Language you should be able to implement this structure as is, small adjustments might be required for languages like Go as nested packages can get hacky. You can check https://github.com/Solar-network/core/tree/main/packages/crypto for an example of how this structure looks like when implemented and how it is reflected in the structure of tests. [src | lib | crypto] \u251c\u2500\u2500 Configuration \u2502 \u251c\u2500\u2500 Fee \u2502 \u2514\u2500\u2500 Network \u251c\u2500\u2500 Enums \u2502 \u251c\u2500\u2500 Fees \u2502 \u2514\u2500\u2500 Types \u251c\u2500\u2500 Identities \u2502 \u251c\u2500\u2500 Address \u2502 \u251c\u2500\u2500 PrivateKey \u2502 \u251c\u2500\u2500 PublicKey \u2502 \u2514\u2500\u2500 WIF \u251c\u2500\u2500 Networks \u2502 \u251c\u2500\u2500 Mainnet \u2502 \u2514\u2500\u2500 Testnet \u251c\u2500\u2500 Transactions \u2502 \u251c\u2500\u2500 Builder \u2502 \u2502 \u251c\u2500\u2500 DelegateRegistration \u2502 \u2502 \u251c\u2500\u2500 DelegateResignation \u2502 \u2502 \u251c\u2500\u2500 IPFS \u2502 \u2502 \u251c\u2500\u2500 MultiPayment \u2502 \u2502 \u251c\u2500\u2500 MultiSignatureRegistration \u2502 \u2502 \u251c\u2500\u2500 SecondSignatureRegistration \u2502 \u2502 \u251c\u2500\u2500 TimelockTransfer \u2502 \u2502 \u251c\u2500\u2500 Transfer \u2502 \u2502 \u2514\u2500\u2500 Vote \u2502 \u251c\u2500\u2500 Deserializer \u2502 \u251c\u2500\u2500 Deserializers \u2502 \u2502 \u251c\u2500\u2500 DelegateRegistration \u2502 \u2502 \u251c\u2500\u2500 DelegateResignation \u2502 \u2502 \u251c\u2500\u2500 IPFS \u2502 \u2502 \u251c\u2500\u2500 MultiPayment \u2502 \u2502 \u251c\u2500\u2500 MultiSignatureRegistration \u2502 \u2502 \u251c\u2500\u2500 SecondSignatureRegistration \u2502 \u2502 \u251c\u2500\u2500 TimelockTransfer \u2502 \u2502 \u251c\u2500\u2500 Transfer \u2502 \u2502 \u2514\u2500\u2500 Vote \u2502 \u251c\u2500\u2500 Serializer \u2502 \u251c\u2500\u2500 Serializers \u2502 \u2502 \u251c\u2500\u2500 DelegateRegistration \u2502 \u2502 \u251c\u2500\u2500 DelegateResignation \u2502 \u2502 \u251c\u2500\u2500 IPFS \u2502 \u2502 \u251c\u2500\u2500 MultiPayment \u2502 \u2502 \u251c\u2500\u2500 MultiSignatureRegistration \u2502 \u2502 \u251c\u2500\u2500 SecondSignatureRegistration \u2502 \u2502 \u251c\u2500\u2500 TimelockTransfer \u2502 \u2502 \u251c\u2500\u2500 Transfer \u2502 \u2502 \u2514\u2500\u2500 Vote \u2502 \u2514\u2500\u2500 Transaction \u2514\u2500\u2500 Utils \u251c\u2500\u2500 Message \u2514\u2500\u2500 Slot","title":"File &amp; Directory Structure"},{"location":"sdk/guidelines/crypto/#implementation","text":"Depending on if you are working with an Object Oriented Programming Language or Functional Programming Language the tools at your disposal for how to implement the required functionality will differ. If you for example work with an OOP language you will be able to isolate functionality into Objects whereas you won't be able to do that with a Functional language but instead need to think of everything as Functions . There are already a few implementations of cryptography packages available, so take a look at them and decide which approach is the right one for your language.","title":"Implementation"},{"location":"sdk/guidelines/crypto/#object-oriented-programming","text":"https://github.com/Solar-network/core/tree/main/packages/crypto https://github.com/solar-network/python-crypto","title":"Object Oriented Programming"},{"location":"sdk/guidelines/documentation/","text":"Documentation \u00b6 This file describes a general overview that must be adhered to when writing documentation for any of the SDKs (both Crypto and Client). Following these guidelines is required to provide a streamlined experience across different languages to make it easier for developers to read up on the SDK usage in their language of choice. Carefully read those guidelines and abide by them while writing SDK documentation. Structure \u00b6 Each SDK contains as at a minimum the following three documentation files: getting-started.md , which contains all the information you need in order to work with the SDK. api-documentation.md , which contains an overview of all available functions in the SDK. examples.md , which contains actual code examples for scenario's that frequently occur. We'll explain the specifics of each file in more details in the following sections. Getting Started \u00b6 We want to make it easy for anyone to work with the SDKs. Therefore this document will detail all the steps necessary to use it in your project. These steps include listing requirements for the SDKs (in terms of what other dependencies you need to have), how to install the SDK on your system to use it and how to include or import it in a project. Note that this document should also include a section on how to start further development on the SDK, including cloning from GitHub, how to run the tests and everything else needed to properly setup a development environment. API Documentation \u00b6 The API documentation should only document the available functions in the SDK, the parameters they take and their return type. It should be accompanied by a guiding text on what the function does, but should not become a code example; save those for the actual example document. Examples \u00b6 This file is meant to show code examples on how to use the SDK. These examples should contain often-used use cases depending on the SDK type. For the Client SDK, this would for example show: How to fetch a list of blocks How to fetch all active delegates How to fetch information of a specific wallet ... For the Crypto SDK, you could give examples of: How to create a transaction with a builder How to serialise / deserialise transactions How to generate a private key / public key / address from a passphrase ... These examples are not set in stone yet and can be adjusted to what you deem fit. If an SDK has more functionality than the same SDK in another language, this would of course mean it could have additional examples. However, please keep an eye on the examples in other languages and make sure the language you work on has similar ones if the SDK contains that same functionality. That way the examples will be streamlined across different languages.","title":"Documentation"},{"location":"sdk/guidelines/documentation/#documentation","text":"This file describes a general overview that must be adhered to when writing documentation for any of the SDKs (both Crypto and Client). Following these guidelines is required to provide a streamlined experience across different languages to make it easier for developers to read up on the SDK usage in their language of choice. Carefully read those guidelines and abide by them while writing SDK documentation.","title":"Documentation"},{"location":"sdk/guidelines/documentation/#structure","text":"Each SDK contains as at a minimum the following three documentation files: getting-started.md , which contains all the information you need in order to work with the SDK. api-documentation.md , which contains an overview of all available functions in the SDK. examples.md , which contains actual code examples for scenario's that frequently occur. We'll explain the specifics of each file in more details in the following sections.","title":"Structure"},{"location":"sdk/guidelines/documentation/#getting-started","text":"We want to make it easy for anyone to work with the SDKs. Therefore this document will detail all the steps necessary to use it in your project. These steps include listing requirements for the SDKs (in terms of what other dependencies you need to have), how to install the SDK on your system to use it and how to include or import it in a project. Note that this document should also include a section on how to start further development on the SDK, including cloning from GitHub, how to run the tests and everything else needed to properly setup a development environment.","title":"Getting Started"},{"location":"sdk/guidelines/documentation/#api-documentation","text":"The API documentation should only document the available functions in the SDK, the parameters they take and their return type. It should be accompanied by a guiding text on what the function does, but should not become a code example; save those for the actual example document.","title":"API Documentation"},{"location":"sdk/guidelines/documentation/#examples","text":"This file is meant to show code examples on how to use the SDK. These examples should contain often-used use cases depending on the SDK type. For the Client SDK, this would for example show: How to fetch a list of blocks How to fetch all active delegates How to fetch information of a specific wallet ... For the Crypto SDK, you could give examples of: How to create a transaction with a builder How to serialise / deserialise transactions How to generate a private key / public key / address from a passphrase ... These examples are not set in stone yet and can be adjusted to what you deem fit. If an SDK has more functionality than the same SDK in another language, this would of course mean it could have additional examples. However, please keep an eye on the examples in other languages and make sure the language you work on has similar ones if the SDK contains that same functionality. That way the examples will be streamlined across different languages.","title":"Examples"},{"location":"sdk/python/complementary-examples/","text":"Complementary Examples \u00b6 Prerequisites \u00b6 Before we get started we need to make sure that all of the required dependencies are installed. These dependencies are the Solar Crypto SDK and Solar Client SDK. You can head on over to their documentations to read more about them but for now we are only concerned with installing them to get up and running. Open your project and execute the following commands to install both SDKs. Make sure that those complete without any errors. If you encounter any errors, please open an issue with as much information as you can provide so that our developers can have a look and get to the bottom of the issue. sudo apt update && sudo apt install python3-pip python3-dev python3-venv cd <PROJECT_DIR> python3 -m venv .venv . ./venv/bin/activate pip3 install wheel pip3 install git+https://github.com/Solar-network/python-client.git@master#egg = solar-client --upgrade pip3 install solar-crypto --upgrade Creating and Broadcasting a Transfer \u00b6 from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.transfer import Transfer # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://tapi.solar.org/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = Transfer () transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . add_transfer ( 1 , 'RECIPIENT_WALLET_ADDRESS_1' ) transaction . add_transfer ( 2 , 'RECIPIENT_WALLET_ADDRESS_2' ) transaction . set_memo ( \"Hello World\" ) #transaction.set_version(3) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse ) The transaction memo is optional and limited to a length of 255 characters. It can be a good idea to add memo to your transactions if you want to be able to easily track them in the future. Rest of the examples assume V3 transactions as default. You must set the version explicity using transaction.set_version(int) otherwise. Creating and Broadcasting a Legacy Transfer \u00b6 from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.legacy_transfer import LegacyTransfer # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://tapi.solar.org/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = LegacyTransfer ( recipientId = 'RECIPIENT_WALLET_ADDRESS' , amount = 200000000 , memo = \"Hello World\" ) transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse ) Creating and Broadcasting a Second Signature \u00b6 from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.second_signature_registration import SecondSignatureRegistration # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://tapi.solar.org/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = SecondSignatureRegistration ( 'this is a top secret second passphrase' ) transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse ) Creating and Broadcasting a Delegate Registration \u00b6 from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.delegate_registration import DelegateRegistration # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://tapi.solar.org/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = DelegateRegistration ( 'johndoe' ) transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse ) Creating and Broadcasting a Delegate Resignation \u00b6 from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.delegate_resignation import DelegateResignation # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://tapi.solar.org/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = DelegateResignation () transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse ) A delegate resignation has to be sent from the delegate wallet itself to verify its identity. Creating and Broadcasting a Vote (Solar Version >= 4.0.0) \u00b6 from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.vote import Vote # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://tapi.solar.org/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = Vote () transaction . set_votes ({ \"asterix\" : 34.9 , \"obelix\" : 35.1 , \"getafix\" : 30.0 }) # must tot up to 100.00 transaction . set_votes ([ \"+asterix\" , \"-obelix\" , \"+getafix\" ]) # will ignore obelix and distribute the wallet to asterix & getafix 50:50 transaction . set_votes ([ \"-obelix\" ]) # will ignore obelix and cancel vote transaction . set_votes ({}) #cancel vote transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse ) Creating and Broadcasting a Legacy Vote (Solar Version >= 3.3.0 & < 4.0.0) \u00b6 from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.legacy_vote import LegacyVote # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://tapi.solar.org/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = LegacyVote () transaction . set_votes ([ \"-obelix\" ]) # cancel vote transaction . set_votes ([ \"+asterix\" ]) # vote transaction . set_votes ([ \"-obelix\" , \"+asterix\" ]) # switch vote transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse ) Creating and Broadcasting a MultiSignature Registration \u00b6 from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.multi_signature_registration import MultiSignatureRegistration # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://tapi.solar.org/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = MultiSignatureRegistration () transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . set_sender_public_key ( 'SENDER_WALLET_PUBLIC_KEY' ) transaction . set_min ( 2 ) transaction . set_public_keys ([ 'participant_1_pk' , 'participant_2_pk' ]) transaction . add_participant ( 'participant_3_pk' ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse ) Creating and Broadcasting a IPFS \u00b6 from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.ipfs import IPFS # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://tapi.solar.org/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = IPFS ( 'QmYSK2JyM3RyDyB52caZCTKFR3HKniEcMnNJYdk8DQ6KKB' ) transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse ) Creating and Broadcasting a HTLC Lock \u00b6 from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP , HTLC_LOCK_EXPIRATION_TYPE from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.htlc_lock import HtlcLock from solar_crypto.utils.slot import get_time from hashlib import sha256 # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://tapi.solar.org/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Secret hash is sha256 of the sha256 hash of the original message secret = \"super secret code that must be unique and entirely random\" secret_code = sha256 ( secret . encode ()) . digest () secret_hash = sha256 ( secret_code ) . hexdigest () # Expiration value must be > lastBlock.data.timestamp + blocktime * activeDelegates expire_in = 600 # set to expire in 10 min. # Step 2: Create the transaction transaction = HtlcLock ( recipient_id = 'RECIPIENT_WALLET_ADDRESS' , amount = 200000000 , secret_hash = secret_hash , expiration_type = HTLC_LOCK_EXPIRATION_TYPE . EPOCH_TIMESTAMP . value , expiration_value = get_time () + expire_in ) transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse ) Creating and Broadcasting a HTLC Claim \u00b6 from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP , HashingType from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.htlc_claim import HtlcClaim import hashlib # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://tapi.solar.org/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Unlock secret is the sha256 hash of the original message secret = \"super secret code that must be unique and entirely random\" unlock_secret = hashlib . sha256 ( secret . encode ( 'utf-8' )) . hexdigest () # Step 2: Create the transaction transaction = HtlcClaim ( 'LOCK_TRANSACTION_ID' , unlock_secret , HashingType . SHA256 ) transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse ) The unlockSecret has to be a SHA256 hash of the plain text secret that you shared with the person that is allowed to claim the transaction. Creating and Broadcasting a HTLC Refund \u00b6 from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.htlc_refund import HtlcRefund # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://tapi.solar.org/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = HtlcRefund ( lock_transaction_id = 'LOCK_TRANSACTION_ID' ) transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse )","title":"Complementary Examples"},{"location":"sdk/python/complementary-examples/#complementary-examples","text":"","title":"Complementary Examples"},{"location":"sdk/python/complementary-examples/#prerequisites","text":"Before we get started we need to make sure that all of the required dependencies are installed. These dependencies are the Solar Crypto SDK and Solar Client SDK. You can head on over to their documentations to read more about them but for now we are only concerned with installing them to get up and running. Open your project and execute the following commands to install both SDKs. Make sure that those complete without any errors. If you encounter any errors, please open an issue with as much information as you can provide so that our developers can have a look and get to the bottom of the issue. sudo apt update && sudo apt install python3-pip python3-dev python3-venv cd <PROJECT_DIR> python3 -m venv .venv . ./venv/bin/activate pip3 install wheel pip3 install git+https://github.com/Solar-network/python-client.git@master#egg = solar-client --upgrade pip3 install solar-crypto --upgrade","title":"Prerequisites"},{"location":"sdk/python/complementary-examples/#creating-and-broadcasting-a-transfer","text":"from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.transfer import Transfer # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://tapi.solar.org/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = Transfer () transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . add_transfer ( 1 , 'RECIPIENT_WALLET_ADDRESS_1' ) transaction . add_transfer ( 2 , 'RECIPIENT_WALLET_ADDRESS_2' ) transaction . set_memo ( \"Hello World\" ) #transaction.set_version(3) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse ) The transaction memo is optional and limited to a length of 255 characters. It can be a good idea to add memo to your transactions if you want to be able to easily track them in the future. Rest of the examples assume V3 transactions as default. You must set the version explicity using transaction.set_version(int) otherwise.","title":"Creating and Broadcasting a Transfer"},{"location":"sdk/python/complementary-examples/#creating-and-broadcasting-a-legacy-transfer","text":"from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.legacy_transfer import LegacyTransfer # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://tapi.solar.org/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = LegacyTransfer ( recipientId = 'RECIPIENT_WALLET_ADDRESS' , amount = 200000000 , memo = \"Hello World\" ) transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse )","title":"Creating and Broadcasting a Legacy Transfer"},{"location":"sdk/python/complementary-examples/#creating-and-broadcasting-a-second-signature","text":"from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.second_signature_registration import SecondSignatureRegistration # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://tapi.solar.org/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = SecondSignatureRegistration ( 'this is a top secret second passphrase' ) transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse )","title":"Creating and Broadcasting a Second Signature"},{"location":"sdk/python/complementary-examples/#creating-and-broadcasting-a-delegate-registration","text":"from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.delegate_registration import DelegateRegistration # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://tapi.solar.org/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = DelegateRegistration ( 'johndoe' ) transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse )","title":"Creating and Broadcasting a Delegate Registration"},{"location":"sdk/python/complementary-examples/#creating-and-broadcasting-a-delegate-resignation","text":"from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.delegate_resignation import DelegateResignation # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://tapi.solar.org/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = DelegateResignation () transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse ) A delegate resignation has to be sent from the delegate wallet itself to verify its identity.","title":"Creating and Broadcasting a Delegate Resignation"},{"location":"sdk/python/complementary-examples/#creating-and-broadcasting-a-vote-solar-version-400","text":"from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.vote import Vote # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://tapi.solar.org/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = Vote () transaction . set_votes ({ \"asterix\" : 34.9 , \"obelix\" : 35.1 , \"getafix\" : 30.0 }) # must tot up to 100.00 transaction . set_votes ([ \"+asterix\" , \"-obelix\" , \"+getafix\" ]) # will ignore obelix and distribute the wallet to asterix & getafix 50:50 transaction . set_votes ([ \"-obelix\" ]) # will ignore obelix and cancel vote transaction . set_votes ({}) #cancel vote transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse )","title":"Creating and Broadcasting a Vote (Solar Version &gt;= 4.0.0)"},{"location":"sdk/python/complementary-examples/#creating-and-broadcasting-a-legacy-vote-solar-version-330-400","text":"from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.legacy_vote import LegacyVote # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://tapi.solar.org/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = LegacyVote () transaction . set_votes ([ \"-obelix\" ]) # cancel vote transaction . set_votes ([ \"+asterix\" ]) # vote transaction . set_votes ([ \"-obelix\" , \"+asterix\" ]) # switch vote transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse )","title":"Creating and Broadcasting a Legacy Vote (Solar Version &gt;= 3.3.0 &amp; &lt; 4.0.0)"},{"location":"sdk/python/complementary-examples/#creating-and-broadcasting-a-multisignature-registration","text":"from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.multi_signature_registration import MultiSignatureRegistration # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://tapi.solar.org/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = MultiSignatureRegistration () transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . set_sender_public_key ( 'SENDER_WALLET_PUBLIC_KEY' ) transaction . set_min ( 2 ) transaction . set_public_keys ([ 'participant_1_pk' , 'participant_2_pk' ]) transaction . add_participant ( 'participant_3_pk' ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse )","title":"Creating and Broadcasting a MultiSignature Registration"},{"location":"sdk/python/complementary-examples/#creating-and-broadcasting-a-ipfs","text":"from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.ipfs import IPFS # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://tapi.solar.org/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = IPFS ( 'QmYSK2JyM3RyDyB52caZCTKFR3HKniEcMnNJYdk8DQ6KKB' ) transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse )","title":"Creating and Broadcasting a IPFS"},{"location":"sdk/python/complementary-examples/#creating-and-broadcasting-a-htlc-lock","text":"from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP , HTLC_LOCK_EXPIRATION_TYPE from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.htlc_lock import HtlcLock from solar_crypto.utils.slot import get_time from hashlib import sha256 # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://tapi.solar.org/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Secret hash is sha256 of the sha256 hash of the original message secret = \"super secret code that must be unique and entirely random\" secret_code = sha256 ( secret . encode ()) . digest () secret_hash = sha256 ( secret_code ) . hexdigest () # Expiration value must be > lastBlock.data.timestamp + blocktime * activeDelegates expire_in = 600 # set to expire in 10 min. # Step 2: Create the transaction transaction = HtlcLock ( recipient_id = 'RECIPIENT_WALLET_ADDRESS' , amount = 200000000 , secret_hash = secret_hash , expiration_type = HTLC_LOCK_EXPIRATION_TYPE . EPOCH_TIMESTAMP . value , expiration_value = get_time () + expire_in ) transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse )","title":"Creating and Broadcasting a HTLC Lock"},{"location":"sdk/python/complementary-examples/#creating-and-broadcasting-a-htlc-claim","text":"from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP , HashingType from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.htlc_claim import HtlcClaim import hashlib # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://tapi.solar.org/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Unlock secret is the sha256 hash of the original message secret = \"super secret code that must be unique and entirely random\" unlock_secret = hashlib . sha256 ( secret . encode ( 'utf-8' )) . hexdigest () # Step 2: Create the transaction transaction = HtlcClaim ( 'LOCK_TRANSACTION_ID' , unlock_secret , HashingType . SHA256 ) transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse ) The unlockSecret has to be a SHA256 hash of the plain text secret that you shared with the person that is allowed to claim the transaction.","title":"Creating and Broadcasting a HTLC Claim"},{"location":"sdk/python/complementary-examples/#creating-and-broadcasting-a-htlc-refund","text":"from solar_client import SolarClient from solar_client.exceptions import SolarHTTPException from solar_crypto.constants import TRANSACTION_TYPE_GROUP from solar_crypto.configuration.network import set_network from solar_crypto.networks.testnet import Testnet from solar_crypto.transactions.builder.htlc_refund import HtlcRefund # Set your network set_network ( Testnet ) # Configure our API client client = SolarClient ( 'https://tapi.solar.org/api' ) # Step 1: Retrieve the incremental nonce of the sender wallet senderWallet = client . wallets . get ( 'SENDER_WALLET_ADDRESS' ) nonce = int ( senderWallet [ 'data' ][ 'nonce' ]) + 1 # Step 2: Create the transaction transaction = HtlcRefund ( lock_transaction_id = 'LOCK_TRANSACTION_ID' ) transaction . set_type_group ( TRANSACTION_TYPE_GROUP . CORE ) transaction . set_nonce ( nonce ) transaction . sign ( 'this is a top secret passphrase' ) # Step 3: Broadcast the transaction try : broadcastResponse = client . transactions . create ([ transaction . to_dict ()]) except SolarHTTPException as exception : print ( exception . response . json ()) # Step 4: Log the response print ( broadcastResponse )","title":"Creating and Broadcasting a HTLC Refund"},{"location":"sdk/python/installation/","text":"Installation \u00b6 Python can be downloaded here . For further information on how to install Python on your operating system : Windows guide Unix guide OSx guide On OSx you can also install Python through HomeBrew , which would also install pip along, to do so, you need to install HomeBrew and then run the following command : brew install python3 Install pip \u00b6 pip is the standard package manager for Python. It allows you to install and manage additional packages that are not part of the Python standard library. On Windows : Download get-pip.py Open your terminal ( powershell , cmd , ...) and navigate to the folder containing get-pip.py Run the following command : python get-pip.py Pip is now installed On Unix : Debian / Ubuntu : sudo apt install python3-pip CentOS / Rhel : sudo yum install epel-release sudo yum install python-pip Fedora : sudo dnf install python3 Arch Linux : sudo pacman -S python-pip openSUSE : sudo zypper install python3-pip On macOS : Download get-pip.py and then run it curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py python get-pip.py With Brew : brew install python3 You can verify that pip was installed properly by running the following command in your terminal : pip -V which should returns the version of the installed pip program.","title":"Installation"},{"location":"sdk/python/installation/#installation","text":"Python can be downloaded here . For further information on how to install Python on your operating system : Windows guide Unix guide OSx guide On OSx you can also install Python through HomeBrew , which would also install pip along, to do so, you need to install HomeBrew and then run the following command : brew install python3","title":"Installation"},{"location":"sdk/python/installation/#install-pip","text":"pip is the standard package manager for Python. It allows you to install and manage additional packages that are not part of the Python standard library. On Windows : Download get-pip.py Open your terminal ( powershell , cmd , ...) and navigate to the folder containing get-pip.py Run the following command : python get-pip.py Pip is now installed On Unix : Debian / Ubuntu : sudo apt install python3-pip CentOS / Rhel : sudo yum install epel-release sudo yum install python-pip Fedora : sudo dnf install python3 Arch Linux : sudo pacman -S python-pip openSUSE : sudo zypper install python3-pip On macOS : Download get-pip.py and then run it curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py python get-pip.py With Brew : brew install python3 You can verify that pip was installed properly by running the following command in your terminal : pip -V which should returns the version of the installed pip program.","title":"Install pip"},{"location":"sdk/python/client/api-documentation/","text":"API Documentation \u00b6 client.api.blocks.Blocks \u00b6 all() \u00b6 def all ( self , page = None , limit = 100 , ** kwargs ) List All Blocks. Parameters \u00b6 Type Name Required Description int page No Pagination int limit No Result limits any **kwargs No Query parameters Return Value \u00b6 <class 'dict'> get() \u00b6 def get ( self , block_id ) Retrieve a Block Parameters \u00b6 Type Name Required Description int block_id Yes Block ID Return Value \u00b6 <class 'dict'> transactions() \u00b6 def transactions ( self , block_id , page = None , limit = 100 ) List All Transactions of a Block Parameters \u00b6 Type Name Required Description str block_id Yes Block ID int page No Pagination int limit No Query parameters Return Value \u00b6 <class 'dict'> search() \u00b6 def search ( self , criteria , page = None , limit = 100 ) Search All Blocks Parameters \u00b6 Type Name Required Description dict criteria Yes Search parameters int page No Pagination int limit No Result limit Return Value \u00b6 <class 'dict'> client.api.delegates.Delegates \u00b6 all() \u00b6 def all ( self , page = None , limit = 100 , ** kwargs ) List All Delegates Parameters \u00b6 Type Name Required Description int page No Pagination int limit No Result limits any **kwargs No Query parameters Return Value \u00b6 <class 'dict'> get() \u00b6 def get ( self , delegate_id ) Retrieve a Delegate Parameters \u00b6 Type Name Required Description int delegate_id Yes Delegate identifier Return Value \u00b6 <class 'dict'> search() \u00b6 def search ( self , username , page = None , limit = 100 ) Search Delegates Parameters \u00b6 Type Name Required Description str username Yes Delegate username int page No Pagination int limit No Result limits Return Value \u00b6 <class 'dict'> blocks() \u00b6 def blocks ( self , delegate_id , page = None , limit = 100 ) List All Blocks of a Delegate Parameters \u00b6 Type Name Required Description str delegate_id Yes Delegate identifier int page No Pagination int limit No Result limits Return Value \u00b6 <class 'dict'> voters() \u00b6 def voters ( self , delegate_id , page = None , limit = 100 , ** kwargs ) List All Voters of a Delegate Parameters \u00b6 Type Name Required Description str delegate_id Yes Delegate identifier int page No Pagination int limit No Result limits any **kwargs No Query parameters Return Value \u00b6 <class 'dict'> client.api.node.Node \u00b6 configuration() \u00b6 def configuration ( self ) Retrieve the Configuration Return Value \u00b6 <class 'dict'> status() \u00b6 def status ( self ) Retrieve the Status Return Value \u00b6 <class 'dict'> syncing() \u00b6 def syncing ( self ) Retrieve the Syncing Status Return Value \u00b6 <class 'dict'> fees() \u00b6 def fees ( self , days = None ) Retrieve the Fees Parameters \u00b6 Type Name Required Description int days No ... Return Value \u00b6 <class 'dict'> client.api.peers.Peers \u00b6 all() \u00b6 def all ( self , os = None , status = None , port = None , version = None , order_by = None , page = None , limit = 100 ) List All Peers Parameters \u00b6 Type Name Required Description s str os No Operating System str status No Peer status int port No Peer port str version No Peer version str order_by No Order by int page No Pagination int limit No Result limit Return Value \u00b6 <class 'dict'> get() \u00b6 def get ( self , ip ) Retrieve a Peer Parameters \u00b6 Type Name Required Description str ip Yes IP address Return Value \u00b6 <class 'dict'> client.api.transactions.Transactions \u00b6 create() \u00b6 def create ( self , transactions ) Create a Transaction Parameters \u00b6 Type Name Required Description list transactions Yes Transaction to broadcast Return Value \u00b6 <class 'dict'> get() \u00b6 def get ( self , transaction_id ) Retrieve a Transaction Parameters \u00b6 Type Name Required Description str transaction_id Yes Transaction ID Return Value \u00b6 <class 'dict'> all() \u00b6 def all ( self , page = None , limit = 100 , ** kwargs ) List All Transactions Parameters \u00b6 Type Name Required Description int page No Pagination int limit No Result limit any **kwargs No Query parameters Return Value \u00b6 <class 'dict'> all_unconfirmed() \u00b6 def all_unconfirmed ( self , limit = 100 , offset = None , ** kwargs ) List All Unconfirmed Transactions Parameters \u00b6 Type Name Required Description int limit No Result limit int offset No Offset any **kwargs No Query parameters Return Value \u00b6 <class 'dict'> get_unconfirmed() \u00b6 def get_unconfirmed ( self , transaction_id ) Get Unconfirmed Transaction Parameters \u00b6 Type Name Required Description str transaction_id Yes Transaction ID Return Value \u00b6 <class 'dict'> search() \u00b6 def search ( self , criteria , page = None , limit = 100 ) Search Transactions Parameters \u00b6 Type Name Required Description dict criteria Yes Search parameters int page No Pagination int limit No Result limit Return Value \u00b6 <class 'dict'> types() \u00b6 def types ( self ) List Transaction Types Return Value \u00b6 <class 'dict'> fees() \u00b6 def fees ( self ) List Transaction Fees (Non-Dynamic) Return Value \u00b6 <class 'dict'> client.api.votes.Votes \u00b6 all() \u00b6 def all ( self , page = None , limit = 100 ) List All Votes Parameters \u00b6 Type Name Required Description s int page No Pagination int limit No Result limit Return Value \u00b6 <class 'dict'> get() \u00b6 def get ( self , vote_id ) Retrieve a Vote Parameters \u00b6 Type Name Required Description str vote_id Yes Vote IDs Return Value \u00b6 <class 'dict'> client.api.wallets.Wallets \u00b6 all() \u00b6 def all ( self , page = None , limit = 100 ) Retrieve All Wallets Parameters \u00b6 Type Name Required Description int page No Pagination int limit No Result limit Return Value \u00b6 <class 'dict'> get() \u00b6 def get ( self , wallet_id ) Retrieve a Wallet Parameters \u00b6 Type Name Required Description str wallet_id Yes Wallet identifier Return Value \u00b6 <class 'dict'> transactions() \u00b6 def transactions ( self , wallet_id , page = None , limit = 100 , ** kwargs ) List All Transactions of a Wallet Parameters \u00b6 Type Name Required Description str wallet_id Yes Wallet identifier int page No Pagination int limit No Result limit any **kwargs No Query parameters Return Value \u00b6 <class 'dict'> transactions_received() \u00b6 def transactions_received ( self , wallet_id , page = None , limit = 100 ) List All Received Transactions of a Wallet Parameters \u00b6 Type Name Required Description str wallet_id Yes Wallet identifier int page No Pagination int limit No Result limit Return Value \u00b6 <class 'dict'> transactions_sent() \u00b6 def transactions_sent ( self , wallet_id , page = None , limit = 100 ) List All Sent Transactions of a Wallet Parameters \u00b6 Type Name Required Description str wallet_id Yes Wallet identifier int page No Pagination int limit No Result limit Return Value \u00b6 <class 'dict'> votes() \u00b6 def votes ( self , wallet_id , page = None , limit = 100 ) List All Votes of a Wallet Parameters \u00b6 Type Name Required Description str wallet_id Yes Wallet identifier int page No Pagination int limit No Result limit Return Value \u00b6 <class 'dict'> top() \u00b6 def top ( self , page = None , limit = 100 ) List All Top Wallets Parameters \u00b6 Type Name Required Description int page No Pagination int limit No Result limit Return Value \u00b6 <class 'dict'> search() \u00b6 def search ( self , criteria , page = None , limit = 100 ) Search All Wallets Parameters \u00b6 Type Name Required Description dict criteria Yes Search parameters int page No Pagination int limit No Result limit Return Value \u00b6 <class 'dict'>","title":"API Documentation"},{"location":"sdk/python/client/api-documentation/#api-documentation","text":"","title":"API Documentation"},{"location":"sdk/python/client/api-documentation/#clientapiblocksblocks","text":"","title":"client.api.blocks.Blocks"},{"location":"sdk/python/client/api-documentation/#all","text":"def all ( self , page = None , limit = 100 , ** kwargs ) List All Blocks.","title":"all()"},{"location":"sdk/python/client/api-documentation/#parameters","text":"Type Name Required Description int page No Pagination int limit No Result limits any **kwargs No Query parameters","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#get","text":"def get ( self , block_id ) Retrieve a Block","title":"get()"},{"location":"sdk/python/client/api-documentation/#parameters_1","text":"Type Name Required Description int block_id Yes Block ID","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_1","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#transactions","text":"def transactions ( self , block_id , page = None , limit = 100 ) List All Transactions of a Block","title":"transactions()"},{"location":"sdk/python/client/api-documentation/#parameters_2","text":"Type Name Required Description str block_id Yes Block ID int page No Pagination int limit No Query parameters","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_2","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#search","text":"def search ( self , criteria , page = None , limit = 100 ) Search All Blocks","title":"search()"},{"location":"sdk/python/client/api-documentation/#parameters_3","text":"Type Name Required Description dict criteria Yes Search parameters int page No Pagination int limit No Result limit","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_3","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#clientapidelegatesdelegates","text":"","title":"client.api.delegates.Delegates"},{"location":"sdk/python/client/api-documentation/#all_1","text":"def all ( self , page = None , limit = 100 , ** kwargs ) List All Delegates","title":"all()"},{"location":"sdk/python/client/api-documentation/#parameters_4","text":"Type Name Required Description int page No Pagination int limit No Result limits any **kwargs No Query parameters","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_4","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#get_1","text":"def get ( self , delegate_id ) Retrieve a Delegate","title":"get()"},{"location":"sdk/python/client/api-documentation/#parameters_5","text":"Type Name Required Description int delegate_id Yes Delegate identifier","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_5","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#search_1","text":"def search ( self , username , page = None , limit = 100 ) Search Delegates","title":"search()"},{"location":"sdk/python/client/api-documentation/#parameters_6","text":"Type Name Required Description str username Yes Delegate username int page No Pagination int limit No Result limits","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_6","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#blocks","text":"def blocks ( self , delegate_id , page = None , limit = 100 ) List All Blocks of a Delegate","title":"blocks()"},{"location":"sdk/python/client/api-documentation/#parameters_7","text":"Type Name Required Description str delegate_id Yes Delegate identifier int page No Pagination int limit No Result limits","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_7","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#voters","text":"def voters ( self , delegate_id , page = None , limit = 100 , ** kwargs ) List All Voters of a Delegate","title":"voters()"},{"location":"sdk/python/client/api-documentation/#parameters_8","text":"Type Name Required Description str delegate_id Yes Delegate identifier int page No Pagination int limit No Result limits any **kwargs No Query parameters","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_8","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#clientapinodenode","text":"","title":"client.api.node.Node"},{"location":"sdk/python/client/api-documentation/#configuration","text":"def configuration ( self ) Retrieve the Configuration","title":"configuration()"},{"location":"sdk/python/client/api-documentation/#return-value_9","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#status","text":"def status ( self ) Retrieve the Status","title":"status()"},{"location":"sdk/python/client/api-documentation/#return-value_10","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#syncing","text":"def syncing ( self ) Retrieve the Syncing Status","title":"syncing()"},{"location":"sdk/python/client/api-documentation/#return-value_11","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#fees","text":"def fees ( self , days = None ) Retrieve the Fees","title":"fees()"},{"location":"sdk/python/client/api-documentation/#parameters_9","text":"Type Name Required Description int days No ...","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_12","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#clientapipeerspeers","text":"","title":"client.api.peers.Peers"},{"location":"sdk/python/client/api-documentation/#all_2","text":"def all ( self , os = None , status = None , port = None , version = None , order_by = None , page = None , limit = 100 ) List All Peers","title":"all()"},{"location":"sdk/python/client/api-documentation/#parameters_10","text":"Type Name Required Description s str os No Operating System str status No Peer status int port No Peer port str version No Peer version str order_by No Order by int page No Pagination int limit No Result limit","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_13","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#get_2","text":"def get ( self , ip ) Retrieve a Peer","title":"get()"},{"location":"sdk/python/client/api-documentation/#parameters_11","text":"Type Name Required Description str ip Yes IP address","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_14","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#clientapitransactionstransactions","text":"","title":"client.api.transactions.Transactions"},{"location":"sdk/python/client/api-documentation/#create","text":"def create ( self , transactions ) Create a Transaction","title":"create()"},{"location":"sdk/python/client/api-documentation/#parameters_12","text":"Type Name Required Description list transactions Yes Transaction to broadcast","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_15","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#get_3","text":"def get ( self , transaction_id ) Retrieve a Transaction","title":"get()"},{"location":"sdk/python/client/api-documentation/#parameters_13","text":"Type Name Required Description str transaction_id Yes Transaction ID","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_16","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#all_3","text":"def all ( self , page = None , limit = 100 , ** kwargs ) List All Transactions","title":"all()"},{"location":"sdk/python/client/api-documentation/#parameters_14","text":"Type Name Required Description int page No Pagination int limit No Result limit any **kwargs No Query parameters","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_17","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#all_unconfirmed","text":"def all_unconfirmed ( self , limit = 100 , offset = None , ** kwargs ) List All Unconfirmed Transactions","title":"all_unconfirmed()"},{"location":"sdk/python/client/api-documentation/#parameters_15","text":"Type Name Required Description int limit No Result limit int offset No Offset any **kwargs No Query parameters","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_18","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#get_unconfirmed","text":"def get_unconfirmed ( self , transaction_id ) Get Unconfirmed Transaction","title":"get_unconfirmed()"},{"location":"sdk/python/client/api-documentation/#parameters_16","text":"Type Name Required Description str transaction_id Yes Transaction ID","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_19","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#search_2","text":"def search ( self , criteria , page = None , limit = 100 ) Search Transactions","title":"search()"},{"location":"sdk/python/client/api-documentation/#parameters_17","text":"Type Name Required Description dict criteria Yes Search parameters int page No Pagination int limit No Result limit","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_20","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#types","text":"def types ( self ) List Transaction Types","title":"types()"},{"location":"sdk/python/client/api-documentation/#return-value_21","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#fees_1","text":"def fees ( self ) List Transaction Fees (Non-Dynamic)","title":"fees()"},{"location":"sdk/python/client/api-documentation/#return-value_22","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#clientapivotesvotes","text":"","title":"client.api.votes.Votes"},{"location":"sdk/python/client/api-documentation/#all_4","text":"def all ( self , page = None , limit = 100 ) List All Votes","title":"all()"},{"location":"sdk/python/client/api-documentation/#parameters_18","text":"Type Name Required Description s int page No Pagination int limit No Result limit","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_23","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#get_4","text":"def get ( self , vote_id ) Retrieve a Vote","title":"get()"},{"location":"sdk/python/client/api-documentation/#parameters_19","text":"Type Name Required Description str vote_id Yes Vote IDs","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_24","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#clientapiwalletswallets","text":"","title":"client.api.wallets.Wallets"},{"location":"sdk/python/client/api-documentation/#all_5","text":"def all ( self , page = None , limit = 100 ) Retrieve All Wallets","title":"all()"},{"location":"sdk/python/client/api-documentation/#parameters_20","text":"Type Name Required Description int page No Pagination int limit No Result limit","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_25","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#get_5","text":"def get ( self , wallet_id ) Retrieve a Wallet","title":"get()"},{"location":"sdk/python/client/api-documentation/#parameters_21","text":"Type Name Required Description str wallet_id Yes Wallet identifier","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_26","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#transactions_1","text":"def transactions ( self , wallet_id , page = None , limit = 100 , ** kwargs ) List All Transactions of a Wallet","title":"transactions()"},{"location":"sdk/python/client/api-documentation/#parameters_22","text":"Type Name Required Description str wallet_id Yes Wallet identifier int page No Pagination int limit No Result limit any **kwargs No Query parameters","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_27","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#transactions_received","text":"def transactions_received ( self , wallet_id , page = None , limit = 100 ) List All Received Transactions of a Wallet","title":"transactions_received()"},{"location":"sdk/python/client/api-documentation/#parameters_23","text":"Type Name Required Description str wallet_id Yes Wallet identifier int page No Pagination int limit No Result limit","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_28","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#transactions_sent","text":"def transactions_sent ( self , wallet_id , page = None , limit = 100 ) List All Sent Transactions of a Wallet","title":"transactions_sent()"},{"location":"sdk/python/client/api-documentation/#parameters_24","text":"Type Name Required Description str wallet_id Yes Wallet identifier int page No Pagination int limit No Result limit","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_29","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#votes","text":"def votes ( self , wallet_id , page = None , limit = 100 ) List All Votes of a Wallet","title":"votes()"},{"location":"sdk/python/client/api-documentation/#parameters_25","text":"Type Name Required Description str wallet_id Yes Wallet identifier int page No Pagination int limit No Result limit","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_30","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#top","text":"def top ( self , page = None , limit = 100 ) List All Top Wallets","title":"top()"},{"location":"sdk/python/client/api-documentation/#parameters_26","text":"Type Name Required Description int page No Pagination int limit No Result limit","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_31","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/api-documentation/#search_3","text":"def search ( self , criteria , page = None , limit = 100 ) Search All Wallets","title":"search()"},{"location":"sdk/python/client/api-documentation/#parameters_27","text":"Type Name Required Description dict criteria Yes Search parameters int page No Pagination int limit No Result limit","title":"Parameters"},{"location":"sdk/python/client/api-documentation/#return-value_32","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/client/examples/","text":"Examples \u00b6 Initialization \u00b6 from client import SolarClient client = SolarClient ( 'https://node.ip.address:port/api' ) Blocks \u00b6 This service API grants access to the blocks resource . A block is a signed set of transactions created by a delegate and permanently committed to the SXP blockchain. It is not possible to POST a block through the public API. Relay Nodes accept only blocks posted by a delegate at the correct time through the internal API. List All Blocks \u00b6 blocks = client . blocks . all () # With parameters blocks = client . blocks . all ( page = 5 , limit = 10 , { \"orderBy\" : \"height\" }) # Available extra_parameters : # orderBy, ... print ( blocks ) >>> { 'meta' : { 'count' : 10 , ... }} Retrieve a Block \u00b6 block = client . blocks . get ( 'validBlockId' ) print ( block ) >>> { 'data' : { 'id' : 'validBlockId' ... }} List All Transactions of a Block \u00b6 block_transactions = client . blocks . transactions ( 'validBlockId' ) # With parameters block_transactions = client . blocks . transactions ( 'validBlockId' , page = 5 , limit = 10 ) print ( block_transactions ) >>> { 'meta' : { 'count' : 10 , ... }} Search All Blocks \u00b6 searched_blocks = client . blocks . search ({ \"generatorPublicKey\" : \"validPublicKey\" }) # With parameters searched_blocks = client . blocks . search ({ \"generatorPublicKey\" : \"validPublicKey\" }, page = 5 , limit = 10 ) # Available keys : # generatorPublicKey, ... print ( searched_blocks ) >>> { 'meta' : { 'count' : 100 , ... }} Delegates \u00b6 The client SDK can be used to query the delegate resource . A delegate is a regular wallet that has broadcast a registration transaction, acquired a sufficient number of votes, and has a Relay Node configured to forge new blocks through a forger module. At any time only 51 delegates are active. They are cost-efficient miners running the SXP network. Voters are wallets which have broadcast a vote transaction on a delegate. A vote remains active until an un-vote transaction is sent (it does not have to be recast unless a wallet wishes to change from delegate). Voting for a delegate does not give the delegate access to the wallet nor does it lock the coins in it. List All Delegates \u00b6 delegates = client . delegates . all () # With parameters delegates = client . delegates . all ( page = 5 , limit = 20 , { \"orderBy\" : \"production\" ) # Available extra_parameters : # orderBy, ... print ( delegates ) >>> { 'meta' : { 'count' : 20 , ... }} Retrieve a Delegate \u00b6 delegate = client . delegates . get ( \"delegateName\" ) print ( delegate ) >>> { 'data' : { 'username' : 'delegateName' , ... }} Search Delegates \u00b6 searched_delegates = client . delegates . search ( \"delegateName\" ) # With parameters searched_delegates = client . delegates . search ( \"delegateName\" , page = 1 , limit = 5 ) print ( searched_delegates ) >>> { 'meta' : { 'count' : 1 , ... }} List All Blocks of a Delegate \u00b6 delegate_blocks = client . delegates . blocks ( \"delegateName\" ) # With parameters delegate_blocks = client . delegates . blocks ( \"delegateName\" , page = 1 , limit = 20 ) print ( delegate_blocks ) >>> { 'meta' : { 'count' : 20 , ... }} List All Voters of a Delegate \u00b6 delegate_voters = client . delegates . voters ( \"delegateName\" ) # With parameters delegate_voters = client . delegates . voters ( \"delegateName\" , page = 1 , limit = 10 ) print ( delegate_voters ) >>> { 'meta' : { 'count' : 10 , ... }} Node \u00b6 The SXP network consists of different anonymous nodes (servers), maintaining the public ledger, validating transactions and blocks and providing APIs. The node resource allows for querying the health and configurations of the node used by the instantiated client. Retrieve the Configuration \u00b6 configuration = client . node . configuration () print ( configuration ) >>> { 'data' : { 'nethash' : '6e84d08bd299ed97c212c886c98a57e36545c8f5d645ca7eeae63a8bd62d8988' , ... }} Retrieve the Status \u00b6 status = client . node . status () print ( status ) >>> { 'data' : { 'synced' : True , 'now' : 6897158 , 'blocksCount' : - 1 }} Retrieve the Syncing Status \u00b6 syncing_status = client . node . syncing () print ( syncing_status ) >>> { 'data' : { 'syncing' : False , 'blocks' : - 1 , 'height' : 6897160 , 'id' : '12905037940821862953' }} Retrieve the Node Fees \u00b6 fees = client . node . fees () print ( fees ) >>> { \"meta\" :{ \"days\" : 7 , ... }} Peers \u00b6 Each node is connected to a set of peers, which are Relay or Delegate Nodes as well. The peers resource provides access to all peers connected to our node. Peers have made their Public API available for use; however for mission-critical queries and transaction posting you should use a node which is under your control. We provide a guide to setting up a Relay Node here . List All Peers \u00b6 peers = client . peers . all () # With parameters peers = client . peers . all ( os = \"\" , status = \"\" , port = 6002 , version = \"\" , orderBy = \"latency\" , page = 1 , limit = 10 ) print ( peers ) >>> { 'meta' : { 'count' : 10 , ... }} Retrieve a Peer \u00b6 peer = client . peers . get ( \"peerIpAddress\" ) print ( peer ) >>> { 'data' : { 'count' : 20 , ... }} # Need to changes Transactions \u00b6 The heart of any blockchain is formed by its transactions; state-altering payloads signed by a wallet. Most likely you will be querying for transactions most often, using the transaction resource . A transaction is the only object which may be posted by a non-delegate. It requires a signature from a wallet containing a sufficient amount of SXP. Create a Transaction \u00b6 transaction = client . transactions . create ([ signed_transaction ]) print ( transaction ) >>> < class ' dict '> # Need to update Retrieve a Transaction \u00b6 transaction = client . transactions . get ( \"validTransactionId\" ) print ( transaction ) >>> < class ' dict '> # Need to update List All Transactions \u00b6 transactions = client . transactions . all () # With parameters transactions = client . transactions . all ( page = 1 , limit = 10 , { \"orderBy\" : \"amount\" }) # Available extra_parameters : # orderBy, ... >>> { 'meta' : { 'count' : 10 , ... }} List All Unconfirmed Transactions \u00b6 unconfirmed_transactions = client . transactions . all_unconfirmed () # With parameters unconfirmed_transactions = client . transactions . all_unconfirmed ( page = 1 , limit = 10 , { \"orderBy\" : \"amount\" }) # Available extra_parameters : # orderBy, ... print ( unconfirmed_transactions ) >>> { 'meta' : { 'count' : 10 , ... }} Get Unconfirmed Transaction \u00b6 unconfirmed_transaction = client . transactions . get_unconfirmed ( \"validTransactionId\" ) print ( unconfirmed_transaction ) >>> < class ' dict '> # Need to update Search Transactions \u00b6 transactions = client . transactions . search ({ \"senderId\" : \"validPublicKey\" }) transactions = client . transactions . search ({ \"senderId\" : \"validPublicKey\" }, page = 1 , limit = 10 ) # Available keys : # senderId, ... print ( transactions ) >>> { 'meta' : { 'count' : 10 , ... }} List Transaction Types \u00b6 types = client . transactions . types () print ( types ) >>> { \"data\" :{ ... }} List Transaction Fees (Non-Dynamic) \u00b6 fees = client . transactions . fees () >>> { \"data\" :{ ... }} Votes \u00b6 A vote is a transaction sub-type, where the asset field contains a votes object and the transaction.type is 3 . List All Votes \u00b6 votes = client . votes . all () # With parameters votes = client . votes . all ( page = 1 , limit = 10 ) print ( votes ) >>> { 'meta' : { 'count' : 10 , ... }} Retrieve a Vote \u00b6 vote = client . votes . get ( 'validVoteId' ) print ( vote ) >>> { 'data' : { ... }} Wallets \u00b6 The wallet resource provides access to: Wallets. Incoming and outgoing transactions per wallet. Each wallet's votes. Retrieve All Wallets \u00b6 wallets = client . wallets . all () # With parameters wallets = client . wallets . all ( page = 1 , limit = 10 ) print ( wallets ) >>> { 'meta' : { 'count' : 10 , ... }} Retrieve a Wallet \u00b6 wallet = client . wallets . get ( 'validWalletId' ) print ( wallet ) >>> { 'data' : { 'id' : 'validWalletId' ... }} List All Transactions of a Wallet \u00b6 wallet_transactions = client . wallets . transactions ( 'validWalletId' ) wallet_transactions = client . wallets . transactions ( 'validWalletId' , page = 1 , limit = 10 , { \"orderBy\" : \"amount\" }) # Available extra_parameters : # orderBy, ... print ( wallet_transactions ) >>> { 'meta' : { 'count' : 10 , ... }} List All Received Transactions of a Wallet \u00b6 received_transactions = client . wallets . transactions_received ( 'validWalletId' ) # With parameters received_transactions = client . wallets . transactions_received ( 'validWalletId' , page = 1 , limit = 10 , { \"orderBy\" : \"amount\" }) # Available extra_parameters : # orderBy, ... print ( received_transactions ) >>> { 'meta' : { 'count' : 10 , ... }} List All Sent Transactions of a Wallet \u00b6 sent_transactions = client . wallets . transactions_sent ( 'validWalletId' ) # With parameters sent_transactions = client . wallets . transactions_sent ( 'validWalletId' , page = 1 , limit = 10 , { \"orderBy\" : \"amount\" }) # Available extra_parameters : # orderBy, ... print ( sent_transactions ) >>> { 'meta' : { 'count' : 10 , ... }} List All Votes of a Wallet \u00b6 wallet_votes = client . wallets . votes ( 'validWalletId' ) # With parameters wallet_votes = client . wallets . votes ( 'validWalletId' , page = 1 , limit = 10 ) print ( wallet_votes ) >>> { 'meta' : { 'count' : 10 , ... }} List All Top Wallets \u00b6 top_wallets = client . wallets . top () # With parameters top_wallets = client . wallets . top ( page = 1 , limit = 10 ) print ( top_wallets ) >>> { 'meta' : { 'count' : 10 , ... }} Search All Wallets \u00b6 wallets = client . wallets . search ({ \"publicKey\" : \"validPublicKey\" }) # With parameters wallets = client . wallets . search ({ \"publicKey\" : \"validPublicKey\" }, page = 1 , limit = 10 ) # Available keys : # publicKey, ... print ( wallets ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"Examples"},{"location":"sdk/python/client/examples/#examples","text":"","title":"Examples"},{"location":"sdk/python/client/examples/#initialization","text":"from client import SolarClient client = SolarClient ( 'https://node.ip.address:port/api' )","title":"Initialization"},{"location":"sdk/python/client/examples/#blocks","text":"This service API grants access to the blocks resource . A block is a signed set of transactions created by a delegate and permanently committed to the SXP blockchain. It is not possible to POST a block through the public API. Relay Nodes accept only blocks posted by a delegate at the correct time through the internal API.","title":"Blocks"},{"location":"sdk/python/client/examples/#list-all-blocks","text":"blocks = client . blocks . all () # With parameters blocks = client . blocks . all ( page = 5 , limit = 10 , { \"orderBy\" : \"height\" }) # Available extra_parameters : # orderBy, ... print ( blocks ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"List All Blocks"},{"location":"sdk/python/client/examples/#retrieve-a-block","text":"block = client . blocks . get ( 'validBlockId' ) print ( block ) >>> { 'data' : { 'id' : 'validBlockId' ... }}","title":"Retrieve a Block"},{"location":"sdk/python/client/examples/#list-all-transactions-of-a-block","text":"block_transactions = client . blocks . transactions ( 'validBlockId' ) # With parameters block_transactions = client . blocks . transactions ( 'validBlockId' , page = 5 , limit = 10 ) print ( block_transactions ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"List All Transactions of a Block"},{"location":"sdk/python/client/examples/#search-all-blocks","text":"searched_blocks = client . blocks . search ({ \"generatorPublicKey\" : \"validPublicKey\" }) # With parameters searched_blocks = client . blocks . search ({ \"generatorPublicKey\" : \"validPublicKey\" }, page = 5 , limit = 10 ) # Available keys : # generatorPublicKey, ... print ( searched_blocks ) >>> { 'meta' : { 'count' : 100 , ... }}","title":"Search All Blocks"},{"location":"sdk/python/client/examples/#delegates","text":"The client SDK can be used to query the delegate resource . A delegate is a regular wallet that has broadcast a registration transaction, acquired a sufficient number of votes, and has a Relay Node configured to forge new blocks through a forger module. At any time only 51 delegates are active. They are cost-efficient miners running the SXP network. Voters are wallets which have broadcast a vote transaction on a delegate. A vote remains active until an un-vote transaction is sent (it does not have to be recast unless a wallet wishes to change from delegate). Voting for a delegate does not give the delegate access to the wallet nor does it lock the coins in it.","title":"Delegates"},{"location":"sdk/python/client/examples/#list-all-delegates","text":"delegates = client . delegates . all () # With parameters delegates = client . delegates . all ( page = 5 , limit = 20 , { \"orderBy\" : \"production\" ) # Available extra_parameters : # orderBy, ... print ( delegates ) >>> { 'meta' : { 'count' : 20 , ... }}","title":"List All Delegates"},{"location":"sdk/python/client/examples/#retrieve-a-delegate","text":"delegate = client . delegates . get ( \"delegateName\" ) print ( delegate ) >>> { 'data' : { 'username' : 'delegateName' , ... }}","title":"Retrieve a Delegate"},{"location":"sdk/python/client/examples/#search-delegates","text":"searched_delegates = client . delegates . search ( \"delegateName\" ) # With parameters searched_delegates = client . delegates . search ( \"delegateName\" , page = 1 , limit = 5 ) print ( searched_delegates ) >>> { 'meta' : { 'count' : 1 , ... }}","title":"Search Delegates"},{"location":"sdk/python/client/examples/#list-all-blocks-of-a-delegate","text":"delegate_blocks = client . delegates . blocks ( \"delegateName\" ) # With parameters delegate_blocks = client . delegates . blocks ( \"delegateName\" , page = 1 , limit = 20 ) print ( delegate_blocks ) >>> { 'meta' : { 'count' : 20 , ... }}","title":"List All Blocks of a Delegate"},{"location":"sdk/python/client/examples/#list-all-voters-of-a-delegate","text":"delegate_voters = client . delegates . voters ( \"delegateName\" ) # With parameters delegate_voters = client . delegates . voters ( \"delegateName\" , page = 1 , limit = 10 ) print ( delegate_voters ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"List All Voters of a Delegate"},{"location":"sdk/python/client/examples/#node","text":"The SXP network consists of different anonymous nodes (servers), maintaining the public ledger, validating transactions and blocks and providing APIs. The node resource allows for querying the health and configurations of the node used by the instantiated client.","title":"Node"},{"location":"sdk/python/client/examples/#retrieve-the-configuration","text":"configuration = client . node . configuration () print ( configuration ) >>> { 'data' : { 'nethash' : '6e84d08bd299ed97c212c886c98a57e36545c8f5d645ca7eeae63a8bd62d8988' , ... }}","title":"Retrieve the Configuration"},{"location":"sdk/python/client/examples/#retrieve-the-status","text":"status = client . node . status () print ( status ) >>> { 'data' : { 'synced' : True , 'now' : 6897158 , 'blocksCount' : - 1 }}","title":"Retrieve the Status"},{"location":"sdk/python/client/examples/#retrieve-the-syncing-status","text":"syncing_status = client . node . syncing () print ( syncing_status ) >>> { 'data' : { 'syncing' : False , 'blocks' : - 1 , 'height' : 6897160 , 'id' : '12905037940821862953' }}","title":"Retrieve the Syncing Status"},{"location":"sdk/python/client/examples/#retrieve-the-node-fees","text":"fees = client . node . fees () print ( fees ) >>> { \"meta\" :{ \"days\" : 7 , ... }}","title":"Retrieve the Node Fees"},{"location":"sdk/python/client/examples/#peers","text":"Each node is connected to a set of peers, which are Relay or Delegate Nodes as well. The peers resource provides access to all peers connected to our node. Peers have made their Public API available for use; however for mission-critical queries and transaction posting you should use a node which is under your control. We provide a guide to setting up a Relay Node here .","title":"Peers"},{"location":"sdk/python/client/examples/#list-all-peers","text":"peers = client . peers . all () # With parameters peers = client . peers . all ( os = \"\" , status = \"\" , port = 6002 , version = \"\" , orderBy = \"latency\" , page = 1 , limit = 10 ) print ( peers ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"List All Peers"},{"location":"sdk/python/client/examples/#retrieve-a-peer","text":"peer = client . peers . get ( \"peerIpAddress\" ) print ( peer ) >>> { 'data' : { 'count' : 20 , ... }} # Need to changes","title":"Retrieve a Peer"},{"location":"sdk/python/client/examples/#transactions","text":"The heart of any blockchain is formed by its transactions; state-altering payloads signed by a wallet. Most likely you will be querying for transactions most often, using the transaction resource . A transaction is the only object which may be posted by a non-delegate. It requires a signature from a wallet containing a sufficient amount of SXP.","title":"Transactions"},{"location":"sdk/python/client/examples/#create-a-transaction","text":"transaction = client . transactions . create ([ signed_transaction ]) print ( transaction ) >>> < class ' dict '> # Need to update","title":"Create a Transaction"},{"location":"sdk/python/client/examples/#retrieve-a-transaction","text":"transaction = client . transactions . get ( \"validTransactionId\" ) print ( transaction ) >>> < class ' dict '> # Need to update","title":"Retrieve a Transaction"},{"location":"sdk/python/client/examples/#list-all-transactions","text":"transactions = client . transactions . all () # With parameters transactions = client . transactions . all ( page = 1 , limit = 10 , { \"orderBy\" : \"amount\" }) # Available extra_parameters : # orderBy, ... >>> { 'meta' : { 'count' : 10 , ... }}","title":"List All Transactions"},{"location":"sdk/python/client/examples/#list-all-unconfirmed-transactions","text":"unconfirmed_transactions = client . transactions . all_unconfirmed () # With parameters unconfirmed_transactions = client . transactions . all_unconfirmed ( page = 1 , limit = 10 , { \"orderBy\" : \"amount\" }) # Available extra_parameters : # orderBy, ... print ( unconfirmed_transactions ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"List All Unconfirmed Transactions"},{"location":"sdk/python/client/examples/#get-unconfirmed-transaction","text":"unconfirmed_transaction = client . transactions . get_unconfirmed ( \"validTransactionId\" ) print ( unconfirmed_transaction ) >>> < class ' dict '> # Need to update","title":"Get Unconfirmed Transaction"},{"location":"sdk/python/client/examples/#search-transactions","text":"transactions = client . transactions . search ({ \"senderId\" : \"validPublicKey\" }) transactions = client . transactions . search ({ \"senderId\" : \"validPublicKey\" }, page = 1 , limit = 10 ) # Available keys : # senderId, ... print ( transactions ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"Search Transactions"},{"location":"sdk/python/client/examples/#list-transaction-types","text":"types = client . transactions . types () print ( types ) >>> { \"data\" :{ ... }}","title":"List Transaction Types"},{"location":"sdk/python/client/examples/#list-transaction-fees-non-dynamic","text":"fees = client . transactions . fees () >>> { \"data\" :{ ... }}","title":"List Transaction Fees (Non-Dynamic)"},{"location":"sdk/python/client/examples/#votes","text":"A vote is a transaction sub-type, where the asset field contains a votes object and the transaction.type is 3 .","title":"Votes"},{"location":"sdk/python/client/examples/#list-all-votes","text":"votes = client . votes . all () # With parameters votes = client . votes . all ( page = 1 , limit = 10 ) print ( votes ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"List All Votes"},{"location":"sdk/python/client/examples/#retrieve-a-vote","text":"vote = client . votes . get ( 'validVoteId' ) print ( vote ) >>> { 'data' : { ... }}","title":"Retrieve a Vote"},{"location":"sdk/python/client/examples/#wallets","text":"The wallet resource provides access to: Wallets. Incoming and outgoing transactions per wallet. Each wallet's votes.","title":"Wallets"},{"location":"sdk/python/client/examples/#retrieve-all-wallets","text":"wallets = client . wallets . all () # With parameters wallets = client . wallets . all ( page = 1 , limit = 10 ) print ( wallets ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"Retrieve All Wallets"},{"location":"sdk/python/client/examples/#retrieve-a-wallet","text":"wallet = client . wallets . get ( 'validWalletId' ) print ( wallet ) >>> { 'data' : { 'id' : 'validWalletId' ... }}","title":"Retrieve a Wallet"},{"location":"sdk/python/client/examples/#list-all-transactions-of-a-wallet","text":"wallet_transactions = client . wallets . transactions ( 'validWalletId' ) wallet_transactions = client . wallets . transactions ( 'validWalletId' , page = 1 , limit = 10 , { \"orderBy\" : \"amount\" }) # Available extra_parameters : # orderBy, ... print ( wallet_transactions ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"List All Transactions of a Wallet"},{"location":"sdk/python/client/examples/#list-all-received-transactions-of-a-wallet","text":"received_transactions = client . wallets . transactions_received ( 'validWalletId' ) # With parameters received_transactions = client . wallets . transactions_received ( 'validWalletId' , page = 1 , limit = 10 , { \"orderBy\" : \"amount\" }) # Available extra_parameters : # orderBy, ... print ( received_transactions ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"List All Received Transactions of a Wallet"},{"location":"sdk/python/client/examples/#list-all-sent-transactions-of-a-wallet","text":"sent_transactions = client . wallets . transactions_sent ( 'validWalletId' ) # With parameters sent_transactions = client . wallets . transactions_sent ( 'validWalletId' , page = 1 , limit = 10 , { \"orderBy\" : \"amount\" }) # Available extra_parameters : # orderBy, ... print ( sent_transactions ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"List All Sent Transactions of a Wallet"},{"location":"sdk/python/client/examples/#list-all-votes-of-a-wallet","text":"wallet_votes = client . wallets . votes ( 'validWalletId' ) # With parameters wallet_votes = client . wallets . votes ( 'validWalletId' , page = 1 , limit = 10 ) print ( wallet_votes ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"List All Votes of a Wallet"},{"location":"sdk/python/client/examples/#list-all-top-wallets","text":"top_wallets = client . wallets . top () # With parameters top_wallets = client . wallets . top ( page = 1 , limit = 10 ) print ( top_wallets ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"List All Top Wallets"},{"location":"sdk/python/client/examples/#search-all-wallets","text":"wallets = client . wallets . search ({ \"publicKey\" : \"validPublicKey\" }) # With parameters wallets = client . wallets . search ({ \"publicKey\" : \"validPublicKey\" }, page = 1 , limit = 10 ) # Available keys : # publicKey, ... print ( wallets ) >>> { 'meta' : { 'count' : 10 , ... }}","title":"Search All Wallets"},{"location":"sdk/python/client/getting-started/","text":"Python installation \u00b6 Python can be downloaded here . For further information on how to install Python on your operating system : Windows guide Unix guide OSx guide On OSx you can also install Python through HomeBrew , which would also install pip along, to do so, you need to install HomeBrew and then run the following command : brew install python3 pip \u00b6 pip is the standard package manager for Python. It allows you to install and manage additional packages that are not part of the Python standard library. Install pip \u00b6 On Windows \u00b6 Download get-pip.py Open your terminal ( powershell , cmd , ...) and navigate to the folder containing get-pip.py Run the following command : python get-pip.py Pip is now installed On Unix \u00b6 Debian / Ubuntu : sudo apt install python3-pip CentOS / Rhel : sudo yum install epel-release sudo yum install python-pip Fedora : sudo dnf install python3 Arch Linux : sudo pacman -S python-pip openSUSE : sudo zypper install python3-pip On macOS : Download get-pip.py and then run it curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py python get-pip.py With Brew : brew install python3 You can verify that pip was installed properly by running the following command in your terminal : pip -V which should returns the version of the installed pip program. Development \u00b6 Fork the package . Clone your forked repository. git clone https://github.com/<githubusername>/python-client Next, move into the fresh cloned directory. cd python-client The next step would be to create something like a virtual environment to ensure no name clashes occur. Create and enter the virtual environment # With virtualenv (on Unix and OSx) mkdir my-amazing-solar-project cd my-amazing-solar-project virtualenv virtualEnvName source venv/bin/activate # With virtualenv (on Windows) mkdir my-amazing-solar-project cd my-amazing-solar-project virtualenv virtualEnvName . \\v env \\S cripts \\a ctivate.bat Once inside the virtualenv, you can proceed to install the dependencies. These are listed inside the setup.py file. pip install \\ requests \\ backoff \\ flake8 \\ flake8-import-order \\ flake8-print \\ flake8-quotes \\ pytest \\ pytest-responses \\ pytest-mock \\ pytest-cov Dependencies are now installed, you can now run the tests to see if everything is running as it should. pytest","title":"Getting Started"},{"location":"sdk/python/client/getting-started/#python-installation","text":"Python can be downloaded here . For further information on how to install Python on your operating system : Windows guide Unix guide OSx guide On OSx you can also install Python through HomeBrew , which would also install pip along, to do so, you need to install HomeBrew and then run the following command : brew install python3","title":"Python installation"},{"location":"sdk/python/client/getting-started/#pip","text":"pip is the standard package manager for Python. It allows you to install and manage additional packages that are not part of the Python standard library.","title":"pip"},{"location":"sdk/python/client/getting-started/#install-pip","text":"","title":"Install pip"},{"location":"sdk/python/client/getting-started/#on-windows","text":"Download get-pip.py Open your terminal ( powershell , cmd , ...) and navigate to the folder containing get-pip.py Run the following command : python get-pip.py Pip is now installed","title":"On Windows"},{"location":"sdk/python/client/getting-started/#on-unix","text":"Debian / Ubuntu : sudo apt install python3-pip CentOS / Rhel : sudo yum install epel-release sudo yum install python-pip Fedora : sudo dnf install python3 Arch Linux : sudo pacman -S python-pip openSUSE : sudo zypper install python3-pip On macOS : Download get-pip.py and then run it curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py python get-pip.py With Brew : brew install python3 You can verify that pip was installed properly by running the following command in your terminal : pip -V which should returns the version of the installed pip program.","title":"On Unix"},{"location":"sdk/python/client/getting-started/#development","text":"Fork the package . Clone your forked repository. git clone https://github.com/<githubusername>/python-client Next, move into the fresh cloned directory. cd python-client The next step would be to create something like a virtual environment to ensure no name clashes occur. Create and enter the virtual environment # With virtualenv (on Unix and OSx) mkdir my-amazing-solar-project cd my-amazing-solar-project virtualenv virtualEnvName source venv/bin/activate # With virtualenv (on Windows) mkdir my-amazing-solar-project cd my-amazing-solar-project virtualenv virtualEnvName . \\v env \\S cripts \\a ctivate.bat Once inside the virtualenv, you can proceed to install the dependencies. These are listed inside the setup.py file. pip install \\ requests \\ backoff \\ flake8 \\ flake8-import-order \\ flake8-print \\ flake8-quotes \\ pytest \\ pytest-responses \\ pytest-mock \\ pytest-cov Dependencies are now installed, you can now run the tests to see if everything is running as it should. pytest","title":"Development"},{"location":"sdk/python/client/intro/","text":"Client \u00b6 Development \u00b6 Fork the package . Clone your forked repository. git clone https://github.com/<githubusername>/python-client Next, move into the fresh cloned directory. cd python-client The next step would be to create something like a virtual environment to ensure no name clashes occur. Create and enter the virtual environment # With virtualenv (on Unix and OSx) mkdir my-amazing-solar-project cd my-amazing-solar-project virtualenv virtualEnvName source venv/bin/activate # With virtualenv (on Windows) mkdir my-amazing-solar-project cd my-amazing-solar-project virtualenv virtualEnvName . \\v env \\S cripts \\a ctivate.bat Once inside the virtualenv, you can proceed to install dependencies. python -m pip install -e . \"[dev]\" Dependencies are now installed, you can now run the tests to see if everything is running as it should. pytest","title":"Introduction"},{"location":"sdk/python/client/intro/#client","text":"","title":"Client"},{"location":"sdk/python/client/intro/#development","text":"Fork the package . Clone your forked repository. git clone https://github.com/<githubusername>/python-client Next, move into the fresh cloned directory. cd python-client The next step would be to create something like a virtual environment to ensure no name clashes occur. Create and enter the virtual environment # With virtualenv (on Unix and OSx) mkdir my-amazing-solar-project cd my-amazing-solar-project virtualenv virtualEnvName source venv/bin/activate # With virtualenv (on Windows) mkdir my-amazing-solar-project cd my-amazing-solar-project virtualenv virtualEnvName . \\v env \\S cripts \\a ctivate.bat Once inside the virtualenv, you can proceed to install dependencies. python -m pip install -e . \"[dev]\" Dependencies are now installed, you can now run the tests to see if everything is running as it should. pytest","title":"Development"},{"location":"sdk/python/crypto/api-documentation/","text":"API Documentation \u00b6 crypto.configuration.fee \u00b6 get_fee() \u00b6 def get_fee ( transaction_type , type_group ): Get a fee for a given transaction type Parameters \u00b6 Type Name Required Description int transaction_type Yes Transaction type for which we wish to get a fee int type_group Yes transaction type group (TRANSACTION_TYPE_GROUP(Enum)) Return Value \u00b6 <class 'int'> set_fee() \u00b6 def set_fee ( transaction_type , type_group , value ): Set a fee Parameters \u00b6 Type Name Required Description int transaction_type Yes Transaction type for which we wish to set a fee int type_group Yes transaction type group (TRANSACTION_TYPE_GROUP(Enum)) int value Yes Fee for a given transaction type Return Value \u00b6 <class 'NoneType'> crypto.configuration.network \u00b6 set_network() \u00b6 def set_network ( network_object ): Set what network you want to use in the crypto library Parameters \u00b6 Type Name Required Description Network network_object Yes Testnet, Mainnet Return Value \u00b6 <class 'NoneType'> get_network() \u00b6 def get_network (): Get settings for a selected network, default network is Testnet Return Value \u00b6 <class 'dict'> set_custom_network() \u00b6 def set_custom_network ( epoch , version , wif ): Set custom network Parameters \u00b6 Type Name Required Description datetime epoch Yes Network epoch time int version Yes Network version int wif Yes Network WIF Return Value \u00b6 <class 'NoneType'> get_network_version() \u00b6 def get_network_version (): Get currently set network version Return Value \u00b6 <class 'Network'> crypto.identity.address \u00b6 address_from_public_key() \u00b6 def address_from_public_key ( public_key , network_version = None ): Get an address from a public key Parameters \u00b6 Type Name Required Description str public_key Yes Public key int network_version No Version of the network Return Value \u00b6 <class 'str'> address_from_private_key() \u00b6 def address_from_private_key ( private_key , network_version = None ): Get an address from private key Parameters \u00b6 Type Name Required Description str private_key Yes Private key int network_version No Version of the network Return Value \u00b6 <class 'str'> address_from_passphrase() \u00b6 def address_from_passphrase ( passphrase , network_version = None ): Get an address from passphrase Parameters \u00b6 Type Name Required Description str passphrase Yes Passphrase int network_version No Version of the network Return Value \u00b6 <class 'str'> validate_address() \u00b6 def validate_address ( address , network_version = None ): Validate a given address Parameters \u00b6 Type Name Required Description str address Yes Address to validate int network_version No Version of the network Return Value \u00b6 <class 'bool'> crypto.identity.private_key.PrivateKey \u00b6 __init__() \u00b6 def __init__ ( self , private_key ): Create a new PrivateKey instance Parameters \u00b6 Type Name Required Description str private_key Yes Hex private key Return Value \u00b6 <class 'solar_crypto.identity.private_key.PrivateKey'> sign() \u00b6 def sign ( self , message , nonce = None ): Sign a message with this private key object Parameters \u00b6 Type Name Required Description str message Yes Bytes data you want to sign int nonce No Deterministic nonce Return Value \u00b6 <class 'str'> to_hex() \u00b6 def to_hex ( self ): Returns a private key in hex format Return Value \u00b6 <class 'str'> from_passphrase() \u00b6 def from_passphrase ( cls , passphrase ): Create PrivateKey object from a given passphrase Parameters \u00b6 Type Name Required Description str passphrase Yes Passphrase Return Value \u00b6 <class 'PrivateKey'> from_hex() \u00b6 def from_hex ( cls , private_key ): Create PrivateKey object from a given hex private key Parameters \u00b6 Type Name Required Description str private_key Yes Private key Return Value \u00b6 <class 'PrivateKey'> crypto.identity.public_key.PublicKey \u00b6 to_hex() \u00b6 def to_hex ( self ): Returns a public key in hex format Return Value \u00b6 <class 'str'> from_passphrase() \u00b6 def from_passphrase ( cls , passphrase ): Create PublicKey object from a given passphrase Parameters \u00b6 Type Name Required Description str passphrase Yes Passphrase Return Value \u00b6 <class 'PublicKey'> from_hex() \u00b6 def from_hex ( cls , public_key ): Create PublicKey object from a given hex private key Parameters \u00b6 Type Name Required Description str public_key Yes Public key Return Value \u00b6 <class 'PublicKey'> crypto.identity.wif \u00b6 wif_from_passphrase() \u00b6 def wif_from_passphrase ( passphrase , network_wif = None ): Get wif from passphrase Parameters \u00b6 Type Name Required Description str passphrase Yes Passphrase int network_wif No Network WIF Return Value \u00b6 <class 'str'> crypto.transactions.builder.base.BaseTransactionBuilder \u00b6 to_dict() \u00b6 def to_dict ( self ): Convert the transaction to its dictionary representation. Return Value \u00b6 <class 'dict'> to_json() \u00b6 def to_json ( self ): Convert the transaction to its JSON representation Return Value \u00b6 <class 'dict'> sign() \u00b6 def sign ( self , passphrase ): Sign the transaction using the given passphrase Parameters \u00b6 Type Name Required Description str passphrase Yes Passphrase associated with the account sending this transaction Return Value \u00b6 <class 'NoneType'> second_sign() \u00b6 def second_sign ( self , passphrase ): Sign the transaction using the given second passphrase Parameters \u00b6 Type Name Required Description str passphrase Yes Second passphrase associated with the account sending this transaction Return Value \u00b6 <class 'NoneType'> multi_sign() \u00b6 def multi_sign ( self , passphrase , index ): Sign the transaction using the given passphrase. A signature will be generated inside the signatures array of the transaction at the specified index. Parameters \u00b6 Type Name Required Description str passphrase Yes Passphrase associated with the account sending this transaction int index Yes Index of the signature for the signatures array. Starts at 0. Return Value \u00b6 <class 'NoneType'> verify() \u00b6 def verify ( self ): Verify the transaction validity Return Value \u00b6 <class 'bool'> verify_multisig() \u00b6 def verify_multisig ( self ): Verify the multisignature transaction validity Return Value \u00b6 <class 'bool'> set_nonce() \u00b6 def set_nonce ( self , nonce ): Set the nonce of the transaction. Parameters \u00b6 Type Name Required Description int nonce Yes Sequential Nonce of the transaction Return Value \u00b6 <class 'NoneType'> set_fee() \u00b6 def set_fee ( self , fee : int ): Set a fee Parameters \u00b6 Type Name Required Description int fee Yes Transaction fee Return Value \u00b6 <class 'NoneType'> set_amount() \u00b6 def set_amount ( self , amount ): Set the amount of the transaction. Parameters \u00b6 Type Name Required Description int amount Yes Amount of the transaction Return Value \u00b6 <class 'NoneType'> set_sender_public_key() \u00b6 def set_sender_public_key ( self , public_key ): Set the Public Key of the transaction. Parameters \u00b6 Type Name Required Description str public_key Yes Public key of the transaction Return Value \u00b6 <class 'NoneType'> set_expiration() \u00b6 def set_expiration ( self , expiration ): Set the block-height or time when the transaction should expire. Parameters \u00b6 Type Name Required Description int, HTLC_LOCK_EXPIRATION_TYPE expiration Yes Expiration of the transaction Return Value \u00b6 <class 'NoneType'> set_type_group() \u00b6 def set_type_group ( self , type_group ): Set the type group of the transaction. Parameters \u00b6 Type Name Required Description int, TRANSACTION_TYPE_GROUP type_group Yes Type group of the transaction Return Value \u00b6 <class 'NoneType'> crypto.transactions.builder.burn.Burn \u00b6 __init__() \u00b6 def __init__ ( self , amount ): Create a new Burn transaction instance Parameters \u00b6 Type Name Required Description int amount Yes Burn amount Return Value \u00b6 <class 'solar_crypto.transactions.builder.burn.Burn'> crypto.transactions.builder.delegate_registration.DelegateRegistration \u00b6 __init__() \u00b6 def __init__ ( self , username , fee = None ): Create a new DelegateRegistration transaction instance Parameters \u00b6 Type Name Required Description str username Yes Delegate username int fee No Transaction fee Return Value \u00b6 <class 'solar_crypto.transactions.builder.delegate_registration.DelegateRegistration'> sign() \u00b6 def sign ( self , passphrase ): Sign the transaction using the given passphrase Parameters \u00b6 Type Name Required Description str passphrase Yes Passphrase Return Value \u00b6 <class 'NoneType'> crypto.transactions.builder.delegate_resignation.DelegateResignation \u00b6 __init__() \u00b6 def __init__ ( self , fee = None ): Create a new DelegateResignation transaction instance Parameters \u00b6 Type Name Required Description int fee No Transaction fee Return Value \u00b6 <class 'solar_crypto.transactions.builder.delegate_resignation.DelegateResignation'> get_type_group() \u00b6 def get_type_group ( self ): Get the type group of the Transaction. Return Value \u00b6 <class 'int'> crypto.transactions.builder.htlc_claim.HtlcClaim \u00b6 __init__() \u00b6 def __init__ ( self , lock_transaction_id , unlock_secret , hash_type : HashingType = HashingType . SHA256 , fee = None ): Create a new HtlcClaim transaction instance Parameters \u00b6 Type Name Required Description str lock_transaction_id Yes HTLC Lock transaction id str unlock_secret Yes Transaction secret hash HashingType hash_type No Hashing algorithm int fee No Transaction fee Return Value \u00b6 <class 'solar_crypto.transactions.builder.htlc_claim.HtlcClaim'> get_type_group() \u00b6 def get_type_group ( self ): Get the type group of the Transaction. Return Value \u00b6 <class 'int'> crypto.transactions.builder.htlc_lock.HtlcLock \u00b6 __init__() \u00b6 def __init__ ( self , recipient_id , amount , secret_hash , expiration_type , expiration_value , memo = None , fee = None ): Create a new HtlcLock transaction instance Parameters \u00b6 Type Name Required Description str recipient_id Yes Transaction recipient int amount Yes Transaction amount str secret_hash Yes Transaction secret hash. The same hash must be used in the corresponding \"claim\" transaction int expiration_type Yes Transaction expiration type. Either block height or network epoch timestamp based int expiration_value Yes Transaction expiration value. The block-height or time when the transaction should expire str memo Yes Transaction memo int fee No Transaction fee Return Value \u00b6 <class 'solar_crypto.transactions.builder.htlc_lock.HtlcLock'> get_type_group() \u00b6 def get_type_group ( self ): Get the type group of the Transaction. Return Value \u00b6 <class 'int'> crypto.transactions.builder.htlc_refund.HtlcRefund \u00b6 __init__() \u00b6 def __init__ ( self , lock_transaction_id , fee = None ): Create a new HtlcRefund transaction instance Parameters \u00b6 Type Name Required Description str lock_transaction_id Yes HTLC Lock transaction id int fee No Transaction fee Return Value \u00b6 <class 'solar_crypto.transactions.builder.htlc_refund.HtlcRefund'> get_type_group() \u00b6 def get_type_group ( self ): Get the type group of the Transaction. Return Value \u00b6 <class 'int'> crypto.transactions.builder.ipfs.IPFS \u00b6 __init__() \u00b6 def __init__ ( self , ipfs_cid = None , fee = None ): Create a new IPFS transaction instance Parameters \u00b6 Type Name Required Description str ipfs_cid No Content identifier int fee No Transaction fee Return Value \u00b6 <class 'solar_crypto.transactions.builder.ipfs.IPFS'> get_type_group() \u00b6 def get_type_group ( self ): Get the type group of the Transaction. Return Value \u00b6 <class 'int'> set_ipfs_cid() \u00b6 set_ipfs_cid ( self , cid : str ): Set the content identifier of the Transaction. Parameters \u00b6 Type Name Required Description str cid Yes Content identifier Return Value \u00b6 <class 'NoneType'> crypto.transactions.builder.transfer.Transfer \u00b6 __init__() \u00b6 def __init__ ( self , memo = None , fee = None ): Create a new Transfer transaction instance Parameters \u00b6 Type Name Required Description str memo No Transaction memo int fee No Transaction fee Return Value \u00b6 <class 'solar_crypto.transactions.builder.transfer.Transfer'> get_type_group() \u00b6 def get_type_group ( self ): Get the type group of the Transaction. Return Value \u00b6 <class 'int'> add_transfer() \u00b6 def add_transfer ( self , amount , recipient_id ): Add a transfer to the Transfers array of a Transaction. Parameters \u00b6 Type Name Required Description int amount Yes Transaction amount string recipient_id Yes Transaction recipient Return Value \u00b6 <class 'NoneType'> crypto.transactions.builder.multi_signature_registration.MultiSignatureRegistration \u00b6 __init__() \u00b6 def __init__ ( self , fee = None ): Create a new MultiSignatureRegistration transaction instance Parameters \u00b6 Type Name Required Description int fee No Transaction fee Return Value \u00b6 <class 'solar_crypto.transactions.builder.multi_signature_registration.MultiSignatureRegistration'> set_min() \u00b6 def set_min ( self , minimum_participants ): Set the minimum amount of participants of a Transaction. Parameters \u00b6 Type Name Required Description int minimum_participants Yes Transaction minimum participants Return Value \u00b6 <class 'NoneType'> set_public_keys() \u00b6 def set_public_keys ( self , public_keys ): Set the public keys of a Transaction. Parameters \u00b6 Type Name Required Description list public_keys Yes Transaction public keys participants Return Value \u00b6 <class 'NoneType'> add_participant() \u00b6 def add_participant ( self , public_key ): Add a participant with his public key to the Transaction. Parameters \u00b6 Type Name Required Description str public_key Yes Participant public key Return Value \u00b6 <class 'NoneType'> crypto.transactions.builder.second_signature_registration.SecondSignatureRegistration \u00b6 __init__() \u00b6 def __init__ ( self , second_passphrase , fee = None ): Create a new SecondSignatureRegistration transaction instance Parameters \u00b6 Type Name Required Description str second_passphrase No Second passphrase int fee No Transaction fee Return Value \u00b6 <class 'solar_crypto.transactions.builder.second_signature_registration.SecondSignatureRegistration'> crypto.transactions.builder.legacy_transfer.LegacyTransfer \u00b6 __init__() \u00b6 def __init__ ( self , recipientId , amount , memo = None , fee = None ): Create a new Legacy Transfer transaction instance Parameters \u00b6 Type Name Required Description str recipientId Yes Recipient identifier int amount Yes Transaction amount str memo No Transaction memo int fee No Transaction fee Return Value \u00b6 <class 'solar_crypto.transactions.builder.legacy_transfer.LegacyTransfer'> crypto.transactions.builder.legacy_vote.LegacyVote \u00b6 __init__() \u00b6 def __init__ ( self , vote = None , fee = None ): Create a new Legacy Vote transaction instance Parameters \u00b6 Type Name Required Description str vote No Delegate address to vote for int fee No Transaction fee Return Value \u00b6 <class 'solar_crypto.transactions.builder.legacy_vote.LegacyVote'> set_votes() \u00b6 def set_votes ( self , votes : typing . List [ str ]): Set legacy votes/cancel vote Parameters \u00b6 Type Name Required Description List[str] votes Yes list of votes Return Value \u00b6 <class 'NoneType'> sign() \u00b6 def sign ( self , passphrase ): Sign the transaction using the given passphrase Parameters \u00b6 Type Name Required Description str passphrase Yes Passphrase Return Value \u00b6 <class 'NoneType'> crypto.transactions.builder.vote.Vote \u00b6 __init__() \u00b6 def __init__ ( self ): Create a new Vote transaction instance Return Value \u00b6 <class 'solar_crypto.transactions.builder.vote.Vote'> set_votes() \u00b6 def set_votes ( self , votes : typing . Union [ typing . List [ str ], typing . Dict [ str , typing . Union [ int , float , Decimal ]]] = dict ): Set votes Parameters \u00b6 Type Name Required Description votes votes Yes list of votes Return Value \u00b6 <class 'NoneType'> crypto.transactions.deserializers.base.BaseDeserializer \u00b6 __init__() \u00b6 def __init__ ( self , serialized , asset_offset , transaction ): Create a new deserializer instance Parameters \u00b6 Type Name Required Description ??? serialized Yes Serialized ??? asset_offset Yes Offset ??? transaction Yes Transaction Return Value \u00b6 <class 'solar_crypto.transactions.deserializers.base.BaseDeserializer'> deserialize() \u00b6 def deserialize ( self ): Handle the deserialization of transaction data Return Value \u00b6 NotImplementedError crypto.transactions.deserializers.burn.BurnDeserializer \u00b6 deserialize() \u00b6 def deserialize ( self ): Handle the deserialization of \"burn\" data Return Value \u00b6 <class 'dict'> crypto.transactions.deserializers.delegate_registration.DelegateRegistrationDeserializer \u00b6 deserialize() \u00b6 def deserialize ( self ): Handle the deserialization of \"delegate registration\" data Return Value \u00b6 <class 'dict'> crypto.transactions.deserializers.delegate_resignation.DelegateResignationDeserializer \u00b6 deserialize() \u00b6 def deserialize ( self ): Handle the deserialization of \"delegate resignation\" data Return Value \u00b6 <class 'dict'> crypto.transactions.deserializers.htlc_claim.HtlcClaimDeserializer \u00b6 deserialize() \u00b6 def deserialize ( self ): Handle the deserialization of \"HTLC Claim\" data Return Value \u00b6 <class 'dict'> crypto.transactions.deserializers.htlc_lock.HtlcLockDeserializer \u00b6 deserialize() \u00b6 def deserialize ( self ): Handle the deserialization of \"HTLC Lock\" data Return Value \u00b6 <class 'dict'> crypto.transactions.deserializers.htlc_refund.HtlcRefundDeserializer \u00b6 deserialize() \u00b6 def deserialize ( self ): Handle the deserialization of \"HTLC refund\" data Return Value \u00b6 <class 'dict'> crypto.transactions.deserializers.ipfs.IPFSDeserializer \u00b6 deserialize() \u00b6 def deserialize ( self ): Handle the deserialization of \"IPFS\" data Return Value \u00b6 <class 'dict'> crypto.transactions.deserializers.transfer.TransferDeserializer \u00b6 deserialize() \u00b6 def deserialize ( self ): Handle the deserialization of \"transfer\" data Return Value \u00b6 <class 'dict'> crypto.transactions.deserializers.multi_signature_registration.MultiSignatureRegistrationDeserializer \u00b6 deserialize() \u00b6 def deserialize ( self ): Handle the deserialization of \"multi signature registration\" data Return Value \u00b6 <class 'dict'> crypto.transactions.deserializers.second_signature_registration.SecondSignatureRegistrationDeserializer \u00b6 deserialize() \u00b6 def deserialize ( self ): Handle the deserialization of \"second signature\" data. Return Value \u00b6 <class 'dict'> crypto.transactions.deserializers.legacy_transfer.LegacyTransferDeserializer \u00b6 deserialize() \u00b6 def deserialize ( self ): Handle the deserialization of \"legacy transfer\" data Return Value \u00b6 <class 'dict'> crypto.transactions.deserializers.legacy_vote.LegacyVoteDeserializer \u00b6 deserialize() \u00b6 def deserialize ( self ): Handle the deserialization of \"legacy vote\" data. Return Value \u00b6 <class 'dict'> crypto.transactions.deserializers.vote.VoteDeserializer \u00b6 deserialize() \u00b6 def deserialize ( self ): Handle the deserialization of \"vote\" data. Return Value \u00b6 <class 'dict'> crypto.transactions.serializers.base.BaseSerializer \u00b6 __init__() \u00b6 def __init__ ( self , transaction , byte_data = bytes ()): Create a new serializer instance Parameters \u00b6 Type Name Required Description Transaction transaction Yes Transaction bytes byte_data No ... Return Value \u00b6 <class 'solar_crypto.transactions.serializers.base.BaseSerializer'> serialize \u00b6 def serialize ( self ): Handle the serialization of transaction data Return Value \u00b6 NotImplementedError crypto.transactions.serializers.burn.BurnSerializer \u00b6 serialize \u00b6 def serialize ( self ): Handle the serialization of \"burn\" data Return Value \u00b6 <class 'bytes'> crypto.transactions.serializers.delegate_registration.DelegateRegistrationSerializer \u00b6 serialize \u00b6 def serialize ( self ): Handle the serialization of \"delegate registration\" data Return Value \u00b6 <class 'bytes'> crypto.transactions.serializers.delegate_resignationDelegateResignationSerializer \u00b6 serialize \u00b6 def serialize ( self ): Handle the serialization of \"delegate resignation\" data Return Value \u00b6 <class 'bytes'> crypto.transactions.serializers.htlc_claim.HtlcClaimSerializer \u00b6 serialize() \u00b6 def serialize ( self ): Handle the serialization of \"HTLC Claim\" data Return Value \u00b6 <class 'bytes'> crypto.transactions.serializers.htlc_lock.HtlcLockSerializer \u00b6 serialize() \u00b6 def serialize ( self ): Handle the serialization of \"HTLC Lock\" data Return Value \u00b6 <class 'bytes'> crypto.transactions.serializers.htlc_refund.HtlcRefundSerializer \u00b6 serialize() \u00b6 def serialize ( self ): Handle the serialization of \"HTLC Refund\" data Return Value \u00b6 <class 'bytes'> crypto.transactions.serializers.ipfs.IPFSSerializer \u00b6 serialize \u00b6 def serialize ( self ): Handle the serialization of \"ipfs\" data Return Value \u00b6 <class 'bytes'> crypto.transactions.serializers.transfer.TransferSerializer \u00b6 serialize \u00b6 def serialize ( self ): Handle the serialization of \"transfer\" data Return Value \u00b6 <class 'bytes'> crypto.transactions.serializers.multi_signature_registration.MultiSignatureSerializer \u00b6 serialize \u00b6 def serialize ( self ): Handle the serialization of \"multi signature\" data Return Value \u00b6 <class 'bytes'> crypto.transactions.serializers.second_signature_registration.SecondSignatureRegistrationSerializer \u00b6 serialize \u00b6 def serialize ( self ): Handle the serialization of \"second signature\" data Return Value \u00b6 <class 'bytes'> crypto.transactions.serializers.legacy_transfer.LegacyTransferSerializer \u00b6 serialize \u00b6 def serialize ( self ): Handle the serialization of \"legacy transfer\" data Return Value \u00b6 <class 'bytes'> crypto.transactions.serializers.legacy_vote.LegacyVoteSerializer \u00b6 serialize \u00b6 def serialize ( self ): Handle the serialization of \"legacy vote\" data Return Value \u00b6 <class 'bytes'> crypto.transactions.serializers.vote.VoteSerializer \u00b6 serialize \u00b6 def serialize ( self ): Handle the serialization of \"vote\" data Return Value \u00b6 <class 'bytes'> crypto.transactions.deserializer.Deserializer \u00b6 __init__ \u00b6 def __init__ ( self , serialized ): Create a new deserializer instance Parameters \u00b6 Type Name Required Description str serialized Yes Serialized Return Value \u00b6 <class 'solar_crypto.transactions.deserializer.Deserializer'> deserialize \u00b6 def deserialize ( self ): Perform AIP11 compliant deserialization Return Value \u00b6 <class 'solar_crypto.transactions.transaction.Transaction'> _handle_transaction_type \u00b6 def _handle_transaction_type ( self , asset_offset , transaction ): Handle the deserialization of transaction data Parameters \u00b6 Type Name Required Description int asset_offset Yes Offset transaction.Transaction transaction Yes Transaction Return Value \u00b6 <class 'solar_crypto.transactions.transaction.Transaction'> crypto.transactions.serializer.Serializer \u00b6 __init__ \u00b6 def __init__ ( self , transaction ): Create a new serializer instance Parameters \u00b6 Type Name Required Description transaction.Transaction transaction Yes Transaction Return Value \u00b6 <class 'solar_crypto.transactions.serializer.Serializer'> serialize \u00b6 def serialize ( self , skip_signature = True , skip_second_signature = True , skip_multi_signature = True , raw = False ): Perform AIP11 compliant serialization Parameters \u00b6 Type Name Required Description bool skip_signature No Should we skip the serialization of the signature bool skip_second_signature No Should we skip the serialization of the second signature bool skip_multi_signature No Should we skip the serialization of multiple signatures bool raw No Raw output Return Value \u00b6 <class 'str'> _handle_transaction_type \u00b6 def _handle_transaction_type ( self , bytes_data ): Handle the serialization of transaction data Parameters \u00b6 Type Name Required Description bytes bytes_data Yes ... Return Value \u00b6 <class 'bytes'> _handle_signature \u00b6 def _handle_signature ( self , bytes_data , skip_signature , skip_second_signature , skip_multi_signature ): Handle the serialization of \"signatures\" data Parameters \u00b6 Type Name Required Description bytes bytes_data Yes ... bool skip_signature Yes Should we skip the serialization of the signature bool skip_second_signature Yes Should we skip the serialization of the second signature bool skip_multi_signature Yes Should we skip the serialization of multiple signatures Return Value \u00b6 <class 'bytes'> crypto.transactions.transaction.Transaction \u00b6 __init__ \u00b6 def __init__ ( self , * args , ** kwargs ): Create a new transaction instance Parameters \u00b6 Type Name Required Description any *args No ... any **kwargs No ... Return Value \u00b6 <class 'solar_crypto.transactions.transaction.Transaction'> get_id \u00b6 def get_id ( self ): Convert the byte representation to a unique identifier Return Value \u00b6 <class 'str'> to_dict \u00b6 def to_dict ( self ): Convert the transaction to its dictionary representation. Return Value \u00b6 <class 'dict'> to_json \u00b6 def to_json ( self ): Convert the transaction to its JSON representation Return Value \u00b6 <class 'dict'> to_bytes \u00b6 def to_bytes ( self , skip_signature = True , skip_second_signature = True , skip_multi_signature = True ): Convert the transaction to its byte representation Parameters \u00b6 Type Name Required Description bool skip_signature Yes Skip first signature bool skip_second_signature Yes Skip second signature bool skip_multi_signature Yes Skip multi signatures Return Value \u00b6 <class 'bytes'> parse_signatures \u00b6 def parse_signatures ( self , serialized , start_offset ): Parse the signature, second signature and multi signatures Parameters \u00b6 Type Name Required Description str serialized Yes Serialized int start_offset Yes Offset Return Value \u00b6 <class 'NoneType'> serialize \u00b6 def serialize ( self , skip_signature = True , skip_second_signature = True , skip_multi_signature = True ): Perform AIP11 compliant serialization Parameters \u00b6 Type Name Required Description bool skip_signature Yes Skip first signature bool skip_second_signature Yes Skip second signature bool skip_multi_signature Yes Skip multi signatures Return Value \u00b6 <class 'str'> deserialize \u00b6 def deserialize ( self , serialized ): Perform AIP11 compliant deserialization Parameters \u00b6 Type Name Required Description str serialized Yes Serialized Return Value \u00b6 <class 'str'> verify \u00b6 def verify ( self ): Verify the transaction. Method will raise an exception if invalid, if it's valid it will returns True Return Value \u00b6 <class 'bool'> verify_secondsig \u00b6 def verify_secondsig ( self , secondPublicKey ): Verify the second signature. Method will raise an exception if invalid, if it's valid it will returns True Parameters \u00b6 Type Name Required Description str secondPublicKey Yes Second public key Return Value \u00b6 <class 'bool'> verify_signatures \u00b6 def verify_signatures ( self , multi_signature_asset ): Verify the multisignatures transaction. Method will raise an exception if invalid, it will returns True Parameters \u00b6 Type Name Required Description dict multi_signature_asset Yes Multisignature asset Return Value \u00b6 <class 'bool'> _handle_transaction_type \u00b6 def _handle_transaction_type ( self , bytes_data ): Handle each transaction type differently Parameters \u00b6 Type Name Required Description bytes bytes_data Yes Input the bytes data to which you want to append new bytes Return Value \u00b6 <class 'bytes'> _handle_signature \u00b6 def _handle_signature ( self , bytes_data , skip_signature , skip_second_signature , skip_multi_signature ): Handle the serialization of \"signatures\" data Parameters \u00b6 Type Name Required Description bytes bytes_data Yes Input the bytes data to which you want to append new bytes from signature bool skip_signature Yes Skip first signature bool skip_second_signature Yes Skip second signature bool skip_multi_signature Yes Skip multi signatures Return Value \u00b6 <class 'bytes'> crypto.utils.crypto \u00b6 sign_schnorr \u00b6 def sign_schnorr ( msg : bytes , private_key : PrivateKey , nonce : int = None ) -> str : Signs a message using Schnorr BIP340 and returns a hex string of the signature Parameters \u00b6 Type Name Required Description bytes msg Yes Message to be signed PrivateKey private_key Yes Private key object int nonce No Deterministic nonce Return Value \u00b6 <class 'str'> sign_schnorr_legacy \u00b6 def sign_schnorr_legacy ( msg : bytes , private_key : PrivateKey ) -> str : Signs a message using Legacy Schnorr and returns a hex string of the signature Parameters \u00b6 Type Name Required Description bytes msg Yes Message to be signed PrivateKey private_key Yes Private key object int nonce No Deterministic nonce Return Value \u00b6 <class 'str'> verify_schnorr \u00b6 def verify_schnorr ( msg : bytes , public_key : str , signature : str ) -> bool : Verifies a message using Schnorr BIP340 Parameters \u00b6 Type Name Required Description bytes msg Yes Message to be verified str public_key Yes Public key str signature Yes Signature Return Value \u00b6 <class 'bool'> verify_schnorr_legacy \u00b6 def verify_schnorr_legacy ( msg : bytes , public_key : str , signature : str ) -> bool : Verifies a message using Legacy Schnorr Parameters \u00b6 Type Name Required Description bytes msg Yes Message to be verified str public_key Yes Public key str signature Yes Signature Return Value \u00b6 <class 'bool'> crypto.utils.message.Message \u00b6 __init__ \u00b6 def __init__ ( self , ** kwargs ): Create a new message instance Parameters \u00b6 Type Name Required Description any **kwargs No ... Return Value \u00b6 <class 'solar_crypto.utils.message.Message'> sign \u00b6 def sign ( cls , message , passphrase ): Sign a message using the given passphrase Parameters \u00b6 Type Name Required Description str message Yes Message str passphrase Yes Passphrase Return Value \u00b6 <class 'solar_crypto.utils.message.Message'> verify \u00b6 def verify ( self ): Verify the message contents Return Value \u00b6 <class 'bool'> to_dict \u00b6 def to_dict ( self ): Convert the message to its dictionary representation Return Value \u00b6 <class 'dict'> to_json \u00b6 def to_json ( self ): Convert the message to its JSON representation Return Value \u00b6 <class 'dict'> crypto.utils.slot \u00b6 get_time \u00b6 def get_time (): Get the time diff between now and network start Return Value \u00b6 <class 'int'> get_epoch \u00b6 def get_epoch (): Get the network start epoch Return Value \u00b6 <class 'datetime'>","title":"API Documentation"},{"location":"sdk/python/crypto/api-documentation/#api-documentation","text":"","title":"API Documentation"},{"location":"sdk/python/crypto/api-documentation/#cryptoconfigurationfee","text":"","title":"crypto.configuration.fee"},{"location":"sdk/python/crypto/api-documentation/#get_fee","text":"def get_fee ( transaction_type , type_group ): Get a fee for a given transaction type","title":"get_fee()"},{"location":"sdk/python/crypto/api-documentation/#parameters","text":"Type Name Required Description int transaction_type Yes Transaction type for which we wish to get a fee int type_group Yes transaction type group (TRANSACTION_TYPE_GROUP(Enum))","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value","text":"<class 'int'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#set_fee","text":"def set_fee ( transaction_type , type_group , value ): Set a fee","title":"set_fee()"},{"location":"sdk/python/crypto/api-documentation/#parameters_1","text":"Type Name Required Description int transaction_type Yes Transaction type for which we wish to set a fee int type_group Yes transaction type group (TRANSACTION_TYPE_GROUP(Enum)) int value Yes Fee for a given transaction type","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_1","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptoconfigurationnetwork","text":"","title":"crypto.configuration.network"},{"location":"sdk/python/crypto/api-documentation/#set_network","text":"def set_network ( network_object ): Set what network you want to use in the crypto library","title":"set_network()"},{"location":"sdk/python/crypto/api-documentation/#parameters_2","text":"Type Name Required Description Network network_object Yes Testnet, Mainnet","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_2","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#get_network","text":"def get_network (): Get settings for a selected network, default network is Testnet","title":"get_network()"},{"location":"sdk/python/crypto/api-documentation/#return-value_3","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#set_custom_network","text":"def set_custom_network ( epoch , version , wif ): Set custom network","title":"set_custom_network()"},{"location":"sdk/python/crypto/api-documentation/#parameters_3","text":"Type Name Required Description datetime epoch Yes Network epoch time int version Yes Network version int wif Yes Network WIF","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_4","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#get_network_version","text":"def get_network_version (): Get currently set network version","title":"get_network_version()"},{"location":"sdk/python/crypto/api-documentation/#return-value_5","text":"<class 'Network'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptoidentityaddress","text":"","title":"crypto.identity.address"},{"location":"sdk/python/crypto/api-documentation/#address_from_public_key","text":"def address_from_public_key ( public_key , network_version = None ): Get an address from a public key","title":"address_from_public_key()"},{"location":"sdk/python/crypto/api-documentation/#parameters_4","text":"Type Name Required Description str public_key Yes Public key int network_version No Version of the network","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_6","text":"<class 'str'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#address_from_private_key","text":"def address_from_private_key ( private_key , network_version = None ): Get an address from private key","title":"address_from_private_key()"},{"location":"sdk/python/crypto/api-documentation/#parameters_5","text":"Type Name Required Description str private_key Yes Private key int network_version No Version of the network","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_7","text":"<class 'str'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#address_from_passphrase","text":"def address_from_passphrase ( passphrase , network_version = None ): Get an address from passphrase","title":"address_from_passphrase()"},{"location":"sdk/python/crypto/api-documentation/#parameters_6","text":"Type Name Required Description str passphrase Yes Passphrase int network_version No Version of the network","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_8","text":"<class 'str'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#validate_address","text":"def validate_address ( address , network_version = None ): Validate a given address","title":"validate_address()"},{"location":"sdk/python/crypto/api-documentation/#parameters_7","text":"Type Name Required Description str address Yes Address to validate int network_version No Version of the network","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_9","text":"<class 'bool'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptoidentityprivate_keyprivatekey","text":"","title":"crypto.identity.private_key.PrivateKey"},{"location":"sdk/python/crypto/api-documentation/#__init__","text":"def __init__ ( self , private_key ): Create a new PrivateKey instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_8","text":"Type Name Required Description str private_key Yes Hex private key","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_10","text":"<class 'solar_crypto.identity.private_key.PrivateKey'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#sign","text":"def sign ( self , message , nonce = None ): Sign a message with this private key object","title":"sign()"},{"location":"sdk/python/crypto/api-documentation/#parameters_9","text":"Type Name Required Description str message Yes Bytes data you want to sign int nonce No Deterministic nonce","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_11","text":"<class 'str'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#to_hex","text":"def to_hex ( self ): Returns a private key in hex format","title":"to_hex()"},{"location":"sdk/python/crypto/api-documentation/#return-value_12","text":"<class 'str'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#from_passphrase","text":"def from_passphrase ( cls , passphrase ): Create PrivateKey object from a given passphrase","title":"from_passphrase()"},{"location":"sdk/python/crypto/api-documentation/#parameters_10","text":"Type Name Required Description str passphrase Yes Passphrase","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_13","text":"<class 'PrivateKey'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#from_hex","text":"def from_hex ( cls , private_key ): Create PrivateKey object from a given hex private key","title":"from_hex()"},{"location":"sdk/python/crypto/api-documentation/#parameters_11","text":"Type Name Required Description str private_key Yes Private key","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_14","text":"<class 'PrivateKey'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptoidentitypublic_keypublickey","text":"","title":"crypto.identity.public_key.PublicKey"},{"location":"sdk/python/crypto/api-documentation/#to_hex_1","text":"def to_hex ( self ): Returns a public key in hex format","title":"to_hex()"},{"location":"sdk/python/crypto/api-documentation/#return-value_15","text":"<class 'str'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#from_passphrase_1","text":"def from_passphrase ( cls , passphrase ): Create PublicKey object from a given passphrase","title":"from_passphrase()"},{"location":"sdk/python/crypto/api-documentation/#parameters_12","text":"Type Name Required Description str passphrase Yes Passphrase","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_16","text":"<class 'PublicKey'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#from_hex_1","text":"def from_hex ( cls , public_key ): Create PublicKey object from a given hex private key","title":"from_hex()"},{"location":"sdk/python/crypto/api-documentation/#parameters_13","text":"Type Name Required Description str public_key Yes Public key","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_17","text":"<class 'PublicKey'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptoidentitywif","text":"","title":"crypto.identity.wif"},{"location":"sdk/python/crypto/api-documentation/#wif_from_passphrase","text":"def wif_from_passphrase ( passphrase , network_wif = None ): Get wif from passphrase","title":"wif_from_passphrase()"},{"location":"sdk/python/crypto/api-documentation/#parameters_14","text":"Type Name Required Description str passphrase Yes Passphrase int network_wif No Network WIF","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_18","text":"<class 'str'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsbuilderbasebasetransactionbuilder","text":"","title":"crypto.transactions.builder.base.BaseTransactionBuilder"},{"location":"sdk/python/crypto/api-documentation/#to_dict","text":"def to_dict ( self ): Convert the transaction to its dictionary representation.","title":"to_dict()"},{"location":"sdk/python/crypto/api-documentation/#return-value_19","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#to_json","text":"def to_json ( self ): Convert the transaction to its JSON representation","title":"to_json()"},{"location":"sdk/python/crypto/api-documentation/#return-value_20","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#sign_1","text":"def sign ( self , passphrase ): Sign the transaction using the given passphrase","title":"sign()"},{"location":"sdk/python/crypto/api-documentation/#parameters_15","text":"Type Name Required Description str passphrase Yes Passphrase associated with the account sending this transaction","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_21","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#second_sign","text":"def second_sign ( self , passphrase ): Sign the transaction using the given second passphrase","title":"second_sign()"},{"location":"sdk/python/crypto/api-documentation/#parameters_16","text":"Type Name Required Description str passphrase Yes Second passphrase associated with the account sending this transaction","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_22","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#multi_sign","text":"def multi_sign ( self , passphrase , index ): Sign the transaction using the given passphrase. A signature will be generated inside the signatures array of the transaction at the specified index.","title":"multi_sign()"},{"location":"sdk/python/crypto/api-documentation/#parameters_17","text":"Type Name Required Description str passphrase Yes Passphrase associated with the account sending this transaction int index Yes Index of the signature for the signatures array. Starts at 0.","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_23","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#verify","text":"def verify ( self ): Verify the transaction validity","title":"verify()"},{"location":"sdk/python/crypto/api-documentation/#return-value_24","text":"<class 'bool'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#verify_multisig","text":"def verify_multisig ( self ): Verify the multisignature transaction validity","title":"verify_multisig()"},{"location":"sdk/python/crypto/api-documentation/#return-value_25","text":"<class 'bool'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#set_nonce","text":"def set_nonce ( self , nonce ): Set the nonce of the transaction.","title":"set_nonce()"},{"location":"sdk/python/crypto/api-documentation/#parameters_18","text":"Type Name Required Description int nonce Yes Sequential Nonce of the transaction","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_26","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#set_fee_1","text":"def set_fee ( self , fee : int ): Set a fee","title":"set_fee()"},{"location":"sdk/python/crypto/api-documentation/#parameters_19","text":"Type Name Required Description int fee Yes Transaction fee","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_27","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#set_amount","text":"def set_amount ( self , amount ): Set the amount of the transaction.","title":"set_amount()"},{"location":"sdk/python/crypto/api-documentation/#parameters_20","text":"Type Name Required Description int amount Yes Amount of the transaction","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_28","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#set_sender_public_key","text":"def set_sender_public_key ( self , public_key ): Set the Public Key of the transaction.","title":"set_sender_public_key()"},{"location":"sdk/python/crypto/api-documentation/#parameters_21","text":"Type Name Required Description str public_key Yes Public key of the transaction","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_29","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#set_expiration","text":"def set_expiration ( self , expiration ): Set the block-height or time when the transaction should expire.","title":"set_expiration()"},{"location":"sdk/python/crypto/api-documentation/#parameters_22","text":"Type Name Required Description int, HTLC_LOCK_EXPIRATION_TYPE expiration Yes Expiration of the transaction","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_30","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#set_type_group","text":"def set_type_group ( self , type_group ): Set the type group of the transaction.","title":"set_type_group()"},{"location":"sdk/python/crypto/api-documentation/#parameters_23","text":"Type Name Required Description int, TRANSACTION_TYPE_GROUP type_group Yes Type group of the transaction","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_31","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsbuilderburnburn","text":"","title":"crypto.transactions.builder.burn.Burn"},{"location":"sdk/python/crypto/api-documentation/#__init___1","text":"def __init__ ( self , amount ): Create a new Burn transaction instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_24","text":"Type Name Required Description int amount Yes Burn amount","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_32","text":"<class 'solar_crypto.transactions.builder.burn.Burn'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsbuilderdelegate_registrationdelegateregistration","text":"","title":"crypto.transactions.builder.delegate_registration.DelegateRegistration"},{"location":"sdk/python/crypto/api-documentation/#__init___2","text":"def __init__ ( self , username , fee = None ): Create a new DelegateRegistration transaction instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_25","text":"Type Name Required Description str username Yes Delegate username int fee No Transaction fee","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_33","text":"<class 'solar_crypto.transactions.builder.delegate_registration.DelegateRegistration'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#sign_2","text":"def sign ( self , passphrase ): Sign the transaction using the given passphrase","title":"sign()"},{"location":"sdk/python/crypto/api-documentation/#parameters_26","text":"Type Name Required Description str passphrase Yes Passphrase","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_34","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsbuilderdelegate_resignationdelegateresignation","text":"","title":"crypto.transactions.builder.delegate_resignation.DelegateResignation"},{"location":"sdk/python/crypto/api-documentation/#__init___3","text":"def __init__ ( self , fee = None ): Create a new DelegateResignation transaction instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_27","text":"Type Name Required Description int fee No Transaction fee","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_35","text":"<class 'solar_crypto.transactions.builder.delegate_resignation.DelegateResignation'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#get_type_group","text":"def get_type_group ( self ): Get the type group of the Transaction.","title":"get_type_group()"},{"location":"sdk/python/crypto/api-documentation/#return-value_36","text":"<class 'int'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsbuilderhtlc_claimhtlcclaim","text":"","title":"crypto.transactions.builder.htlc_claim.HtlcClaim"},{"location":"sdk/python/crypto/api-documentation/#__init___4","text":"def __init__ ( self , lock_transaction_id , unlock_secret , hash_type : HashingType = HashingType . SHA256 , fee = None ): Create a new HtlcClaim transaction instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_28","text":"Type Name Required Description str lock_transaction_id Yes HTLC Lock transaction id str unlock_secret Yes Transaction secret hash HashingType hash_type No Hashing algorithm int fee No Transaction fee","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_37","text":"<class 'solar_crypto.transactions.builder.htlc_claim.HtlcClaim'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#get_type_group_1","text":"def get_type_group ( self ): Get the type group of the Transaction.","title":"get_type_group()"},{"location":"sdk/python/crypto/api-documentation/#return-value_38","text":"<class 'int'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsbuilderhtlc_lockhtlclock","text":"","title":"crypto.transactions.builder.htlc_lock.HtlcLock"},{"location":"sdk/python/crypto/api-documentation/#__init___5","text":"def __init__ ( self , recipient_id , amount , secret_hash , expiration_type , expiration_value , memo = None , fee = None ): Create a new HtlcLock transaction instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_29","text":"Type Name Required Description str recipient_id Yes Transaction recipient int amount Yes Transaction amount str secret_hash Yes Transaction secret hash. The same hash must be used in the corresponding \"claim\" transaction int expiration_type Yes Transaction expiration type. Either block height or network epoch timestamp based int expiration_value Yes Transaction expiration value. The block-height or time when the transaction should expire str memo Yes Transaction memo int fee No Transaction fee","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_39","text":"<class 'solar_crypto.transactions.builder.htlc_lock.HtlcLock'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#get_type_group_2","text":"def get_type_group ( self ): Get the type group of the Transaction.","title":"get_type_group()"},{"location":"sdk/python/crypto/api-documentation/#return-value_40","text":"<class 'int'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsbuilderhtlc_refundhtlcrefund","text":"","title":"crypto.transactions.builder.htlc_refund.HtlcRefund"},{"location":"sdk/python/crypto/api-documentation/#__init___6","text":"def __init__ ( self , lock_transaction_id , fee = None ): Create a new HtlcRefund transaction instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_30","text":"Type Name Required Description str lock_transaction_id Yes HTLC Lock transaction id int fee No Transaction fee","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_41","text":"<class 'solar_crypto.transactions.builder.htlc_refund.HtlcRefund'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#get_type_group_3","text":"def get_type_group ( self ): Get the type group of the Transaction.","title":"get_type_group()"},{"location":"sdk/python/crypto/api-documentation/#return-value_42","text":"<class 'int'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsbuilderipfsipfs","text":"","title":"crypto.transactions.builder.ipfs.IPFS"},{"location":"sdk/python/crypto/api-documentation/#__init___7","text":"def __init__ ( self , ipfs_cid = None , fee = None ): Create a new IPFS transaction instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_31","text":"Type Name Required Description str ipfs_cid No Content identifier int fee No Transaction fee","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_43","text":"<class 'solar_crypto.transactions.builder.ipfs.IPFS'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#get_type_group_4","text":"def get_type_group ( self ): Get the type group of the Transaction.","title":"get_type_group()"},{"location":"sdk/python/crypto/api-documentation/#return-value_44","text":"<class 'int'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#set_ipfs_cid","text":"set_ipfs_cid ( self , cid : str ): Set the content identifier of the Transaction.","title":"set_ipfs_cid()"},{"location":"sdk/python/crypto/api-documentation/#parameters_32","text":"Type Name Required Description str cid Yes Content identifier","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_45","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsbuildertransfertransfer","text":"","title":"crypto.transactions.builder.transfer.Transfer"},{"location":"sdk/python/crypto/api-documentation/#__init___8","text":"def __init__ ( self , memo = None , fee = None ): Create a new Transfer transaction instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_33","text":"Type Name Required Description str memo No Transaction memo int fee No Transaction fee","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_46","text":"<class 'solar_crypto.transactions.builder.transfer.Transfer'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#get_type_group_5","text":"def get_type_group ( self ): Get the type group of the Transaction.","title":"get_type_group()"},{"location":"sdk/python/crypto/api-documentation/#return-value_47","text":"<class 'int'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#add_transfer","text":"def add_transfer ( self , amount , recipient_id ): Add a transfer to the Transfers array of a Transaction.","title":"add_transfer()"},{"location":"sdk/python/crypto/api-documentation/#parameters_34","text":"Type Name Required Description int amount Yes Transaction amount string recipient_id Yes Transaction recipient","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_48","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsbuildermulti_signature_registrationmultisignatureregistration","text":"","title":"crypto.transactions.builder.multi_signature_registration.MultiSignatureRegistration"},{"location":"sdk/python/crypto/api-documentation/#__init___9","text":"def __init__ ( self , fee = None ): Create a new MultiSignatureRegistration transaction instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_35","text":"Type Name Required Description int fee No Transaction fee","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_49","text":"<class 'solar_crypto.transactions.builder.multi_signature_registration.MultiSignatureRegistration'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#set_min","text":"def set_min ( self , minimum_participants ): Set the minimum amount of participants of a Transaction.","title":"set_min()"},{"location":"sdk/python/crypto/api-documentation/#parameters_36","text":"Type Name Required Description int minimum_participants Yes Transaction minimum participants","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_50","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#set_public_keys","text":"def set_public_keys ( self , public_keys ): Set the public keys of a Transaction.","title":"set_public_keys()"},{"location":"sdk/python/crypto/api-documentation/#parameters_37","text":"Type Name Required Description list public_keys Yes Transaction public keys participants","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_51","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#add_participant","text":"def add_participant ( self , public_key ): Add a participant with his public key to the Transaction.","title":"add_participant()"},{"location":"sdk/python/crypto/api-documentation/#parameters_38","text":"Type Name Required Description str public_key Yes Participant public key","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_52","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsbuildersecond_signature_registrationsecondsignatureregistration","text":"","title":"crypto.transactions.builder.second_signature_registration.SecondSignatureRegistration"},{"location":"sdk/python/crypto/api-documentation/#__init___10","text":"def __init__ ( self , second_passphrase , fee = None ): Create a new SecondSignatureRegistration transaction instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_39","text":"Type Name Required Description str second_passphrase No Second passphrase int fee No Transaction fee","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_53","text":"<class 'solar_crypto.transactions.builder.second_signature_registration.SecondSignatureRegistration'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsbuilderlegacy_transferlegacytransfer","text":"","title":"crypto.transactions.builder.legacy_transfer.LegacyTransfer"},{"location":"sdk/python/crypto/api-documentation/#__init___11","text":"def __init__ ( self , recipientId , amount , memo = None , fee = None ): Create a new Legacy Transfer transaction instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_40","text":"Type Name Required Description str recipientId Yes Recipient identifier int amount Yes Transaction amount str memo No Transaction memo int fee No Transaction fee","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_54","text":"<class 'solar_crypto.transactions.builder.legacy_transfer.LegacyTransfer'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsbuilderlegacy_votelegacyvote","text":"","title":"crypto.transactions.builder.legacy_vote.LegacyVote"},{"location":"sdk/python/crypto/api-documentation/#__init___12","text":"def __init__ ( self , vote = None , fee = None ): Create a new Legacy Vote transaction instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_41","text":"Type Name Required Description str vote No Delegate address to vote for int fee No Transaction fee","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_55","text":"<class 'solar_crypto.transactions.builder.legacy_vote.LegacyVote'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#set_votes","text":"def set_votes ( self , votes : typing . List [ str ]): Set legacy votes/cancel vote","title":"set_votes()"},{"location":"sdk/python/crypto/api-documentation/#parameters_42","text":"Type Name Required Description List[str] votes Yes list of votes","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_56","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#sign_3","text":"def sign ( self , passphrase ): Sign the transaction using the given passphrase","title":"sign()"},{"location":"sdk/python/crypto/api-documentation/#parameters_43","text":"Type Name Required Description str passphrase Yes Passphrase","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_57","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsbuildervotevote","text":"","title":"crypto.transactions.builder.vote.Vote"},{"location":"sdk/python/crypto/api-documentation/#__init___13","text":"def __init__ ( self ): Create a new Vote transaction instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#return-value_58","text":"<class 'solar_crypto.transactions.builder.vote.Vote'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#set_votes_1","text":"def set_votes ( self , votes : typing . Union [ typing . List [ str ], typing . Dict [ str , typing . Union [ int , float , Decimal ]]] = dict ): Set votes","title":"set_votes()"},{"location":"sdk/python/crypto/api-documentation/#parameters_44","text":"Type Name Required Description votes votes Yes list of votes","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_59","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializersbasebasedeserializer","text":"","title":"crypto.transactions.deserializers.base.BaseDeserializer"},{"location":"sdk/python/crypto/api-documentation/#__init___14","text":"def __init__ ( self , serialized , asset_offset , transaction ): Create a new deserializer instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_45","text":"Type Name Required Description ??? serialized Yes Serialized ??? asset_offset Yes Offset ??? transaction Yes Transaction","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_60","text":"<class 'solar_crypto.transactions.deserializers.base.BaseDeserializer'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#deserialize","text":"def deserialize ( self ): Handle the deserialization of transaction data","title":"deserialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_61","text":"NotImplementedError","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializersburnburndeserializer","text":"","title":"crypto.transactions.deserializers.burn.BurnDeserializer"},{"location":"sdk/python/crypto/api-documentation/#deserialize_1","text":"def deserialize ( self ): Handle the deserialization of \"burn\" data","title":"deserialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_62","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializersdelegate_registrationdelegateregistrationdeserializer","text":"","title":"crypto.transactions.deserializers.delegate_registration.DelegateRegistrationDeserializer"},{"location":"sdk/python/crypto/api-documentation/#deserialize_2","text":"def deserialize ( self ): Handle the deserialization of \"delegate registration\" data","title":"deserialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_63","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializersdelegate_resignationdelegateresignationdeserializer","text":"","title":"crypto.transactions.deserializers.delegate_resignation.DelegateResignationDeserializer"},{"location":"sdk/python/crypto/api-documentation/#deserialize_3","text":"def deserialize ( self ): Handle the deserialization of \"delegate resignation\" data","title":"deserialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_64","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializershtlc_claimhtlcclaimdeserializer","text":"","title":"crypto.transactions.deserializers.htlc_claim.HtlcClaimDeserializer"},{"location":"sdk/python/crypto/api-documentation/#deserialize_4","text":"def deserialize ( self ): Handle the deserialization of \"HTLC Claim\" data","title":"deserialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_65","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializershtlc_lockhtlclockdeserializer","text":"","title":"crypto.transactions.deserializers.htlc_lock.HtlcLockDeserializer"},{"location":"sdk/python/crypto/api-documentation/#deserialize_5","text":"def deserialize ( self ): Handle the deserialization of \"HTLC Lock\" data","title":"deserialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_66","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializershtlc_refundhtlcrefunddeserializer","text":"","title":"crypto.transactions.deserializers.htlc_refund.HtlcRefundDeserializer"},{"location":"sdk/python/crypto/api-documentation/#deserialize_6","text":"def deserialize ( self ): Handle the deserialization of \"HTLC refund\" data","title":"deserialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_67","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializersipfsipfsdeserializer","text":"","title":"crypto.transactions.deserializers.ipfs.IPFSDeserializer"},{"location":"sdk/python/crypto/api-documentation/#deserialize_7","text":"def deserialize ( self ): Handle the deserialization of \"IPFS\" data","title":"deserialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_68","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializerstransfertransferdeserializer","text":"","title":"crypto.transactions.deserializers.transfer.TransferDeserializer"},{"location":"sdk/python/crypto/api-documentation/#deserialize_8","text":"def deserialize ( self ): Handle the deserialization of \"transfer\" data","title":"deserialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_69","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializersmulti_signature_registrationmultisignatureregistrationdeserializer","text":"","title":"crypto.transactions.deserializers.multi_signature_registration.MultiSignatureRegistrationDeserializer"},{"location":"sdk/python/crypto/api-documentation/#deserialize_9","text":"def deserialize ( self ): Handle the deserialization of \"multi signature registration\" data","title":"deserialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_70","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializerssecond_signature_registrationsecondsignatureregistrationdeserializer","text":"","title":"crypto.transactions.deserializers.second_signature_registration.SecondSignatureRegistrationDeserializer"},{"location":"sdk/python/crypto/api-documentation/#deserialize_10","text":"def deserialize ( self ): Handle the deserialization of \"second signature\" data.","title":"deserialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_71","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializerslegacy_transferlegacytransferdeserializer","text":"","title":"crypto.transactions.deserializers.legacy_transfer.LegacyTransferDeserializer"},{"location":"sdk/python/crypto/api-documentation/#deserialize_11","text":"def deserialize ( self ): Handle the deserialization of \"legacy transfer\" data","title":"deserialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_72","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializerslegacy_votelegacyvotedeserializer","text":"","title":"crypto.transactions.deserializers.legacy_vote.LegacyVoteDeserializer"},{"location":"sdk/python/crypto/api-documentation/#deserialize_12","text":"def deserialize ( self ): Handle the deserialization of \"legacy vote\" data.","title":"deserialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_73","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializersvotevotedeserializer","text":"","title":"crypto.transactions.deserializers.vote.VoteDeserializer"},{"location":"sdk/python/crypto/api-documentation/#deserialize_13","text":"def deserialize ( self ): Handle the deserialization of \"vote\" data.","title":"deserialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_74","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializersbasebaseserializer","text":"","title":"crypto.transactions.serializers.base.BaseSerializer"},{"location":"sdk/python/crypto/api-documentation/#__init___15","text":"def __init__ ( self , transaction , byte_data = bytes ()): Create a new serializer instance","title":"__init__()"},{"location":"sdk/python/crypto/api-documentation/#parameters_46","text":"Type Name Required Description Transaction transaction Yes Transaction bytes byte_data No ...","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_75","text":"<class 'solar_crypto.transactions.serializers.base.BaseSerializer'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#serialize","text":"def serialize ( self ): Handle the serialization of transaction data","title":"serialize"},{"location":"sdk/python/crypto/api-documentation/#return-value_76","text":"NotImplementedError","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializersburnburnserializer","text":"","title":"crypto.transactions.serializers.burn.BurnSerializer"},{"location":"sdk/python/crypto/api-documentation/#serialize_1","text":"def serialize ( self ): Handle the serialization of \"burn\" data","title":"serialize"},{"location":"sdk/python/crypto/api-documentation/#return-value_77","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializersdelegate_registrationdelegateregistrationserializer","text":"","title":"crypto.transactions.serializers.delegate_registration.DelegateRegistrationSerializer"},{"location":"sdk/python/crypto/api-documentation/#serialize_2","text":"def serialize ( self ): Handle the serialization of \"delegate registration\" data","title":"serialize"},{"location":"sdk/python/crypto/api-documentation/#return-value_78","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializersdelegate_resignationdelegateresignationserializer","text":"","title":"crypto.transactions.serializers.delegate_resignationDelegateResignationSerializer"},{"location":"sdk/python/crypto/api-documentation/#serialize_3","text":"def serialize ( self ): Handle the serialization of \"delegate resignation\" data","title":"serialize"},{"location":"sdk/python/crypto/api-documentation/#return-value_79","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializershtlc_claimhtlcclaimserializer","text":"","title":"crypto.transactions.serializers.htlc_claim.HtlcClaimSerializer"},{"location":"sdk/python/crypto/api-documentation/#serialize_4","text":"def serialize ( self ): Handle the serialization of \"HTLC Claim\" data","title":"serialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_80","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializershtlc_lockhtlclockserializer","text":"","title":"crypto.transactions.serializers.htlc_lock.HtlcLockSerializer"},{"location":"sdk/python/crypto/api-documentation/#serialize_5","text":"def serialize ( self ): Handle the serialization of \"HTLC Lock\" data","title":"serialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_81","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializershtlc_refundhtlcrefundserializer","text":"","title":"crypto.transactions.serializers.htlc_refund.HtlcRefundSerializer"},{"location":"sdk/python/crypto/api-documentation/#serialize_6","text":"def serialize ( self ): Handle the serialization of \"HTLC Refund\" data","title":"serialize()"},{"location":"sdk/python/crypto/api-documentation/#return-value_82","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializersipfsipfsserializer","text":"","title":"crypto.transactions.serializers.ipfs.IPFSSerializer"},{"location":"sdk/python/crypto/api-documentation/#serialize_7","text":"def serialize ( self ): Handle the serialization of \"ipfs\" data","title":"serialize"},{"location":"sdk/python/crypto/api-documentation/#return-value_83","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializerstransfertransferserializer","text":"","title":"crypto.transactions.serializers.transfer.TransferSerializer"},{"location":"sdk/python/crypto/api-documentation/#serialize_8","text":"def serialize ( self ): Handle the serialization of \"transfer\" data","title":"serialize"},{"location":"sdk/python/crypto/api-documentation/#return-value_84","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializersmulti_signature_registrationmultisignatureserializer","text":"","title":"crypto.transactions.serializers.multi_signature_registration.MultiSignatureSerializer"},{"location":"sdk/python/crypto/api-documentation/#serialize_9","text":"def serialize ( self ): Handle the serialization of \"multi signature\" data","title":"serialize"},{"location":"sdk/python/crypto/api-documentation/#return-value_85","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializerssecond_signature_registrationsecondsignatureregistrationserializer","text":"","title":"crypto.transactions.serializers.second_signature_registration.SecondSignatureRegistrationSerializer"},{"location":"sdk/python/crypto/api-documentation/#serialize_10","text":"def serialize ( self ): Handle the serialization of \"second signature\" data","title":"serialize"},{"location":"sdk/python/crypto/api-documentation/#return-value_86","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializerslegacy_transferlegacytransferserializer","text":"","title":"crypto.transactions.serializers.legacy_transfer.LegacyTransferSerializer"},{"location":"sdk/python/crypto/api-documentation/#serialize_11","text":"def serialize ( self ): Handle the serialization of \"legacy transfer\" data","title":"serialize"},{"location":"sdk/python/crypto/api-documentation/#return-value_87","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializerslegacy_votelegacyvoteserializer","text":"","title":"crypto.transactions.serializers.legacy_vote.LegacyVoteSerializer"},{"location":"sdk/python/crypto/api-documentation/#serialize_12","text":"def serialize ( self ): Handle the serialization of \"legacy vote\" data","title":"serialize"},{"location":"sdk/python/crypto/api-documentation/#return-value_88","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializersvotevoteserializer","text":"","title":"crypto.transactions.serializers.vote.VoteSerializer"},{"location":"sdk/python/crypto/api-documentation/#serialize_13","text":"def serialize ( self ): Handle the serialization of \"vote\" data","title":"serialize"},{"location":"sdk/python/crypto/api-documentation/#return-value_89","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsdeserializerdeserializer","text":"","title":"crypto.transactions.deserializer.Deserializer"},{"location":"sdk/python/crypto/api-documentation/#__init___16","text":"def __init__ ( self , serialized ): Create a new deserializer instance","title":"__init__"},{"location":"sdk/python/crypto/api-documentation/#parameters_47","text":"Type Name Required Description str serialized Yes Serialized","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_90","text":"<class 'solar_crypto.transactions.deserializer.Deserializer'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#deserialize_14","text":"def deserialize ( self ): Perform AIP11 compliant deserialization","title":"deserialize"},{"location":"sdk/python/crypto/api-documentation/#return-value_91","text":"<class 'solar_crypto.transactions.transaction.Transaction'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#_handle_transaction_type","text":"def _handle_transaction_type ( self , asset_offset , transaction ): Handle the deserialization of transaction data","title":"_handle_transaction_type"},{"location":"sdk/python/crypto/api-documentation/#parameters_48","text":"Type Name Required Description int asset_offset Yes Offset transaction.Transaction transaction Yes Transaction","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_92","text":"<class 'solar_crypto.transactions.transaction.Transaction'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionsserializerserializer","text":"","title":"crypto.transactions.serializer.Serializer"},{"location":"sdk/python/crypto/api-documentation/#__init___17","text":"def __init__ ( self , transaction ): Create a new serializer instance","title":"__init__"},{"location":"sdk/python/crypto/api-documentation/#parameters_49","text":"Type Name Required Description transaction.Transaction transaction Yes Transaction","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_93","text":"<class 'solar_crypto.transactions.serializer.Serializer'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#serialize_14","text":"def serialize ( self , skip_signature = True , skip_second_signature = True , skip_multi_signature = True , raw = False ): Perform AIP11 compliant serialization","title":"serialize"},{"location":"sdk/python/crypto/api-documentation/#parameters_50","text":"Type Name Required Description bool skip_signature No Should we skip the serialization of the signature bool skip_second_signature No Should we skip the serialization of the second signature bool skip_multi_signature No Should we skip the serialization of multiple signatures bool raw No Raw output","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_94","text":"<class 'str'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#_handle_transaction_type_1","text":"def _handle_transaction_type ( self , bytes_data ): Handle the serialization of transaction data","title":"_handle_transaction_type"},{"location":"sdk/python/crypto/api-documentation/#parameters_51","text":"Type Name Required Description bytes bytes_data Yes ...","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_95","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#_handle_signature","text":"def _handle_signature ( self , bytes_data , skip_signature , skip_second_signature , skip_multi_signature ): Handle the serialization of \"signatures\" data","title":"_handle_signature"},{"location":"sdk/python/crypto/api-documentation/#parameters_52","text":"Type Name Required Description bytes bytes_data Yes ... bool skip_signature Yes Should we skip the serialization of the signature bool skip_second_signature Yes Should we skip the serialization of the second signature bool skip_multi_signature Yes Should we skip the serialization of multiple signatures","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_96","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptotransactionstransactiontransaction","text":"","title":"crypto.transactions.transaction.Transaction"},{"location":"sdk/python/crypto/api-documentation/#__init___18","text":"def __init__ ( self , * args , ** kwargs ): Create a new transaction instance","title":"__init__"},{"location":"sdk/python/crypto/api-documentation/#parameters_53","text":"Type Name Required Description any *args No ... any **kwargs No ...","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_97","text":"<class 'solar_crypto.transactions.transaction.Transaction'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#get_id","text":"def get_id ( self ): Convert the byte representation to a unique identifier","title":"get_id"},{"location":"sdk/python/crypto/api-documentation/#return-value_98","text":"<class 'str'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#to_dict_1","text":"def to_dict ( self ): Convert the transaction to its dictionary representation.","title":"to_dict"},{"location":"sdk/python/crypto/api-documentation/#return-value_99","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#to_json_1","text":"def to_json ( self ): Convert the transaction to its JSON representation","title":"to_json"},{"location":"sdk/python/crypto/api-documentation/#return-value_100","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#to_bytes","text":"def to_bytes ( self , skip_signature = True , skip_second_signature = True , skip_multi_signature = True ): Convert the transaction to its byte representation","title":"to_bytes"},{"location":"sdk/python/crypto/api-documentation/#parameters_54","text":"Type Name Required Description bool skip_signature Yes Skip first signature bool skip_second_signature Yes Skip second signature bool skip_multi_signature Yes Skip multi signatures","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_101","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#parse_signatures","text":"def parse_signatures ( self , serialized , start_offset ): Parse the signature, second signature and multi signatures","title":"parse_signatures"},{"location":"sdk/python/crypto/api-documentation/#parameters_55","text":"Type Name Required Description str serialized Yes Serialized int start_offset Yes Offset","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_102","text":"<class 'NoneType'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#serialize_15","text":"def serialize ( self , skip_signature = True , skip_second_signature = True , skip_multi_signature = True ): Perform AIP11 compliant serialization","title":"serialize"},{"location":"sdk/python/crypto/api-documentation/#parameters_56","text":"Type Name Required Description bool skip_signature Yes Skip first signature bool skip_second_signature Yes Skip second signature bool skip_multi_signature Yes Skip multi signatures","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_103","text":"<class 'str'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#deserialize_15","text":"def deserialize ( self , serialized ): Perform AIP11 compliant deserialization","title":"deserialize"},{"location":"sdk/python/crypto/api-documentation/#parameters_57","text":"Type Name Required Description str serialized Yes Serialized","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_104","text":"<class 'str'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#verify_1","text":"def verify ( self ): Verify the transaction. Method will raise an exception if invalid, if it's valid it will returns True","title":"verify"},{"location":"sdk/python/crypto/api-documentation/#return-value_105","text":"<class 'bool'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#verify_secondsig","text":"def verify_secondsig ( self , secondPublicKey ): Verify the second signature. Method will raise an exception if invalid, if it's valid it will returns True","title":"verify_secondsig"},{"location":"sdk/python/crypto/api-documentation/#parameters_58","text":"Type Name Required Description str secondPublicKey Yes Second public key","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_106","text":"<class 'bool'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#verify_signatures","text":"def verify_signatures ( self , multi_signature_asset ): Verify the multisignatures transaction. Method will raise an exception if invalid, it will returns True","title":"verify_signatures"},{"location":"sdk/python/crypto/api-documentation/#parameters_59","text":"Type Name Required Description dict multi_signature_asset Yes Multisignature asset","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_107","text":"<class 'bool'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#_handle_transaction_type_2","text":"def _handle_transaction_type ( self , bytes_data ): Handle each transaction type differently","title":"_handle_transaction_type"},{"location":"sdk/python/crypto/api-documentation/#parameters_60","text":"Type Name Required Description bytes bytes_data Yes Input the bytes data to which you want to append new bytes","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_108","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#_handle_signature_1","text":"def _handle_signature ( self , bytes_data , skip_signature , skip_second_signature , skip_multi_signature ): Handle the serialization of \"signatures\" data","title":"_handle_signature"},{"location":"sdk/python/crypto/api-documentation/#parameters_61","text":"Type Name Required Description bytes bytes_data Yes Input the bytes data to which you want to append new bytes from signature bool skip_signature Yes Skip first signature bool skip_second_signature Yes Skip second signature bool skip_multi_signature Yes Skip multi signatures","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_109","text":"<class 'bytes'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptoutilscrypto","text":"","title":"crypto.utils.crypto"},{"location":"sdk/python/crypto/api-documentation/#sign_schnorr","text":"def sign_schnorr ( msg : bytes , private_key : PrivateKey , nonce : int = None ) -> str : Signs a message using Schnorr BIP340 and returns a hex string of the signature","title":"sign_schnorr"},{"location":"sdk/python/crypto/api-documentation/#parameters_62","text":"Type Name Required Description bytes msg Yes Message to be signed PrivateKey private_key Yes Private key object int nonce No Deterministic nonce","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_110","text":"<class 'str'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#sign_schnorr_legacy","text":"def sign_schnorr_legacy ( msg : bytes , private_key : PrivateKey ) -> str : Signs a message using Legacy Schnorr and returns a hex string of the signature","title":"sign_schnorr_legacy"},{"location":"sdk/python/crypto/api-documentation/#parameters_63","text":"Type Name Required Description bytes msg Yes Message to be signed PrivateKey private_key Yes Private key object int nonce No Deterministic nonce","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_111","text":"<class 'str'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#verify_schnorr","text":"def verify_schnorr ( msg : bytes , public_key : str , signature : str ) -> bool : Verifies a message using Schnorr BIP340","title":"verify_schnorr"},{"location":"sdk/python/crypto/api-documentation/#parameters_64","text":"Type Name Required Description bytes msg Yes Message to be verified str public_key Yes Public key str signature Yes Signature","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_112","text":"<class 'bool'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#verify_schnorr_legacy","text":"def verify_schnorr_legacy ( msg : bytes , public_key : str , signature : str ) -> bool : Verifies a message using Legacy Schnorr","title":"verify_schnorr_legacy"},{"location":"sdk/python/crypto/api-documentation/#parameters_65","text":"Type Name Required Description bytes msg Yes Message to be verified str public_key Yes Public key str signature Yes Signature","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_113","text":"<class 'bool'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptoutilsmessagemessage","text":"","title":"crypto.utils.message.Message"},{"location":"sdk/python/crypto/api-documentation/#__init___19","text":"def __init__ ( self , ** kwargs ): Create a new message instance","title":"__init__"},{"location":"sdk/python/crypto/api-documentation/#parameters_66","text":"Type Name Required Description any **kwargs No ...","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_114","text":"<class 'solar_crypto.utils.message.Message'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#sign_4","text":"def sign ( cls , message , passphrase ): Sign a message using the given passphrase","title":"sign"},{"location":"sdk/python/crypto/api-documentation/#parameters_67","text":"Type Name Required Description str message Yes Message str passphrase Yes Passphrase","title":"Parameters"},{"location":"sdk/python/crypto/api-documentation/#return-value_115","text":"<class 'solar_crypto.utils.message.Message'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#verify_2","text":"def verify ( self ): Verify the message contents","title":"verify"},{"location":"sdk/python/crypto/api-documentation/#return-value_116","text":"<class 'bool'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#to_dict_2","text":"def to_dict ( self ): Convert the message to its dictionary representation","title":"to_dict"},{"location":"sdk/python/crypto/api-documentation/#return-value_117","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#to_json_2","text":"def to_json ( self ): Convert the message to its JSON representation","title":"to_json"},{"location":"sdk/python/crypto/api-documentation/#return-value_118","text":"<class 'dict'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#cryptoutilsslot","text":"","title":"crypto.utils.slot"},{"location":"sdk/python/crypto/api-documentation/#get_time","text":"def get_time (): Get the time diff between now and network start","title":"get_time"},{"location":"sdk/python/crypto/api-documentation/#return-value_119","text":"<class 'int'>","title":"Return Value"},{"location":"sdk/python/crypto/api-documentation/#get_epoch","text":"def get_epoch (): Get the network start epoch","title":"get_epoch"},{"location":"sdk/python/crypto/api-documentation/#return-value_120","text":"<class 'datetime'>","title":"Return Value"},{"location":"sdk/python/crypto/examples/","text":"Examples \u00b6 Initialization \u00b6 from solar_crypto.transactions.builder.transfer import Transfer The transaction object used for this section: tx = { 'amount' : int , 'asset' : dict , 'fee' : int , 'id' : str , 'network' : int , 'recipientId' : str , 'secondSignature' : str , 'senderPublicKey' : str , 'signature' : str , 'signatures' : list , 'signSignature' : str , 'nonce' : int , 'type' : int , 'typeGroup' : int , 'memo' : str , 'version' : int , 'lockTransactionId' : str , 'lockSecret' : str , 'expiration' : int , } Transactions \u00b6 A transaction is an object specifying the transfer of funds from the sender's wallet to the recipient's. Each transaction must be signed by the sender's private key to prove authenticity and origin. After broadcasting through the client SDK , a transaction is permanently incorporated in the blockchain by a Delegate Node. Sign \u00b6 The crypto SDK can sign a transaction using your private key or passphrase (from which the private key is generated). Ensure you are familiar with digital signatures before using the crypto SDKs. For serializing and deserializing, we must require the Transaction model: from solar_crypto.transactions.transaction import Transaction # Serializing transaction = Transaction ( ** tx ) transaction . serialize () # Deserializing transaction = Transaction () transaction . deserialize ( ** tx [ 'serialized' ]) Using the Transaction builder class. transaction = Transfer ( recipientId = str , amount = int ) transaction . sign ( 'seedPass' ) Serialize (AIP11) \u00b6 Serialization of a transaction object ensures it is compact and properly formatted to be incorporated in the SXP blockchain. If you are using the crypto SDK in combination with the public API SDK, you should not need to serialize manually. from solar_crypto.transactions.serializer import Serializer serialized_transaction = Serializer ( tx ) . serialize () >>> < class ' str '> Deserialize (AIP11) \u00b6 A serialized transaction may be deserialized for inspection purposes. The public API does not return serialized transactions, so you should only need to deserialize in exceptional circumstances. from solar_crypto.transactions.deserializer import Deserializer transaction_data = Deserializer ( serialized_data ) . deserialize () >>> < class ' solar_crypto . transactions . transaction . Transaction '> Message \u00b6 The crypto SDK not only supports transactions but can also work with other arbitrary data (expressed as strings). Sign \u00b6 Signing a string works much like signing a transaction: in most implementations, the message is hashed, and the resulting hash is signed using the private key or passphrase . from solar_crypto.utils.message import Message message = Message . sign ( string , 'validSeedPass' ) >>> < class ' solar_crypto . utils . message . Message '> Verify \u00b6 A message's signature can easily be verified by hash, without the private key that signed the message, by using the verify method. from solar_crypto.utils.message import Message message = Message ( message = str , signature = str , publicKey = str ) message . verify () >>> < class ' bool '> Identities \u00b6 The identities class allows for the creation and inspection of keyPairs from passphrases . Here you find vital functions when creating transactions and managing wallets. Derive the Address from a Passphrase \u00b6 from solar_crypto.identity.address import address_from_passphrase address_from_passphrase ( 'validSeedPass' ) >>> < class ' str '> Derive the Address from a Public Key \u00b6 from solar_crypto.identity.address import address_from_public_key address_from_public_key ( 'validPublicKey' ) >>> < class ' str '> Derive the Address from a Private Key \u00b6 from solar_crypto.identity.address import address_from_private_key address_from_private_key ( 'validPrivateKey' ) >>> < class ' str '> Validate an Address \u00b6 from solar_crypto.identity.address import validate_address validate_address ( 'validAddress' ) >>> < class ' bool '> Private Key \u00b6 As the name implies, private keys and passphrases are to remain private. Never store these unencrypted and minimize access to these secrets Derive the Private Key from a Passphrase \u00b6 from solar_crypto.identity.private_key import PrivateKey private_key = PrivateKey . from_passphrase ( 'validSeedPass' ) . to_hex () >>> < class ' str '> Derive the Private Key Instance Object from a Hexadecimal Encoded String \u00b6 from solar_crypto.identity.private_key import PrivateKey private_key = PrivateKey . from_hex ( str ) >>> < class ' solar_crypto . identity . private_key . PrivateKey '> Derive the Private Key from a WIF \u00b6 This function has not been implemented in this client library . Public Key \u00b6 Public Keys may be freely shared, and are included in transaction objects to validate the authenticity. Derive the Public Key from a Passphrase \u00b6 from solar_crypto.identity.public_key import PublicKey public_key = PublicKey . from_passphrase ( 'this is a top secret passphrase' ) >>> < class ' str '> Derive the Public Key Instance Object from a Hexadecimal Encoded String \u00b6 from solar_crypto.identity.public_key import PublicKey public_key = PublicKey . from_hex ( str ) >>> < class ' solar_crypto . identity . public_key . PublicKey '> Validate a Public Key \u00b6 This function has not been implemented in this client library . WIF \u00b6 The WIF should remain secret, just like your passphrase and private key . Derive the WIF from a Passphrase \u00b6 from solar_crypto.identity.wif import wif_from_passphrase wif = wif_from_passphrase ( 'validSeedPass' ) >>> < class ' str '>","title":"Examples"},{"location":"sdk/python/crypto/examples/#examples","text":"","title":"Examples"},{"location":"sdk/python/crypto/examples/#initialization","text":"from solar_crypto.transactions.builder.transfer import Transfer The transaction object used for this section: tx = { 'amount' : int , 'asset' : dict , 'fee' : int , 'id' : str , 'network' : int , 'recipientId' : str , 'secondSignature' : str , 'senderPublicKey' : str , 'signature' : str , 'signatures' : list , 'signSignature' : str , 'nonce' : int , 'type' : int , 'typeGroup' : int , 'memo' : str , 'version' : int , 'lockTransactionId' : str , 'lockSecret' : str , 'expiration' : int , }","title":"Initialization"},{"location":"sdk/python/crypto/examples/#transactions","text":"A transaction is an object specifying the transfer of funds from the sender's wallet to the recipient's. Each transaction must be signed by the sender's private key to prove authenticity and origin. After broadcasting through the client SDK , a transaction is permanently incorporated in the blockchain by a Delegate Node.","title":"Transactions"},{"location":"sdk/python/crypto/examples/#sign","text":"The crypto SDK can sign a transaction using your private key or passphrase (from which the private key is generated). Ensure you are familiar with digital signatures before using the crypto SDKs. For serializing and deserializing, we must require the Transaction model: from solar_crypto.transactions.transaction import Transaction # Serializing transaction = Transaction ( ** tx ) transaction . serialize () # Deserializing transaction = Transaction () transaction . deserialize ( ** tx [ 'serialized' ]) Using the Transaction builder class. transaction = Transfer ( recipientId = str , amount = int ) transaction . sign ( 'seedPass' )","title":"Sign"},{"location":"sdk/python/crypto/examples/#serialize-aip11","text":"Serialization of a transaction object ensures it is compact and properly formatted to be incorporated in the SXP blockchain. If you are using the crypto SDK in combination with the public API SDK, you should not need to serialize manually. from solar_crypto.transactions.serializer import Serializer serialized_transaction = Serializer ( tx ) . serialize () >>> < class ' str '>","title":"Serialize (AIP11)"},{"location":"sdk/python/crypto/examples/#deserialize-aip11","text":"A serialized transaction may be deserialized for inspection purposes. The public API does not return serialized transactions, so you should only need to deserialize in exceptional circumstances. from solar_crypto.transactions.deserializer import Deserializer transaction_data = Deserializer ( serialized_data ) . deserialize () >>> < class ' solar_crypto . transactions . transaction . Transaction '>","title":"Deserialize (AIP11)"},{"location":"sdk/python/crypto/examples/#message","text":"The crypto SDK not only supports transactions but can also work with other arbitrary data (expressed as strings).","title":"Message"},{"location":"sdk/python/crypto/examples/#sign_1","text":"Signing a string works much like signing a transaction: in most implementations, the message is hashed, and the resulting hash is signed using the private key or passphrase . from solar_crypto.utils.message import Message message = Message . sign ( string , 'validSeedPass' ) >>> < class ' solar_crypto . utils . message . Message '>","title":"Sign"},{"location":"sdk/python/crypto/examples/#verify","text":"A message's signature can easily be verified by hash, without the private key that signed the message, by using the verify method. from solar_crypto.utils.message import Message message = Message ( message = str , signature = str , publicKey = str ) message . verify () >>> < class ' bool '>","title":"Verify"},{"location":"sdk/python/crypto/examples/#identities","text":"The identities class allows for the creation and inspection of keyPairs from passphrases . Here you find vital functions when creating transactions and managing wallets.","title":"Identities"},{"location":"sdk/python/crypto/examples/#derive-the-address-from-a-passphrase","text":"from solar_crypto.identity.address import address_from_passphrase address_from_passphrase ( 'validSeedPass' ) >>> < class ' str '>","title":"Derive the Address from a Passphrase"},{"location":"sdk/python/crypto/examples/#derive-the-address-from-a-public-key","text":"from solar_crypto.identity.address import address_from_public_key address_from_public_key ( 'validPublicKey' ) >>> < class ' str '>","title":"Derive the Address from a Public Key"},{"location":"sdk/python/crypto/examples/#derive-the-address-from-a-private-key","text":"from solar_crypto.identity.address import address_from_private_key address_from_private_key ( 'validPrivateKey' ) >>> < class ' str '>","title":"Derive the Address from a Private Key"},{"location":"sdk/python/crypto/examples/#validate-an-address","text":"from solar_crypto.identity.address import validate_address validate_address ( 'validAddress' ) >>> < class ' bool '>","title":"Validate an Address"},{"location":"sdk/python/crypto/examples/#private-key","text":"As the name implies, private keys and passphrases are to remain private. Never store these unencrypted and minimize access to these secrets","title":"Private Key"},{"location":"sdk/python/crypto/examples/#derive-the-private-key-from-a-passphrase","text":"from solar_crypto.identity.private_key import PrivateKey private_key = PrivateKey . from_passphrase ( 'validSeedPass' ) . to_hex () >>> < class ' str '>","title":"Derive the Private Key from a Passphrase"},{"location":"sdk/python/crypto/examples/#derive-the-private-key-instance-object-from-a-hexadecimal-encoded-string","text":"from solar_crypto.identity.private_key import PrivateKey private_key = PrivateKey . from_hex ( str ) >>> < class ' solar_crypto . identity . private_key . PrivateKey '>","title":"Derive the Private Key Instance Object from a Hexadecimal Encoded String"},{"location":"sdk/python/crypto/examples/#derive-the-private-key-from-a-wif","text":"This function has not been implemented in this client library .","title":"Derive the Private Key from a WIF"},{"location":"sdk/python/crypto/examples/#public-key","text":"Public Keys may be freely shared, and are included in transaction objects to validate the authenticity.","title":"Public Key"},{"location":"sdk/python/crypto/examples/#derive-the-public-key-from-a-passphrase","text":"from solar_crypto.identity.public_key import PublicKey public_key = PublicKey . from_passphrase ( 'this is a top secret passphrase' ) >>> < class ' str '>","title":"Derive the Public Key from a Passphrase"},{"location":"sdk/python/crypto/examples/#derive-the-public-key-instance-object-from-a-hexadecimal-encoded-string","text":"from solar_crypto.identity.public_key import PublicKey public_key = PublicKey . from_hex ( str ) >>> < class ' solar_crypto . identity . public_key . PublicKey '>","title":"Derive the Public Key Instance Object from a Hexadecimal Encoded String"},{"location":"sdk/python/crypto/examples/#validate-a-public-key","text":"This function has not been implemented in this client library .","title":"Validate a Public Key"},{"location":"sdk/python/crypto/examples/#wif","text":"The WIF should remain secret, just like your passphrase and private key .","title":"WIF"},{"location":"sdk/python/crypto/examples/#derive-the-wif-from-a-passphrase","text":"from solar_crypto.identity.wif import wif_from_passphrase wif = wif_from_passphrase ( 'validSeedPass' ) >>> < class ' str '>","title":"Derive the WIF from a Passphrase"},{"location":"sdk/python/crypto/intro/","text":"Crypto \u00b6 Development \u00b6 Fork the package . Clone your forked repository. git clone https://github.com/<githubusername>/python-crypto Next, move into the cloned directory. cd python-crypto The next step would be to create something like a virtual environment and install the dependencies of this package inside it. Create and enter the virtual environment # With virtualenv (on Unix and OSx) mkdir my-amazing-solar-project cd my-amazing-solar-project virtualenv virtualEnvName source venv/bin/activate # With virtualenv (on Windows) mkdir my-amazing-solar-project cd my-amazing-solar-project virtualenv virtualEnvName . \\v env \\S cripts \\a ctivate.bat Once inside the virtualenv, you can proceed to install dependencies. python -m pip install -e . \"[dev]\" Dependencies are now installed, you can now run the tests to see if everything is running as it should. pytest","title":"Getting Started"},{"location":"sdk/python/crypto/intro/#crypto","text":"","title":"Crypto"},{"location":"sdk/python/crypto/intro/#development","text":"Fork the package . Clone your forked repository. git clone https://github.com/<githubusername>/python-crypto Next, move into the cloned directory. cd python-crypto The next step would be to create something like a virtual environment and install the dependencies of this package inside it. Create and enter the virtual environment # With virtualenv (on Unix and OSx) mkdir my-amazing-solar-project cd my-amazing-solar-project virtualenv virtualEnvName source venv/bin/activate # With virtualenv (on Windows) mkdir my-amazing-solar-project cd my-amazing-solar-project virtualenv virtualEnvName . \\v env \\S cripts \\a ctivate.bat Once inside the virtualenv, you can proceed to install dependencies. python -m pip install -e . \"[dev]\" Dependencies are now installed, you can now run the tests to see if everything is running as it should. pytest","title":"Development"},{"location":"sdk/typescript/complementary-examples/","text":"Complementary Examples \u00b6 Prerequisites \u00b6 Before we get started we need to make sure that all of the required dependencies are installed. These dependencies are the Crypto SDK and Client SDK . You can head on over to their documentations to read more about them but for now we are only concerned with installing them to get up and running. Open your project and execute the following commands to install both SDKs. Make sure that those complete without any errors. If you encounter any errors, please open an issue with as much information as you can provide so that our developers can have a look and get to the bottom of the issue. yarn \u00b6 yarn add @solar-network/crypto yarn add @solar-network/client pnpm \u00b6 pnpm add @solar-network/crypto pnpm add @solar-network/client npm \u00b6 npm install @solar-network/crypto npm install @solar-network/client Now that we're setup and ready to go we'll look into some examples for the most common tasks you'll encounter when wanting to interact with the SXP Blockchain. Persisting your transaction on the blockchain \u00b6 The process of getting your transaction verified and persisted on the SXP Blockchain involves a few steps with which our SDKs will help you but lets break them down to get a better idea of what is happening. Install the Client SDK and configure it to use a node of your choosing to broadcast your transactions to. Always make sure that you have a fallback node that you can use for broadcasting in case your primary node goes offline or acts strange otherwise. Install the Crypto SDK and configure it to match the configuration of the network. This is the most important part as misconfiguration can lead to a myriad of issues as Core will reject your transactions. Retrieve the nonce of the sender wallet and increase it by 1. You can read about what a sequential nonce is and why it is important here . Create an instance of the builder for the type of transaction you want to create. This is the step where we actually create a transaction and sign it so that the SXP Blockchain can later on verify it and decide if it will be accepted, forged and finally. You can read the relevant API documentation if you want more detailed information about the design and usage. Turn the newly created transaction into JSON and broadcast it to the network through the Client SDK. You can read the relevant API documentation if you want more detailed information about the design and usage. Process the API response and verify that your transaction was accepted. If the network rejects your transaction you'll receive the reason as to why that is the case in the response which might mean that you need to create a new transaction and broadcast it. Troubleshooting \u00b6 A common issue when trying to get your transaction onto the blockchain is that you'll receive an error to the effect of Transaction Version 2 is not supported which indicates that your Crypto SDK configuration might be wrong. The solution to this is to make sure that your Crypto SDK instance is properly configured. This includes both the network preset and the height it's configured to assume the network has passed, if any of those don't match up you'll encounter the aforementioned issue with the version of your transactions. Mainnet \u00b6 Managers . configManager . setFromPreset ( \"mainnet\" ); Managers . configManager . setHeight ( 2477000 ); Testnet \u00b6 Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); Creating and Broadcasting a Transfer Transaction \u00b6 const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://tapi.solar.org/api\" ); // Set the chain and height Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . transfer () . nonce ( senderNonce . toFixed ()) . memo ( \"This is an example memo\" ) . addTransfer ( \"Address of Recipient Wallet 1\" , 1 * 1e8 ) . addTransfer ( \"Address of Recipient Wallet 2\" , 1 * 1e8 ) . addTransfer ( \"Address of Recipient Wallet 3\" , 1 * 1e8 ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); info The memo is optional and limited to a length of 255 characters. It can be a good idea to add a memo to your transactions if you want to be able to easily track or identify them in the future or include a personal message to the transaction's recipient(s). Creating and Broadcasting a Second Signature Registration Transaction \u00b6 const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://tapi.solar.org/api\" ); // Set the chain and height Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . secondSignature () . version ( 2 ) . nonce ( senderNonce . toFixed ()) . signatureAsset ( \"this is a top secret second passphrase\" ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); Creating and Broadcasting a Delegate Registration Transaction \u00b6 const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://tapi.solar.org/api\" ); // Set the chain and height Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . delegateRegistration () . nonce ( senderNonce . toFixed ()) . usernameAsset ( \"johndoe\" ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); Creating and Broadcasting a Vote Transaction \u00b6 const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://tapi.solar.org/api\" ); // Set the chain and height Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . vote () . nonce ( senderNonce . toFixed ()) . votesAsset ({ \"sl33p\" : 100 }) // you can also vote for multiple delegates (up to 53 in total) // .votesAsset({\"sl33p\": 50, \"cactus1549\": 50}) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); info When voting for multiple delegates, the custom allocation amounts represent the vote-weight percentage to be applied. The total percentage must equal 100 to be valid. Creating and Broadcasting an Unvote Transaction \u00b6 const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://tapi.solar.org/api\" ); // Set the chain and height Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . vote () . nonce ( senderNonce . toFixed ()) . votesAsset ({}) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); info Note that unvoting is simply the act of sending an empty votes object. Creating and Broadcasting an IPFS Transaction \u00b6 const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://tapi.solar.org/api\" ); // Set the chain and height Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . ipfs () . nonce ( senderNonce . toFixed ()) . ipfsAsset ( \"QmR45FmbVVrixReBwJkhEKde2qwHYaQzGxu4ZoDeswuF9w\" ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); Creating and Broadcasting a Delegate Resignation Transaction \u00b6 Previously, v2-style Delegate Resignation was a permanent action. There was no way for a resigned delegate to reinstate their eligibility to receive votes and produce blocks. This was only useful in cases where a delegate no longer wanted to participate in network consensus. Solar Core 4.x adds a new 'Temporary' resignation option where their resigned status may be 'Revoked' after at least two rounds (~106 blocks). This is useful when a delegate may only wish to resign for a short time without negatively impacting the network (e.g., missing blocks) and can be for a variety of reasons, from temporary node maintenance to personal/private matters. Resignation Type Value Description Temporary 0 Resign only for a short time. Delegate will be temporarily blocked from receiving votes or forging. (the default when no resign type is declared) Permanent 1 Irreversible. Delegate will no longer be allowed to receive votes or forge. Revoke 2 Reverses a temporary resignation. const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://tapi.solar.org/api\" ); // Set the chain and height Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . delegateResignation () . nonce ( senderNonce . toFixed ()) . resignationTypeAsset ( 0 ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); info A delegate resignation has to be sent from the delegate wallet itself to verify its identity. Creating and Broadcasting a HTLC Lock Transaction \u00b6 const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://tapi.solar.org/api\" ); // Set the chain and height Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . htlcLock () . nonce ( senderNonce . toFixed ()) . htlcLockAsset ({ secretHash : \"0f128d401958b1b30ad0d10406f47f9489321017b4614e6cb993fc63913c5454\" , expiration : { type : 1 , value : Math.floor ( Date . now () / 1000 ), }, }) . amount ( 1 * 1e8 ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); Creating and Broadcasting a HTLC Claim Transaction \u00b6 const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://tapi.solar.org/api\" ); // Set the chain and height Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . htlcClaim () . nonce ( senderNonce . toFixed ()) . htlcClaimAsset ({ hashType : 0 lockTransactionId : \"943c220691e711c39c79d437ce185748a0018940e1a4144293af9d05627d2eb4\" , unlockSecret : \"c27f1ce845d8c29eebc9006be932b604fd06755521b1a8b0be4204c65377151a\" , }) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); Creating and Broadcasting a HTLC Refund Transaction \u00b6 const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://tapi.solar.org/api\" ); // Set the chain and height Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . htlcRefund () . nonce ( senderNonce . toFixed ()) . htlcRefundAsset ({ lockTransactionId : \"943c220691e711c39c79d437ce185748a0018940e1a4144293af9d05627d2eb4\" , }) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); Creating and Broadcasting a Burn Transaction \u00b6 const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://tapi.solar.org/api\" ); // Set the chain and height Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . burn () . nonce ( senderNonce . toFixed ()) . amount ( 100 * 1e8 ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })();","title":"Complementary Examples"},{"location":"sdk/typescript/complementary-examples/#complementary-examples","text":"","title":"Complementary Examples"},{"location":"sdk/typescript/complementary-examples/#prerequisites","text":"Before we get started we need to make sure that all of the required dependencies are installed. These dependencies are the Crypto SDK and Client SDK . You can head on over to their documentations to read more about them but for now we are only concerned with installing them to get up and running. Open your project and execute the following commands to install both SDKs. Make sure that those complete without any errors. If you encounter any errors, please open an issue with as much information as you can provide so that our developers can have a look and get to the bottom of the issue.","title":"Prerequisites"},{"location":"sdk/typescript/complementary-examples/#yarn","text":"yarn add @solar-network/crypto yarn add @solar-network/client","title":"yarn"},{"location":"sdk/typescript/complementary-examples/#pnpm","text":"pnpm add @solar-network/crypto pnpm add @solar-network/client","title":"pnpm"},{"location":"sdk/typescript/complementary-examples/#npm","text":"npm install @solar-network/crypto npm install @solar-network/client Now that we're setup and ready to go we'll look into some examples for the most common tasks you'll encounter when wanting to interact with the SXP Blockchain.","title":"npm"},{"location":"sdk/typescript/complementary-examples/#persisting-your-transaction-on-the-blockchain","text":"The process of getting your transaction verified and persisted on the SXP Blockchain involves a few steps with which our SDKs will help you but lets break them down to get a better idea of what is happening. Install the Client SDK and configure it to use a node of your choosing to broadcast your transactions to. Always make sure that you have a fallback node that you can use for broadcasting in case your primary node goes offline or acts strange otherwise. Install the Crypto SDK and configure it to match the configuration of the network. This is the most important part as misconfiguration can lead to a myriad of issues as Core will reject your transactions. Retrieve the nonce of the sender wallet and increase it by 1. You can read about what a sequential nonce is and why it is important here . Create an instance of the builder for the type of transaction you want to create. This is the step where we actually create a transaction and sign it so that the SXP Blockchain can later on verify it and decide if it will be accepted, forged and finally. You can read the relevant API documentation if you want more detailed information about the design and usage. Turn the newly created transaction into JSON and broadcast it to the network through the Client SDK. You can read the relevant API documentation if you want more detailed information about the design and usage. Process the API response and verify that your transaction was accepted. If the network rejects your transaction you'll receive the reason as to why that is the case in the response which might mean that you need to create a new transaction and broadcast it.","title":"Persisting your transaction on the blockchain"},{"location":"sdk/typescript/complementary-examples/#troubleshooting","text":"A common issue when trying to get your transaction onto the blockchain is that you'll receive an error to the effect of Transaction Version 2 is not supported which indicates that your Crypto SDK configuration might be wrong. The solution to this is to make sure that your Crypto SDK instance is properly configured. This includes both the network preset and the height it's configured to assume the network has passed, if any of those don't match up you'll encounter the aforementioned issue with the version of your transactions.","title":"Troubleshooting"},{"location":"sdk/typescript/complementary-examples/#mainnet","text":"Managers . configManager . setFromPreset ( \"mainnet\" ); Managers . configManager . setHeight ( 2477000 );","title":"Mainnet"},{"location":"sdk/typescript/complementary-examples/#testnet","text":"Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 );","title":"Testnet"},{"location":"sdk/typescript/complementary-examples/#creating-and-broadcasting-a-transfer-transaction","text":"const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://tapi.solar.org/api\" ); // Set the chain and height Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . transfer () . nonce ( senderNonce . toFixed ()) . memo ( \"This is an example memo\" ) . addTransfer ( \"Address of Recipient Wallet 1\" , 1 * 1e8 ) . addTransfer ( \"Address of Recipient Wallet 2\" , 1 * 1e8 ) . addTransfer ( \"Address of Recipient Wallet 3\" , 1 * 1e8 ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); info The memo is optional and limited to a length of 255 characters. It can be a good idea to add a memo to your transactions if you want to be able to easily track or identify them in the future or include a personal message to the transaction's recipient(s).","title":"Creating and Broadcasting a Transfer Transaction"},{"location":"sdk/typescript/complementary-examples/#creating-and-broadcasting-a-second-signature-registration-transaction","text":"const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://tapi.solar.org/api\" ); // Set the chain and height Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . secondSignature () . version ( 2 ) . nonce ( senderNonce . toFixed ()) . signatureAsset ( \"this is a top secret second passphrase\" ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })();","title":"Creating and Broadcasting a Second Signature Registration Transaction"},{"location":"sdk/typescript/complementary-examples/#creating-and-broadcasting-a-delegate-registration-transaction","text":"const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://tapi.solar.org/api\" ); // Set the chain and height Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . delegateRegistration () . nonce ( senderNonce . toFixed ()) . usernameAsset ( \"johndoe\" ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })();","title":"Creating and Broadcasting a Delegate Registration Transaction"},{"location":"sdk/typescript/complementary-examples/#creating-and-broadcasting-a-vote-transaction","text":"const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://tapi.solar.org/api\" ); // Set the chain and height Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . vote () . nonce ( senderNonce . toFixed ()) . votesAsset ({ \"sl33p\" : 100 }) // you can also vote for multiple delegates (up to 53 in total) // .votesAsset({\"sl33p\": 50, \"cactus1549\": 50}) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); info When voting for multiple delegates, the custom allocation amounts represent the vote-weight percentage to be applied. The total percentage must equal 100 to be valid.","title":"Creating and Broadcasting a Vote Transaction"},{"location":"sdk/typescript/complementary-examples/#creating-and-broadcasting-an-unvote-transaction","text":"const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://tapi.solar.org/api\" ); // Set the chain and height Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . vote () . nonce ( senderNonce . toFixed ()) . votesAsset ({}) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); info Note that unvoting is simply the act of sending an empty votes object.","title":"Creating and Broadcasting an Unvote Transaction"},{"location":"sdk/typescript/complementary-examples/#creating-and-broadcasting-an-ipfs-transaction","text":"const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://tapi.solar.org/api\" ); // Set the chain and height Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . ipfs () . nonce ( senderNonce . toFixed ()) . ipfsAsset ( \"QmR45FmbVVrixReBwJkhEKde2qwHYaQzGxu4ZoDeswuF9w\" ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })();","title":"Creating and Broadcasting an IPFS Transaction"},{"location":"sdk/typescript/complementary-examples/#creating-and-broadcasting-a-delegate-resignation-transaction","text":"Previously, v2-style Delegate Resignation was a permanent action. There was no way for a resigned delegate to reinstate their eligibility to receive votes and produce blocks. This was only useful in cases where a delegate no longer wanted to participate in network consensus. Solar Core 4.x adds a new 'Temporary' resignation option where their resigned status may be 'Revoked' after at least two rounds (~106 blocks). This is useful when a delegate may only wish to resign for a short time without negatively impacting the network (e.g., missing blocks) and can be for a variety of reasons, from temporary node maintenance to personal/private matters. Resignation Type Value Description Temporary 0 Resign only for a short time. Delegate will be temporarily blocked from receiving votes or forging. (the default when no resign type is declared) Permanent 1 Irreversible. Delegate will no longer be allowed to receive votes or forge. Revoke 2 Reverses a temporary resignation. const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://tapi.solar.org/api\" ); // Set the chain and height Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . delegateResignation () . nonce ( senderNonce . toFixed ()) . resignationTypeAsset ( 0 ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })(); info A delegate resignation has to be sent from the delegate wallet itself to verify its identity.","title":"Creating and Broadcasting a Delegate Resignation Transaction"},{"location":"sdk/typescript/complementary-examples/#creating-and-broadcasting-a-htlc-lock-transaction","text":"const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://tapi.solar.org/api\" ); // Set the chain and height Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . htlcLock () . nonce ( senderNonce . toFixed ()) . htlcLockAsset ({ secretHash : \"0f128d401958b1b30ad0d10406f47f9489321017b4614e6cb993fc63913c5454\" , expiration : { type : 1 , value : Math.floor ( Date . now () / 1000 ), }, }) . amount ( 1 * 1e8 ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })();","title":"Creating and Broadcasting a HTLC Lock Transaction"},{"location":"sdk/typescript/complementary-examples/#creating-and-broadcasting-a-htlc-claim-transaction","text":"const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://tapi.solar.org/api\" ); // Set the chain and height Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . htlcClaim () . nonce ( senderNonce . toFixed ()) . htlcClaimAsset ({ hashType : 0 lockTransactionId : \"943c220691e711c39c79d437ce185748a0018940e1a4144293af9d05627d2eb4\" , unlockSecret : \"c27f1ce845d8c29eebc9006be932b604fd06755521b1a8b0be4204c65377151a\" , }) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })();","title":"Creating and Broadcasting a HTLC Claim Transaction"},{"location":"sdk/typescript/complementary-examples/#creating-and-broadcasting-a-htlc-refund-transaction","text":"const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://tapi.solar.org/api\" ); // Set the chain and height Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . htlcRefund () . nonce ( senderNonce . toFixed ()) . htlcRefundAsset ({ lockTransactionId : \"943c220691e711c39c79d437ce185748a0018940e1a4144293af9d05627d2eb4\" , }) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })();","title":"Creating and Broadcasting a HTLC Refund Transaction"},{"location":"sdk/typescript/complementary-examples/#creating-and-broadcasting-a-burn-transaction","text":"const { Transactions , Managers , Utils } = require ( \"@solar-network/crypto\" ); const { Connection } = require ( \"@solar-network/client\" ); // Configure our API client const client = new Connection ( \"https://tapi.solar.org/api\" ); // Set the chain and height Managers . configManager . setFromPreset ( \"testnet\" ); Managers . configManager . setHeight ( 972604 ); ( async () => { // Step 1: Retrieve the incremental nonce of the sender wallet const senderWallet = await client . api ( \"wallets\" ). get ( \"YOUR_SENDER_WALLET_ADDRESS\" ); const senderNonce = Utils . BigNumber . make ( senderWallet . body . data . nonce ). plus ( 1 ); // Step 2: Create the transaction const transaction = Transactions . BuilderFactory . burn () . nonce ( senderNonce . toFixed ()) . amount ( 100 * 1e8 ) . sign ( \"this is a top secret passphrase\" ); // Step 4: Broadcast the transaction const broadcastResponse = await client . api ( \"transactions\" ). create ({ transactions : [ transaction . build (). toJson ()] }); // Step 5: Log the response console . log ( JSON . stringify ( broadcastResponse . body . data , null , 4 )) })();","title":"Creating and Broadcasting a Burn Transaction"},{"location":"sdk/typescript/installation/","text":"Installation \u00b6 NodeJS installation \u00b6 NodeJS can be downloaded here . Alternatively you can install NodeJS through your operating system packager manager . An excellent way to manage your NodeJS installation and be able to work with multiple version is to go through NVM . Install Yarn Package Manager \u00b6 Yarn is a package manager for your code. It allows you to use and share code with other developers from around the world. Yarn does this quickly, securely, and reliably so you don\u2019t ever have to worry. Instructions on how to install Yarn can be found here","title":"Installation"},{"location":"sdk/typescript/installation/#installation","text":"","title":"Installation"},{"location":"sdk/typescript/installation/#nodejs-installation","text":"NodeJS can be downloaded here . Alternatively you can install NodeJS through your operating system packager manager . An excellent way to manage your NodeJS installation and be able to work with multiple version is to go through NVM .","title":"NodeJS installation"},{"location":"sdk/typescript/installation/#install-yarn-package-manager","text":"Yarn is a package manager for your code. It allows you to use and share code with other developers from around the world. Yarn does this quickly, securely, and reliably so you don\u2019t ever have to worry. Instructions on how to install Yarn can be found here","title":"Install Yarn Package Manager"},{"location":"sdk/typescript/client/api-documentation/","text":"API Documentation \u00b6 ConnectionManager \u00b6 connect() \u00b6 public connect ( host : string , name = \"main\" ) Connect to the given connection. Parameters \u00b6 Type Name Required Description string host Yes Node URL string name No Network name Return Value \u00b6 Connection disconnect() \u00b6 public disconnect ( name? : string ) Disconnect from the given connection. Parameters \u00b6 Type Name Required Description string name No Network Name Return Value \u00b6 void connection() \u00b6 public connection ( name? : string ) Get a connection instance. Parameters \u00b6 Type Name Required Description string name No Network Name Return Value \u00b6 Connection getDefaultConnection() \u00b6 public getDefaultConnection () Get the default connection name. Return Value \u00b6 string setDefaultConnection() \u00b6 public setDefaultConnection ( name : string ) Set the default connection name. Parameters \u00b6 Type Name Required Description string name No Network Name Return Value \u00b6 void getConnections() \u00b6 public getConnections () Return all of the created connections. Return Value \u00b6 Record<string, Connection> Connection \u00b6 constructor() \u00b6 public constructor ( private readonly host : string ) Create a new Connection class instance. Parameters \u00b6 Type Name Required Description string host Yes Node URL api() \u00b6 public api < T = any > ( name : string ) Instantiate new Api. Parameters \u00b6 Type Name Required Description string name Yes Network name Return Value \u00b6 T Type Name Required Description string host Yes Node URL withOptions() \u00b6 public withOptions ( opts : Record < string , any > ) Apply options to future connection requests. Parameters \u00b6 Type Name Required Description string opts Yes Connection options Return Value \u00b6 this get() \u00b6 public async get < T = any > ( url : string , opts? : Record < string , any > ) Send a GET request with query parameters. Parameters \u00b6 Type Name Required Description string url Yes Endpoint Record opts? No Query parameters Return Value \u00b6 Promise<IResponse<T>> post() \u00b6 public async post < T = any > ( url : string , opts? : Record < string , any > ) : Promise < IResponse < T >> Send a POST request with JSON-encoded parameters. Parameters \u00b6 Type Name Required Description string url Yes Endpoint Record opts? No Query parameters Return Value \u00b6 Promise<IResponse<T>> RequestError \u00b6 constructor() \u00b6 public constructor ( error ) Create a new RequestError class instance. Parameters \u00b6 Type Name Required Description string error Yes Error Resources\\Blockchain \u00b6 blockchain() \u00b6 public async blockchain < T = any > ( query? : Record < string , any > ) Get all blockchains. Parameters \u00b6 Type Name Required Description Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> search() \u00b6 public async search < T = any > ( payload? : Record < string , any > ) Filter all blockchains by the given parameters. Parameters \u00b6 Type Name Required Description Record payload No Search parameters Return Value \u00b6 Promise<IResponse<T>> Resources\\Blocks \u00b6 all() \u00b6 public async all < T = any > ( query? : Record < string , any > ) Get all blocks. Parameters \u00b6 Type Name Required Description Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> first() \u00b6 public async first < T = any > ( query? : Record < string , any > ) Get the first block. Parameters \u00b6 Type Name Required Description Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> last() \u00b6 public async last < T = any > ( query? : Record < string , any > ) Get the last (most recent) block. Parameters \u00b6 Type Name Required Description Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> get() \u00b6 public async get < T = any > ( id : string ) Get a block by the given id. Parameters \u00b6 Type Name Required Description string id Yes Block ID Return Value \u00b6 Promise<IResponse<T>> transactions() \u00b6 public async transactions < T = any > ( id : string , query? : Record < string , any > ) Get all transactions by the given block. Parameters \u00b6 Type Name Required Description string id Yes Block ID Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> missed() \u00b6 public async missed < T = any > ( payload? : Record < string , any > ) Shows all the missed blocks by all delegates in the last 30 days Parameters \u00b6 Type Name Required Description Record payload No Search parameters Return Value \u00b6 Promise<IResponse<T>> Resources\\Locks \u00b6 all() \u00b6 public async all < T = any > ( query? : Record < string , any > ) Get all locks. Parameters \u00b6 Type Name Required Description Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> get() \u00b6 public async get < T = any > ( id : string ) Get a lock by the given id. Parameters \u00b6 Type Name Required Description string id Yes Bridgechain identifier Return Value \u00b6 Promise<IResponse<T>> unlocked() \u00b6 public async unlocked < T = any > ( payload? : Record < string , any > ) Search for unlocked locks. Parameters \u00b6 Type Name Required Description Record payload No Search parameters Return Value \u00b6 Promise<IResponse<T>> Resources\\Delegates \u00b6 all() \u00b6 public async all < T = any > ( query? : Record < string , any > ) Get all accounts. Parameters \u00b6 Type Name Required Description Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> get() \u00b6 public async get < T = any > ( id : string ) Get a delegate by the given id. Parameters \u00b6 Type Name Required Description string id Yes Delegate identifier Return Value \u00b6 Promise<IResponse<T>> blocks() \u00b6 public async blocks < T = any > ( id : string , query? : Record < string , any > ) Get all blocks for the given delegate. Parameters \u00b6 Type Name Required Description string id Yes Delegate identifier Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> missed() \u00b6 public async missed < T = any > ( id : string , query? : Record < string , any > ) List Recent Missed Blocks of a Delegate Parameters \u00b6 Type Name Required Description string id Yes Delegate identifier Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> voters() \u00b6 public async voters < T = any > ( id : string , query? : Record < string , any > ) Get all voters for the given delegate. Parameters \u00b6 Type Name Required Description string id Yes Delegate identifier Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> Resources\\Node \u00b6 configuration() \u00b6 public async configuration < T = any > () Get the node configuration. Return Value \u00b6 Promise<IResponse<T>> status() \u00b6 public async status < T = any > () Get the node status. Return Value \u00b6 Promise<IResponse<T>> syncing() \u00b6 public async syncing < T = any > () Get the node syncing status. Return Value \u00b6 Promise<IResponse<T>> crypto() \u00b6 public async crypto < T = any > () Get the node crypto configuration. Return Value \u00b6 Promise<IResponse<T>> fees() \u00b6 public async fees < T = any > ( days : number ) Get the node fee statistics. Parameters \u00b6 Type Name Required Description number days Yes Days Return Value \u00b6 Promise<IResponse<T>> Resources\\Peers \u00b6 all() \u00b6 public async all < T = any > ( query? : Record < string , any > ) Get all peers. Parameters \u00b6 Type Name Required Description Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> get() \u00b6 public async get < T = any > ( ip : string ) Get a peer by the given IP address. Parameters \u00b6 Type Name Required Description string ip Yes IP address Return Value \u00b6 Promise<IResponse<T>> Resources\\Rounds \u00b6 delegates() \u00b6 public async delegates < T = any > ( id : number ) Get delegates for a round. Parameters \u00b6 Type Name Required Description number id yes Round number Return Value \u00b6 Promise<IResponse<T>> Resources\\Transactions \u00b6 create() \u00b6 public async create < T = any > ( payload : object []) Create a new transaction. Parameters \u00b6 Type Name Required Description object[] payload Yes Transaction(s) to broadcast Return Value \u00b6 Promise<IResponse<T>> get() \u00b6 public async get < T = any > ( id : string ) Get a transaction by the given id. Parameters \u00b6 Type Name Required Description string id Yes Transaction ID Return Value \u00b6 Promise<IResponse<T>> all() \u00b6 public async all < T = any > ( query? : Record < string , any > ) Get all transactions. Parameters \u00b6 Type Name Required Description Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> allUnconfirmed() \u00b6 public async allUnconfirmed < T = any > ( query? : Record < string , any > ) Get all unconfirmed transactions. Parameters \u00b6 Type Name Required Description Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> getUnconfirmed() \u00b6 public async getUnconfirmed < T = any > ( id : string ) Get an unconfirmed transaction by the given id. Parameters \u00b6 Type Name Required Description string id Yes Transaction ID Return Value \u00b6 Promise<IResponse<T>> schemas() \u00b6 public async search < T = any > ( payload : Record < string , any > ) Get a list of transaction schemas. Parameters \u00b6 Type Name Required Description Record payload Yes Search parameters Return Value \u00b6 Promise<IResponse<T>> types() \u00b6 public async types < T = any > () Get a list of valid transaction types. Return Value \u00b6 Promise<IResponse<T>> fees() \u00b6 public async fees < T = any > () : Promise < IResponse < T >> Get the node fee statistics. Return Value \u00b6 Promise<IResponse<T>> Resources\\Votes \u00b6 all() \u00b6 public async all < T = any > ( query? : Record < string , any > ) Get all votes. Parameters \u00b6 Type Name Required Description Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> get() \u00b6 public async get < T = any > ( id : string ) Get a vote by the given id. Parameters \u00b6 Type Name Required Description string id Yes Vote ID Return Value \u00b6 Promise<IResponse<T>> Resources\\Wallets \u00b6 all() \u00b6 public async all < T = any > ( query? : Record < string , any > ) Get all wallets. Parameters \u00b6 Type Name Required Description Record query No Query parameters Return Value \u00b6 Promise<IResponse<T>> get() \u00b6 public async get < T = any > ( id : string ) Get a wallet by the given id. Parameters \u00b6 Type Name Required Description string id Yes Wallet identifier Return Value \u00b6 Promise<IResponse<T>> locks() \u00b6 public async locks < T = any > ( id : string , query? : Record < string , any > ) Get a wallet by the given id. Parameters \u00b6 Type Name Required Description string id Yes Wallet identifier Record query No Search parameters Return Value \u00b6 Promise<IResponse<T>> transactions() \u00b6 public async transactions < T = any > ( id : string , query? : Record < string , any > ) Get all transactions for the given wallet. Parameters \u00b6 Type Name Required Description string id Yes Wallet identifier Record query Yes Query parameters Return Value \u00b6 Promise<IResponse<T>> transactionsReceived() \u00b6 public async transactionsReceived < T = any > ( id : string , query? : Record < string , any > ) Get all transactions received by the given wallet. Parameters \u00b6 Type Name Required Description string id Yes Wallet identifier Record query Yes Query parameters Return Value \u00b6 Promise<IResponse<T>> transactionsSent() \u00b6 public async transactionsSent < T = any > ( id : string , query? : Record < string , any > ) Get all transactions sent by the given wallet. Parameters \u00b6 Type Name Required Description string id Yes Wallet identifier Record query Yes Query parameters Return Value \u00b6 Promise<IResponse<T>> votes() \u00b6 public async votes < T = any > ( id : string ) Get all votes by the given wallet. Parameters \u00b6 Type Name Required Description string id Yes Wallet identifier Return Value \u00b6 Promise<IResponse<T>> top() \u00b6 public async top < T = any > ( query? : Record < string , any > ) Get all wallets sorted by balance in descending order. Parameters \u00b6 Type Name Required Description Record query Yes Query parameters Return Value \u00b6 Promise<IResponse<T>>","title":"API Documentation"},{"location":"sdk/typescript/client/api-documentation/#api-documentation","text":"","title":"API Documentation"},{"location":"sdk/typescript/client/api-documentation/#connectionmanager","text":"","title":"ConnectionManager"},{"location":"sdk/typescript/client/api-documentation/#connect","text":"public connect ( host : string , name = \"main\" ) Connect to the given connection.","title":"connect()"},{"location":"sdk/typescript/client/api-documentation/#parameters","text":"Type Name Required Description string host Yes Node URL string name No Network name","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value","text":"Connection","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#disconnect","text":"public disconnect ( name? : string ) Disconnect from the given connection.","title":"disconnect()"},{"location":"sdk/typescript/client/api-documentation/#parameters_1","text":"Type Name Required Description string name No Network Name","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_1","text":"void","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#connection","text":"public connection ( name? : string ) Get a connection instance.","title":"connection()"},{"location":"sdk/typescript/client/api-documentation/#parameters_2","text":"Type Name Required Description string name No Network Name","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_2","text":"Connection","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#getdefaultconnection","text":"public getDefaultConnection () Get the default connection name.","title":"getDefaultConnection()"},{"location":"sdk/typescript/client/api-documentation/#return-value_3","text":"string","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#setdefaultconnection","text":"public setDefaultConnection ( name : string ) Set the default connection name.","title":"setDefaultConnection()"},{"location":"sdk/typescript/client/api-documentation/#parameters_3","text":"Type Name Required Description string name No Network Name","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_4","text":"void","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#getconnections","text":"public getConnections () Return all of the created connections.","title":"getConnections()"},{"location":"sdk/typescript/client/api-documentation/#return-value_5","text":"Record<string, Connection>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#connection_1","text":"","title":"Connection"},{"location":"sdk/typescript/client/api-documentation/#constructor","text":"public constructor ( private readonly host : string ) Create a new Connection class instance.","title":"constructor()"},{"location":"sdk/typescript/client/api-documentation/#parameters_4","text":"Type Name Required Description string host Yes Node URL","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#api","text":"public api < T = any > ( name : string ) Instantiate new Api.","title":"api()"},{"location":"sdk/typescript/client/api-documentation/#parameters_5","text":"Type Name Required Description string name Yes Network name","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_6","text":"T Type Name Required Description string host Yes Node URL","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#withoptions","text":"public withOptions ( opts : Record < string , any > ) Apply options to future connection requests.","title":"withOptions()"},{"location":"sdk/typescript/client/api-documentation/#parameters_6","text":"Type Name Required Description string opts Yes Connection options","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_7","text":"this","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#get","text":"public async get < T = any > ( url : string , opts? : Record < string , any > ) Send a GET request with query parameters.","title":"get()"},{"location":"sdk/typescript/client/api-documentation/#parameters_7","text":"Type Name Required Description string url Yes Endpoint Record opts? No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_8","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#post","text":"public async post < T = any > ( url : string , opts? : Record < string , any > ) : Promise < IResponse < T >> Send a POST request with JSON-encoded parameters.","title":"post()"},{"location":"sdk/typescript/client/api-documentation/#parameters_8","text":"Type Name Required Description string url Yes Endpoint Record opts? No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_9","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#requesterror","text":"","title":"RequestError"},{"location":"sdk/typescript/client/api-documentation/#constructor_1","text":"public constructor ( error ) Create a new RequestError class instance.","title":"constructor()"},{"location":"sdk/typescript/client/api-documentation/#parameters_9","text":"Type Name Required Description string error Yes Error","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#resourcesblockchain","text":"","title":"Resources\\Blockchain"},{"location":"sdk/typescript/client/api-documentation/#blockchain","text":"public async blockchain < T = any > ( query? : Record < string , any > ) Get all blockchains.","title":"blockchain()"},{"location":"sdk/typescript/client/api-documentation/#parameters_10","text":"Type Name Required Description Record query No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_10","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#search","text":"public async search < T = any > ( payload? : Record < string , any > ) Filter all blockchains by the given parameters.","title":"search()"},{"location":"sdk/typescript/client/api-documentation/#parameters_11","text":"Type Name Required Description Record payload No Search parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_11","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#resourcesblocks","text":"","title":"Resources\\Blocks"},{"location":"sdk/typescript/client/api-documentation/#all","text":"public async all < T = any > ( query? : Record < string , any > ) Get all blocks.","title":"all()"},{"location":"sdk/typescript/client/api-documentation/#parameters_12","text":"Type Name Required Description Record query No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_12","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#first","text":"public async first < T = any > ( query? : Record < string , any > ) Get the first block.","title":"first()"},{"location":"sdk/typescript/client/api-documentation/#parameters_13","text":"Type Name Required Description Record query No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_13","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#last","text":"public async last < T = any > ( query? : Record < string , any > ) Get the last (most recent) block.","title":"last()"},{"location":"sdk/typescript/client/api-documentation/#parameters_14","text":"Type Name Required Description Record query No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_14","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#get_1","text":"public async get < T = any > ( id : string ) Get a block by the given id.","title":"get()"},{"location":"sdk/typescript/client/api-documentation/#parameters_15","text":"Type Name Required Description string id Yes Block ID","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_15","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#transactions","text":"public async transactions < T = any > ( id : string , query? : Record < string , any > ) Get all transactions by the given block.","title":"transactions()"},{"location":"sdk/typescript/client/api-documentation/#parameters_16","text":"Type Name Required Description string id Yes Block ID Record query No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_16","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#missed","text":"public async missed < T = any > ( payload? : Record < string , any > ) Shows all the missed blocks by all delegates in the last 30 days","title":"missed()"},{"location":"sdk/typescript/client/api-documentation/#parameters_17","text":"Type Name Required Description Record payload No Search parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_17","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#resourceslocks","text":"","title":"Resources\\Locks"},{"location":"sdk/typescript/client/api-documentation/#all_1","text":"public async all < T = any > ( query? : Record < string , any > ) Get all locks.","title":"all()"},{"location":"sdk/typescript/client/api-documentation/#parameters_18","text":"Type Name Required Description Record query No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_18","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#get_2","text":"public async get < T = any > ( id : string ) Get a lock by the given id.","title":"get()"},{"location":"sdk/typescript/client/api-documentation/#parameters_19","text":"Type Name Required Description string id Yes Bridgechain identifier","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_19","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#unlocked","text":"public async unlocked < T = any > ( payload? : Record < string , any > ) Search for unlocked locks.","title":"unlocked()"},{"location":"sdk/typescript/client/api-documentation/#parameters_20","text":"Type Name Required Description Record payload No Search parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_20","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#resourcesdelegates","text":"","title":"Resources\\Delegates"},{"location":"sdk/typescript/client/api-documentation/#all_2","text":"public async all < T = any > ( query? : Record < string , any > ) Get all accounts.","title":"all()"},{"location":"sdk/typescript/client/api-documentation/#parameters_21","text":"Type Name Required Description Record query No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_21","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#get_3","text":"public async get < T = any > ( id : string ) Get a delegate by the given id.","title":"get()"},{"location":"sdk/typescript/client/api-documentation/#parameters_22","text":"Type Name Required Description string id Yes Delegate identifier","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_22","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#blocks","text":"public async blocks < T = any > ( id : string , query? : Record < string , any > ) Get all blocks for the given delegate.","title":"blocks()"},{"location":"sdk/typescript/client/api-documentation/#parameters_23","text":"Type Name Required Description string id Yes Delegate identifier Record query No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_23","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#missed_1","text":"public async missed < T = any > ( id : string , query? : Record < string , any > ) List Recent Missed Blocks of a Delegate","title":"missed()"},{"location":"sdk/typescript/client/api-documentation/#parameters_24","text":"Type Name Required Description string id Yes Delegate identifier Record query No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_24","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#voters","text":"public async voters < T = any > ( id : string , query? : Record < string , any > ) Get all voters for the given delegate.","title":"voters()"},{"location":"sdk/typescript/client/api-documentation/#parameters_25","text":"Type Name Required Description string id Yes Delegate identifier Record query No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_25","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#resourcesnode","text":"","title":"Resources\\Node"},{"location":"sdk/typescript/client/api-documentation/#configuration","text":"public async configuration < T = any > () Get the node configuration.","title":"configuration()"},{"location":"sdk/typescript/client/api-documentation/#return-value_26","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#status","text":"public async status < T = any > () Get the node status.","title":"status()"},{"location":"sdk/typescript/client/api-documentation/#return-value_27","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#syncing","text":"public async syncing < T = any > () Get the node syncing status.","title":"syncing()"},{"location":"sdk/typescript/client/api-documentation/#return-value_28","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#crypto","text":"public async crypto < T = any > () Get the node crypto configuration.","title":"crypto()"},{"location":"sdk/typescript/client/api-documentation/#return-value_29","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#fees","text":"public async fees < T = any > ( days : number ) Get the node fee statistics.","title":"fees()"},{"location":"sdk/typescript/client/api-documentation/#parameters_26","text":"Type Name Required Description number days Yes Days","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_30","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#resourcespeers","text":"","title":"Resources\\Peers"},{"location":"sdk/typescript/client/api-documentation/#all_3","text":"public async all < T = any > ( query? : Record < string , any > ) Get all peers.","title":"all()"},{"location":"sdk/typescript/client/api-documentation/#parameters_27","text":"Type Name Required Description Record query No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_31","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#get_4","text":"public async get < T = any > ( ip : string ) Get a peer by the given IP address.","title":"get()"},{"location":"sdk/typescript/client/api-documentation/#parameters_28","text":"Type Name Required Description string ip Yes IP address","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_32","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#resourcesrounds","text":"","title":"Resources\\Rounds"},{"location":"sdk/typescript/client/api-documentation/#delegates","text":"public async delegates < T = any > ( id : number ) Get delegates for a round.","title":"delegates()"},{"location":"sdk/typescript/client/api-documentation/#parameters_29","text":"Type Name Required Description number id yes Round number","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_33","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#resourcestransactions","text":"","title":"Resources\\Transactions"},{"location":"sdk/typescript/client/api-documentation/#create","text":"public async create < T = any > ( payload : object []) Create a new transaction.","title":"create()"},{"location":"sdk/typescript/client/api-documentation/#parameters_30","text":"Type Name Required Description object[] payload Yes Transaction(s) to broadcast","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_34","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#get_5","text":"public async get < T = any > ( id : string ) Get a transaction by the given id.","title":"get()"},{"location":"sdk/typescript/client/api-documentation/#parameters_31","text":"Type Name Required Description string id Yes Transaction ID","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_35","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#all_4","text":"public async all < T = any > ( query? : Record < string , any > ) Get all transactions.","title":"all()"},{"location":"sdk/typescript/client/api-documentation/#parameters_32","text":"Type Name Required Description Record query No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_36","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#allunconfirmed","text":"public async allUnconfirmed < T = any > ( query? : Record < string , any > ) Get all unconfirmed transactions.","title":"allUnconfirmed()"},{"location":"sdk/typescript/client/api-documentation/#parameters_33","text":"Type Name Required Description Record query No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_37","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#getunconfirmed","text":"public async getUnconfirmed < T = any > ( id : string ) Get an unconfirmed transaction by the given id.","title":"getUnconfirmed()"},{"location":"sdk/typescript/client/api-documentation/#parameters_34","text":"Type Name Required Description string id Yes Transaction ID","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_38","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#schemas","text":"public async search < T = any > ( payload : Record < string , any > ) Get a list of transaction schemas.","title":"schemas()"},{"location":"sdk/typescript/client/api-documentation/#parameters_35","text":"Type Name Required Description Record payload Yes Search parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_39","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#types","text":"public async types < T = any > () Get a list of valid transaction types.","title":"types()"},{"location":"sdk/typescript/client/api-documentation/#return-value_40","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#fees_1","text":"public async fees < T = any > () : Promise < IResponse < T >> Get the node fee statistics.","title":"fees()"},{"location":"sdk/typescript/client/api-documentation/#return-value_41","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#resourcesvotes","text":"","title":"Resources\\Votes"},{"location":"sdk/typescript/client/api-documentation/#all_5","text":"public async all < T = any > ( query? : Record < string , any > ) Get all votes.","title":"all()"},{"location":"sdk/typescript/client/api-documentation/#parameters_36","text":"Type Name Required Description Record query No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_42","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#get_6","text":"public async get < T = any > ( id : string ) Get a vote by the given id.","title":"get()"},{"location":"sdk/typescript/client/api-documentation/#parameters_37","text":"Type Name Required Description string id Yes Vote ID","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_43","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#resourceswallets","text":"","title":"Resources\\Wallets"},{"location":"sdk/typescript/client/api-documentation/#all_6","text":"public async all < T = any > ( query? : Record < string , any > ) Get all wallets.","title":"all()"},{"location":"sdk/typescript/client/api-documentation/#parameters_38","text":"Type Name Required Description Record query No Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_44","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#get_7","text":"public async get < T = any > ( id : string ) Get a wallet by the given id.","title":"get()"},{"location":"sdk/typescript/client/api-documentation/#parameters_39","text":"Type Name Required Description string id Yes Wallet identifier","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_45","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#locks","text":"public async locks < T = any > ( id : string , query? : Record < string , any > ) Get a wallet by the given id.","title":"locks()"},{"location":"sdk/typescript/client/api-documentation/#parameters_40","text":"Type Name Required Description string id Yes Wallet identifier Record query No Search parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_46","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#transactions_1","text":"public async transactions < T = any > ( id : string , query? : Record < string , any > ) Get all transactions for the given wallet.","title":"transactions()"},{"location":"sdk/typescript/client/api-documentation/#parameters_41","text":"Type Name Required Description string id Yes Wallet identifier Record query Yes Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_47","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#transactionsreceived","text":"public async transactionsReceived < T = any > ( id : string , query? : Record < string , any > ) Get all transactions received by the given wallet.","title":"transactionsReceived()"},{"location":"sdk/typescript/client/api-documentation/#parameters_42","text":"Type Name Required Description string id Yes Wallet identifier Record query Yes Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_48","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#transactionssent","text":"public async transactionsSent < T = any > ( id : string , query? : Record < string , any > ) Get all transactions sent by the given wallet.","title":"transactionsSent()"},{"location":"sdk/typescript/client/api-documentation/#parameters_43","text":"Type Name Required Description string id Yes Wallet identifier Record query Yes Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_49","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#votes","text":"public async votes < T = any > ( id : string ) Get all votes by the given wallet.","title":"votes()"},{"location":"sdk/typescript/client/api-documentation/#parameters_44","text":"Type Name Required Description string id Yes Wallet identifier","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_50","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/api-documentation/#top","text":"public async top < T = any > ( query? : Record < string , any > ) Get all wallets sorted by balance in descending order.","title":"top()"},{"location":"sdk/typescript/client/api-documentation/#parameters_45","text":"Type Name Required Description Record query Yes Query parameters","title":"Parameters"},{"location":"sdk/typescript/client/api-documentation/#return-value_51","text":"Promise<IResponse<T>>","title":"Return Value"},{"location":"sdk/typescript/client/examples/","text":"Examples \u00b6 Initialization \u00b6 const { Connection } = require ( \"@solar-network/client\" ); const client = new Connection ( ` ${ server } /api` ); Blocks \u00b6 This service API grants access to the blocks resource . A block is a signed set of transactions created by a delegate and permanently committed to the SXP blockchain. It is not possible to POST a block through the public API. Relay Nodes accept only blocks posted by a delegate at the correct time through the internal API. List All Blocks \u00b6 const response = client . api ( \"blocks\" ). all (); >>> Promise < IResponse < T >> Retrieve a Block \u00b6 const response = client . api ( \"blocks\" ). get ( \"validBlockId\" ); >>> Promise < IResponse < T >> List All Transactions of a Block \u00b6 const response = client . api ( \"blocks\" ). transactions ( \"validBlockId\" ); >>> Promise < IResponse < T >> Search All Blocks \u00b6 const response = client . api ( \"blocks\" ). search ({ \"id\" : \"validBlockId\" }); >>> Promise < IResponse < T >> Bridgechains \u00b6 This service API grants access to the bridgechain resource. This can be used to access all registered bridgechains on the network. List All Bridgechains \u00b6 const response = client . api ( \"bridgechains\" ). all (); >>> Promise < IResponse < T >> Retrieve a Bridgechain \u00b6 const response = client . api ( \"bridgechains\" ). get ( \"validId\" ); >>> Promise < IResponse < T >> Search All Bridgechains \u00b6 const response = client . api ( \"bridgechains\" ). search ({ \"bridgechainId\" : \"validId\" }); >>> Promise < IResponse < T >> Businesses \u00b6 This service API grants access to the business resource. This can be used to access all registered businesses on the network. List All Businesses \u00b6 const response = client . api ( \"businesses\" ). all (); >>> Promise < IResponse < T >> Retrieve a Business \u00b6 const response = client . api ( \"businesses\" ). get ( \"validId\" ); >>> Promise < IResponse < T >> Retrieve all Business Bridgechains \u00b6 const response = client . api ( \"businesses\" ). bridgechains ( \"validId\" ); >>> Promise < IResponse < T >> Search All Businesses \u00b6 const response = client . api ( \"businesses\" ). search ({ \"businessId\" : \"validId\" }); >>> Promise < IResponse < T >> Delegates \u00b6 The client SDK can be used to query the delegate resource . A delegate is a regular wallet that has broadcast a registration transaction, acquired a sufficient number of votes, and has a Relay Node configured to forge new blocks through a forger module. At any time only 51 delegates are active. They are cost-efficient miners running the SXP network. Voters are wallets which have broadcast a vote transaction on a delegate. A vote remains active until an un-vote transaction is sent (it does not have to be recast unless a wallet wishes to change from delegate). Voting for a delegate does not give the delegate access to the wallet nor does it lock the coins in it. List All Delegates \u00b6 const response = client . api ( \"delegates\" ). all (); >>> Promise < IResponse < T >> Retrieve a Delegate \u00b6 const response = client . api ( \"delegates\" ). get ( \"validId\" ); >>> Promise < IResponse < T >> List All Blocks of a Delegate \u00b6 const response = client . api ( \"delegates\" ). blocks ( \"validId\" ); >>> Promise < IResponse < T >> List All Voters of a Delegate \u00b6 const response = client . api ( \"delegates\" ). voters ( \"validId\" ); >>> Promise < IResponse < T >> Locks \u00b6 This service API grants access to the lock resource. This can be used to access all locks initiated for wallets. List All Locks \u00b6 const response = client . api ( \"locks\" ). all (); >>> Promise < IResponse < T >> Retrieve a Lock \u00b6 const response = client . api ( \"locks\" ). get ( \"validId\" ); >>> Promise < IResponse < T >> Search Locks \u00b6 const response = client . api ( \"locks\" ). search ({ \"lockId\" : \"validId\" }); >>> Promise < IResponse < T >> Get Unlocked Locks \u00b6 const response = client . api ( \"locks\" ). unlocked ({ ids : [ \"validId\" ]}); >>> Promise < IResponse < T >> Node \u00b6 The SXP network consists of different anonymous nodes (servers), maintaining the public ledger, validating transactions and blocks and providing APIs. The node resource allows for querying the health and configurations of the node used by the instantiated client. Retrieve the Configuration \u00b6 const response = client . api ( \"node\" ). configuration (); >>> Promise < IResponse < T >> Retrieve the Status \u00b6 const response = client . api ( \"node\" ). status (); >>> Promise < IResponse < T >> Retrieve the Syncing Status \u00b6 const response = client . api ( \"node\" ). syncing (); >>> Promise < IResponse < T >> Retrieve the Fees \u00b6 const response = client . api ( \"node\" ). fees (); >>> Promise < IResponse < T >> Peers \u00b6 Each node is connected to a set of peers, which are Relay or Delegate Nodes as well. The peers resource provides access to all peers connected to our node. Peers have made their Public API available for use; however for mission-critical queries and transaction posting you should use a node which is under your control. List All Peers \u00b6 const response = client . api ( \"peers\" ). all (); >>> Promise < IResponse < T >> Retrieve a Peer \u00b6 const response = client . api ( \"peers\" ). get ( \"validIpAddress\" ); >>> Promise < IResponse < T >> Rounds \u00b6 This service API grants access to the round resource. This can be used to access all round information for the network. List Delegates for a Round \u00b6 const response = client . api ( \"rounds\" ). delegates ( roundNumber ); >>> Promise < IResponse < T >> Transactions \u00b6 The heart of any blockchain is formed by its transactions; state-altering payloads signed by a wallet. Most likely you will be querying for transactions most often, using the transaction resource . A transaction is the only object which may be posted by a non-delegate. It requires a signature from a wallet containing a sufficient amount of SXP. Create a Transaction \u00b6 const response = client . api ( \"transactions\" ). create ([...]); >>> Promise < IResponse < T >> Retrieve a Transaction \u00b6 const response = client . api ( \"transactions\" ). get ( \"validId\" ); >>> Promise < IResponse < T >> List All Transactions \u00b6 const response = client . api ( \"transactions\" ). all (); >>> Promise < IResponse < T >> List All Unconfirmed Transactions \u00b6 const response = client . api ( \"transactions\" ). allUnconfirmed (); >>> Promise < IResponse < T >> Get Unconfirmed Transaction \u00b6 const response = client . api ( \"transactions\" ). getUnconfirmed ( \"validId\" ); >>> Promise < IResponse < T >> Search Transactions \u00b6 const response = client . api ( \"transactions\" ). search ({ \"id\" : \"validId\" }); >>> Promise < IResponse < T >> List Transaction Types \u00b6 const response = client . api ( \"transactions\" ). types (); >>> Promise < IResponse < T >> Votes \u00b6 A vote is a transaction sub-type, where the asset field contains a votes object and the transaction.type is 3 . List All Votes \u00b6 const response = client . api ( \"votes\" ). all (); >>> Promise < IResponse < T >> Retrieve a Vote \u00b6 const response = client . api ( \"votes\" ). get ( \"validId\" ); >>> Promise < IResponse < T >> Wallets \u00b6 The wallet resource provides access to: Wallets. Incoming and outgoing transactions per wallet. Each wallet's votes. Retrieve All Wallets \u00b6 const response = client . api ( \"wallets\" ). all (); >>> Promise < IResponse < T >> Retrieve a Wallet \u00b6 const response = client . api ( \"wallets\" ). get ( \"validId\" ); >>> Promise < IResponse < T >> List All Transactions of a Wallet \u00b6 const response = client . api ( \"wallets\" ). transactions ( \"validId\" ); >>> Promise < IResponse < T >> List All Received Transactions of a Wallet \u00b6 const response = client . api ( \"wallets\" ). transactionsReceived ( \"validId\" ); >>> Promise < IResponse < T >> List All Sent Transactions of a Wallet \u00b6 const response = client . api ( \"wallets\" ). transactionsSent ( \"validId\" ); >>> Promise < IResponse < T >> List All Votes of a Wallet \u00b6 const response = client . api ( \"wallets\" ). votes ( \"validId\" ); >>> Promise < IResponse < T >> List All Locks of a Wallet \u00b6 const response = client . api ( \"wallets\" ). locks ( \"validId\" ); >>> Promise < IResponse < T >> List All Top Wallets \u00b6 const response = client . api ( \"wallets\" ). top (); >>> Promise < IResponse < T >> Search All Wallets \u00b6 const response = client . api ( \"wallets\" ). search ({ \"address\" : \"validId\" }); >>> Promise < IResponse < T >>","title":"Examples"},{"location":"sdk/typescript/client/examples/#examples","text":"","title":"Examples"},{"location":"sdk/typescript/client/examples/#initialization","text":"const { Connection } = require ( \"@solar-network/client\" ); const client = new Connection ( ` ${ server } /api` );","title":"Initialization"},{"location":"sdk/typescript/client/examples/#blocks","text":"This service API grants access to the blocks resource . A block is a signed set of transactions created by a delegate and permanently committed to the SXP blockchain. It is not possible to POST a block through the public API. Relay Nodes accept only blocks posted by a delegate at the correct time through the internal API.","title":"Blocks"},{"location":"sdk/typescript/client/examples/#list-all-blocks","text":"const response = client . api ( \"blocks\" ). all (); >>> Promise < IResponse < T >>","title":"List All Blocks"},{"location":"sdk/typescript/client/examples/#retrieve-a-block","text":"const response = client . api ( \"blocks\" ). get ( \"validBlockId\" ); >>> Promise < IResponse < T >>","title":"Retrieve a Block"},{"location":"sdk/typescript/client/examples/#list-all-transactions-of-a-block","text":"const response = client . api ( \"blocks\" ). transactions ( \"validBlockId\" ); >>> Promise < IResponse < T >>","title":"List All Transactions of a Block"},{"location":"sdk/typescript/client/examples/#search-all-blocks","text":"const response = client . api ( \"blocks\" ). search ({ \"id\" : \"validBlockId\" }); >>> Promise < IResponse < T >>","title":"Search All Blocks"},{"location":"sdk/typescript/client/examples/#bridgechains","text":"This service API grants access to the bridgechain resource. This can be used to access all registered bridgechains on the network.","title":"Bridgechains"},{"location":"sdk/typescript/client/examples/#list-all-bridgechains","text":"const response = client . api ( \"bridgechains\" ). all (); >>> Promise < IResponse < T >>","title":"List All Bridgechains"},{"location":"sdk/typescript/client/examples/#retrieve-a-bridgechain","text":"const response = client . api ( \"bridgechains\" ). get ( \"validId\" ); >>> Promise < IResponse < T >>","title":"Retrieve a Bridgechain"},{"location":"sdk/typescript/client/examples/#search-all-bridgechains","text":"const response = client . api ( \"bridgechains\" ). search ({ \"bridgechainId\" : \"validId\" }); >>> Promise < IResponse < T >>","title":"Search All Bridgechains"},{"location":"sdk/typescript/client/examples/#businesses","text":"This service API grants access to the business resource. This can be used to access all registered businesses on the network.","title":"Businesses"},{"location":"sdk/typescript/client/examples/#list-all-businesses","text":"const response = client . api ( \"businesses\" ). all (); >>> Promise < IResponse < T >>","title":"List All Businesses"},{"location":"sdk/typescript/client/examples/#retrieve-a-business","text":"const response = client . api ( \"businesses\" ). get ( \"validId\" ); >>> Promise < IResponse < T >>","title":"Retrieve a Business"},{"location":"sdk/typescript/client/examples/#retrieve-all-business-bridgechains","text":"const response = client . api ( \"businesses\" ). bridgechains ( \"validId\" ); >>> Promise < IResponse < T >>","title":"Retrieve all Business Bridgechains"},{"location":"sdk/typescript/client/examples/#search-all-businesses","text":"const response = client . api ( \"businesses\" ). search ({ \"businessId\" : \"validId\" }); >>> Promise < IResponse < T >>","title":"Search All Businesses"},{"location":"sdk/typescript/client/examples/#delegates","text":"The client SDK can be used to query the delegate resource . A delegate is a regular wallet that has broadcast a registration transaction, acquired a sufficient number of votes, and has a Relay Node configured to forge new blocks through a forger module. At any time only 51 delegates are active. They are cost-efficient miners running the SXP network. Voters are wallets which have broadcast a vote transaction on a delegate. A vote remains active until an un-vote transaction is sent (it does not have to be recast unless a wallet wishes to change from delegate). Voting for a delegate does not give the delegate access to the wallet nor does it lock the coins in it.","title":"Delegates"},{"location":"sdk/typescript/client/examples/#list-all-delegates","text":"const response = client . api ( \"delegates\" ). all (); >>> Promise < IResponse < T >>","title":"List All Delegates"},{"location":"sdk/typescript/client/examples/#retrieve-a-delegate","text":"const response = client . api ( \"delegates\" ). get ( \"validId\" ); >>> Promise < IResponse < T >>","title":"Retrieve a Delegate"},{"location":"sdk/typescript/client/examples/#list-all-blocks-of-a-delegate","text":"const response = client . api ( \"delegates\" ). blocks ( \"validId\" ); >>> Promise < IResponse < T >>","title":"List All Blocks of a Delegate"},{"location":"sdk/typescript/client/examples/#list-all-voters-of-a-delegate","text":"const response = client . api ( \"delegates\" ). voters ( \"validId\" ); >>> Promise < IResponse < T >>","title":"List All Voters of a Delegate"},{"location":"sdk/typescript/client/examples/#locks","text":"This service API grants access to the lock resource. This can be used to access all locks initiated for wallets.","title":"Locks"},{"location":"sdk/typescript/client/examples/#list-all-locks","text":"const response = client . api ( \"locks\" ). all (); >>> Promise < IResponse < T >>","title":"List All Locks"},{"location":"sdk/typescript/client/examples/#retrieve-a-lock","text":"const response = client . api ( \"locks\" ). get ( \"validId\" ); >>> Promise < IResponse < T >>","title":"Retrieve a Lock"},{"location":"sdk/typescript/client/examples/#search-locks","text":"const response = client . api ( \"locks\" ). search ({ \"lockId\" : \"validId\" }); >>> Promise < IResponse < T >>","title":"Search Locks"},{"location":"sdk/typescript/client/examples/#get-unlocked-locks","text":"const response = client . api ( \"locks\" ). unlocked ({ ids : [ \"validId\" ]}); >>> Promise < IResponse < T >>","title":"Get Unlocked Locks"},{"location":"sdk/typescript/client/examples/#node","text":"The SXP network consists of different anonymous nodes (servers), maintaining the public ledger, validating transactions and blocks and providing APIs. The node resource allows for querying the health and configurations of the node used by the instantiated client.","title":"Node"},{"location":"sdk/typescript/client/examples/#retrieve-the-configuration","text":"const response = client . api ( \"node\" ). configuration (); >>> Promise < IResponse < T >>","title":"Retrieve the Configuration"},{"location":"sdk/typescript/client/examples/#retrieve-the-status","text":"const response = client . api ( \"node\" ). status (); >>> Promise < IResponse < T >>","title":"Retrieve the Status"},{"location":"sdk/typescript/client/examples/#retrieve-the-syncing-status","text":"const response = client . api ( \"node\" ). syncing (); >>> Promise < IResponse < T >>","title":"Retrieve the Syncing Status"},{"location":"sdk/typescript/client/examples/#retrieve-the-fees","text":"const response = client . api ( \"node\" ). fees (); >>> Promise < IResponse < T >>","title":"Retrieve the Fees"},{"location":"sdk/typescript/client/examples/#peers","text":"Each node is connected to a set of peers, which are Relay or Delegate Nodes as well. The peers resource provides access to all peers connected to our node. Peers have made their Public API available for use; however for mission-critical queries and transaction posting you should use a node which is under your control.","title":"Peers"},{"location":"sdk/typescript/client/examples/#list-all-peers","text":"const response = client . api ( \"peers\" ). all (); >>> Promise < IResponse < T >>","title":"List All Peers"},{"location":"sdk/typescript/client/examples/#retrieve-a-peer","text":"const response = client . api ( \"peers\" ). get ( \"validIpAddress\" ); >>> Promise < IResponse < T >>","title":"Retrieve a Peer"},{"location":"sdk/typescript/client/examples/#rounds","text":"This service API grants access to the round resource. This can be used to access all round information for the network.","title":"Rounds"},{"location":"sdk/typescript/client/examples/#list-delegates-for-a-round","text":"const response = client . api ( \"rounds\" ). delegates ( roundNumber ); >>> Promise < IResponse < T >>","title":"List Delegates for a Round"},{"location":"sdk/typescript/client/examples/#transactions","text":"The heart of any blockchain is formed by its transactions; state-altering payloads signed by a wallet. Most likely you will be querying for transactions most often, using the transaction resource . A transaction is the only object which may be posted by a non-delegate. It requires a signature from a wallet containing a sufficient amount of SXP.","title":"Transactions"},{"location":"sdk/typescript/client/examples/#create-a-transaction","text":"const response = client . api ( \"transactions\" ). create ([...]); >>> Promise < IResponse < T >>","title":"Create a Transaction"},{"location":"sdk/typescript/client/examples/#retrieve-a-transaction","text":"const response = client . api ( \"transactions\" ). get ( \"validId\" ); >>> Promise < IResponse < T >>","title":"Retrieve a Transaction"},{"location":"sdk/typescript/client/examples/#list-all-transactions","text":"const response = client . api ( \"transactions\" ). all (); >>> Promise < IResponse < T >>","title":"List All Transactions"},{"location":"sdk/typescript/client/examples/#list-all-unconfirmed-transactions","text":"const response = client . api ( \"transactions\" ). allUnconfirmed (); >>> Promise < IResponse < T >>","title":"List All Unconfirmed Transactions"},{"location":"sdk/typescript/client/examples/#get-unconfirmed-transaction","text":"const response = client . api ( \"transactions\" ). getUnconfirmed ( \"validId\" ); >>> Promise < IResponse < T >>","title":"Get Unconfirmed Transaction"},{"location":"sdk/typescript/client/examples/#search-transactions","text":"const response = client . api ( \"transactions\" ). search ({ \"id\" : \"validId\" }); >>> Promise < IResponse < T >>","title":"Search Transactions"},{"location":"sdk/typescript/client/examples/#list-transaction-types","text":"const response = client . api ( \"transactions\" ). types (); >>> Promise < IResponse < T >>","title":"List Transaction Types"},{"location":"sdk/typescript/client/examples/#votes","text":"A vote is a transaction sub-type, where the asset field contains a votes object and the transaction.type is 3 .","title":"Votes"},{"location":"sdk/typescript/client/examples/#list-all-votes","text":"const response = client . api ( \"votes\" ). all (); >>> Promise < IResponse < T >>","title":"List All Votes"},{"location":"sdk/typescript/client/examples/#retrieve-a-vote","text":"const response = client . api ( \"votes\" ). get ( \"validId\" ); >>> Promise < IResponse < T >>","title":"Retrieve a Vote"},{"location":"sdk/typescript/client/examples/#wallets","text":"The wallet resource provides access to: Wallets. Incoming and outgoing transactions per wallet. Each wallet's votes.","title":"Wallets"},{"location":"sdk/typescript/client/examples/#retrieve-all-wallets","text":"const response = client . api ( \"wallets\" ). all (); >>> Promise < IResponse < T >>","title":"Retrieve All Wallets"},{"location":"sdk/typescript/client/examples/#retrieve-a-wallet","text":"const response = client . api ( \"wallets\" ). get ( \"validId\" ); >>> Promise < IResponse < T >>","title":"Retrieve a Wallet"},{"location":"sdk/typescript/client/examples/#list-all-transactions-of-a-wallet","text":"const response = client . api ( \"wallets\" ). transactions ( \"validId\" ); >>> Promise < IResponse < T >>","title":"List All Transactions of a Wallet"},{"location":"sdk/typescript/client/examples/#list-all-received-transactions-of-a-wallet","text":"const response = client . api ( \"wallets\" ). transactionsReceived ( \"validId\" ); >>> Promise < IResponse < T >>","title":"List All Received Transactions of a Wallet"},{"location":"sdk/typescript/client/examples/#list-all-sent-transactions-of-a-wallet","text":"const response = client . api ( \"wallets\" ). transactionsSent ( \"validId\" ); >>> Promise < IResponse < T >>","title":"List All Sent Transactions of a Wallet"},{"location":"sdk/typescript/client/examples/#list-all-votes-of-a-wallet","text":"const response = client . api ( \"wallets\" ). votes ( \"validId\" ); >>> Promise < IResponse < T >>","title":"List All Votes of a Wallet"},{"location":"sdk/typescript/client/examples/#list-all-locks-of-a-wallet","text":"const response = client . api ( \"wallets\" ). locks ( \"validId\" ); >>> Promise < IResponse < T >>","title":"List All Locks of a Wallet"},{"location":"sdk/typescript/client/examples/#list-all-top-wallets","text":"const response = client . api ( \"wallets\" ). top (); >>> Promise < IResponse < T >>","title":"List All Top Wallets"},{"location":"sdk/typescript/client/examples/#search-all-wallets","text":"const response = client . api ( \"wallets\" ). search ({ \"address\" : \"validId\" }); >>> Promise < IResponse < T >>","title":"Search All Wallets"},{"location":"sdk/typescript/client/getting-started/","text":"NodeJS installation \u00b6 NodeJS can be downloaded here: nodejs.org/en/download Alternatively you can install NodeJS through your operating system packager manager . An excellent way to manage your NodeJS installation and be able to work with multiple version is to go through NVM . Yarn \u00b6 Yarn is a package manager for your code. It allows you to use and share code with other developers from around the world. Yarn does this quickly, securely, and reliably so you don\u2019t ever have to worry. Install Yarn \u00b6 Instructions on how to install Yarn can be found here: yarnpkg.com/en/docs/install Install package with Yarn \u00b6 yarn add @solar-network/client Development \u00b6 Fork the package: github.com/Solar-network/client/fork Clone your forked repository. git clone https://github.com/<githubusername>/client Next, move into the fresh cloned directory. cd javascript-client Proceed to install the dependencies. yarn install Dependencies are now installed, you can now run the tests to see if everything is running as it should. yarn test","title":"Getting Started"},{"location":"sdk/typescript/client/getting-started/#nodejs-installation","text":"NodeJS can be downloaded here: nodejs.org/en/download Alternatively you can install NodeJS through your operating system packager manager . An excellent way to manage your NodeJS installation and be able to work with multiple version is to go through NVM .","title":"NodeJS installation"},{"location":"sdk/typescript/client/getting-started/#yarn","text":"Yarn is a package manager for your code. It allows you to use and share code with other developers from around the world. Yarn does this quickly, securely, and reliably so you don\u2019t ever have to worry.","title":"Yarn"},{"location":"sdk/typescript/client/getting-started/#install-yarn","text":"Instructions on how to install Yarn can be found here: yarnpkg.com/en/docs/install","title":"Install Yarn"},{"location":"sdk/typescript/client/getting-started/#install-package-with-yarn","text":"yarn add @solar-network/client","title":"Install package with Yarn"},{"location":"sdk/typescript/client/getting-started/#development","text":"Fork the package: github.com/Solar-network/client/fork Clone your forked repository. git clone https://github.com/<githubusername>/client Next, move into the fresh cloned directory. cd javascript-client Proceed to install the dependencies. yarn install Dependencies are now installed, you can now run the tests to see if everything is running as it should. yarn test","title":"Development"},{"location":"sdk/typescript/client/intro/","text":"Client \u00b6 Install package with Yarn \u00b6 yarn add @solar-network/client Development \u00b6 Fork the package: github.com/Solar-network/client/fork Clone your forked repository. git clone https://github.com/<githubusername>/client Next, move into the fresh cloned directory. cd client Proceed to install the dependencies. yarn install Dependencies are now installed, you can now run the tests to see if everything is running as it should. yarn test","title":"Introduction"},{"location":"sdk/typescript/client/intro/#client","text":"","title":"Client"},{"location":"sdk/typescript/client/intro/#install-package-with-yarn","text":"yarn add @solar-network/client","title":"Install package with Yarn"},{"location":"sdk/typescript/client/intro/#development","text":"Fork the package: github.com/Solar-network/client/fork Clone your forked repository. git clone https://github.com/<githubusername>/client Next, move into the fresh cloned directory. cd client Proceed to install the dependencies. yarn install Dependencies are now installed, you can now run the tests to see if everything is running as it should. yarn test","title":"Development"},{"location":"sdk/typescript/crypto/api-documentation/","text":"API Documentation \u00b6 Crypto\\Blocks\\BlockFactory \u00b6 fromHex() \u00b6 public static fromHex ( hex : string ) Generate Block object from HEX. Parameters \u00b6 Type Name Required Description string hex Yes Block content Return Value \u00b6 IBlock fromBytes() \u00b6 public static fromBytes ( buffer : Buffer ) Generate Block object from a Buffer. Parameters \u00b6 Type Name Required Description Buffer buffer Yes Block content Return Value \u00b6 IBlock fromJson() \u00b6 public static fromJson ( json : IBlockJson ) Generate Block object from JSON. Parameters \u00b6 Type Name Required Description IBlockJson json Yes Block content Return Value \u00b6 IBlock fromData() \u00b6 public static fromData ( data : IBlockData , options : { deserialiseTransactionsUnchecked? : boolean } = {}) Generate Block object from Block data. Parameters \u00b6 Type Name Required Description IBlockData data Yes Block content object options Yes Options used for parsing block data Return Value \u00b6 IBlock Crypto\\Blocks\\Serialiser \u00b6 size() \u00b6 public static size ( block : IBlock ) Get size of Block. Parameters \u00b6 Type Name Required Description IBlock block Yes Block object Return Value \u00b6 number serialiseWithTransactions() \u00b6 public static serialiseWithTransactions ( block : IBlockData ) Serialise Block with Transactions. Parameters \u00b6 Type Name Required Description IBlockData block Yes Block object Return Value \u00b6 Buffer serialise() \u00b6 public static serialise ( block : IBlockData , includeSignature : boolean = true ) Serialise Block without Transactions. Parameters \u00b6 Type Name Required Description IBlockData block Yes Block object boolean includeSignature Yes Whether to include signature in serialisation Return Value \u00b6 Buffer Crypto\\Crypto\\HashAlgorithms \u00b6 ripemd160() \u00b6 public static ripemd160 ( buffer : Buffer | string ) Hash with RIPEMD-160. Parameters \u00b6 Type Name Required Description Buffer, string buffer Yes String or Buffer to generate hash for Return Value \u00b6 Buffer sha1() \u00b6 public static sha1 ( buffer : Buffer | string ) Hash with SHA-1. Parameters \u00b6 Type Name Required Description Buffer, string buffer Yes String or Buffer to generate hash for Return Value \u00b6 Buffer sha256() \u00b6 public static sha256 ( buffer : Buffer | string | Buffer []) Hash with SHA-256. Parameters \u00b6 Type Name Required Description Buffer, string buffer Yes String or Buffer to generate hash for Return Value \u00b6 Buffer hash160() \u00b6 public static hash160 ( buffer : Buffer | string ) Hash with Hash160. Parameters \u00b6 Type Name Required Description Buffer, string buffer Yes String or Buffer to generate hash for Return Value \u00b6 Buffer hash256() \u00b6 public static hash256 ( buffer : Buffer | string ) Hash with Hash256. Parameters \u00b6 Type Name Required Description Buffer, string buffer Yes String or Buffer to generate hash for Return Value \u00b6 Buffer Crypto\\Crypto\\Hash \u00b6 signECDSA() \u00b6 public static signECDSA ( hash : Buffer , keys : IKeyPair ) Sign hash with ECDSA. Parameters \u00b6 Type Name Required Description Buffer hash Yes Hash to sign IKeyPair keys Yes Keys to sign hash with Return Value \u00b6 string verifyECDSA() \u00b6 public static verifyECDSA ( hash : Buffer , signature : Buffer | string , publicKey : Buffer | string ) Verify ECDSA signature. Parameters \u00b6 Type Name Required Description Buffer hash Yes Hash to verify Buffer, string signature Yes Signature of hash Buffer, string publicKey Yes Public key of wallet which signed the hash Return Value \u00b6 boolean signSchnorr() \u00b6 public static signSchnorr ( hash : Buffer , keys : IKeyPair ) Sign hash with Schnorr. Parameters \u00b6 Type Name Required Description Buffer hash Yes Hash to sign IKeyPair keys Yes Keys to sign hash with Return Value \u00b6 string verifySchnorr() \u00b6 public static verifySchnorr ( hash : Buffer , signature : Buffer | string , publicKey : Buffer | string ) Verify Schnorr signature. Parameters \u00b6 Type Name Required Description Buffer hash Yes Hash to verify Buffer, string signature Yes Signature of hash Buffer, string publicKey Yes Public key of wallet which signed the hash Return Value \u00b6 boolean Crypto\\Crypto\\HDWallet \u00b6 fromMnemonic() \u00b6 public static fromMnemonic ( mnemonic : string , passphrase? : string ) Generate BIP32 Wallet from mnemonic. Parameters \u00b6 Type Name Required Description string mnemonic Yes INSERT_DESCRIPTION string passphrase No INSERT_DESCRIPTION Return Value \u00b6 BIP32Interface fromKeys() \u00b6 public static fromKeys ( keys : IKeyPair , chainCode : Buffer ) Generate BIP32 Wallet from KeyPair. Parameters \u00b6 Type Name Required Description IKeyPair keys Yes INSERT_DESCRIPTION Buffer chainCode Yes INSERT_DESCRIPTION Return Value \u00b6 BIP32Interface getKeys() \u00b6 public static getKeys ( node : BIP32Interface ) Get keys for BIP32 Wallet. Parameters \u00b6 Type Name Required Description BIP32Interface node Yes BIP32 Wallet to get keys for Return Value \u00b6 IKeyPair deriveSlip44() \u00b6 public static deriveSlip44 ( root : BIP32Interface , hardened : boolean = true ) Determine Slip44 for BIP32 Wallet. Parameters \u00b6 Type Name Required Description BIP32Interface root Yes BIP32 Wallet to determine Slip44 for boolean hardened Yes INSERT_DESCRIPTION Return Value \u00b6 BIP32Interface deriveNetwork() \u00b6 public static deriveNetwork ( root : BIP32Interface ) Determine Network for BIP32 Wallet. Parameters \u00b6 Type Name Required Description BIP32Interface root Yes BIP32 Wallet to determine network for Return Value \u00b6 BIP32Interface Crypto\\Crypto\\Message \u00b6 sign() \u00b6 public static sign ( message : string , passphrase : string ) Sign a message using the given passphrase. Parameters \u00b6 Type Name Required Description string message Yes Message string passphrase Yes Passphrase Return Value \u00b6 IMessage signWithWif() \u00b6 public static signWithWif ( message : string , wif : string , network? : INetwork ) Sign a message using the given WIF string. Parameters \u00b6 Type Name Required Description string message Yes Message string wif Yes Network WIF INetwork network No Network Return Value \u00b6 IMessage verify() \u00b6 public static verify ({ message , publicKey , signature } : IMessage ) Verify the message contents Parameters \u00b6 Type Name Required Description IMessage object Yes Message Return Value \u00b6 boolean Crypto\\Crypto\\Slots \u00b6 getTime() \u00b6 public static getTime ( time? : number ) Get the time diff between now and network start. Parameters \u00b6 Type Name Required Description number time No Network start time Return Value \u00b6 number getTimeInMsUntilNextSlot() \u00b6 public static getTimeInMsUntilNextSlot () Get the time (in milliseconds) until the start of the next slot. Return Value \u00b6 number getSlotNumber() \u00b6 public static getSlotNumber ( epoch? : number ) Get the slot number. Parameters \u00b6 Type Name Required Description number epoch No Epoch time Return Value \u00b6 number getSlotTime() \u00b6 public static getSlotTime ( slot : number ) Get the slot time. Parameters \u00b6 Type Name Required Description number slot Yes Slot Return Value \u00b6 number getNextSlot() \u00b6 public static getNextSlot () Get the next slot. Return Value \u00b6 number isForgingAllowed() \u00b6 public static isForgingAllowed ( epoch? : number ) Verify is forging is allowed. Parameters \u00b6 Type Name Required Description number epoch No Epoch time Return Value \u00b6 boolean Crypto\\Identities\\Address \u00b6 fromPassphrase() \u00b6 public static fromPassphrase ( passphrase : string , networkVersion? : number ) Derive the address from the given passphrase. Parameters \u00b6 Type Name Required Description string passphrase Yes Passphrase number networkVersion No Version of the network Return Value \u00b6 string fromPublicKey() \u00b6 public static fromPublicKey ( publicKey : string , networkVersion? : number ) Derive a (multisig) address from a multi signature asset. Parameters \u00b6 Type Name Required Description string publicKey Yes Public key number networkVersion No Version of the network Return Value \u00b6 string fromWIF() \u00b6 public static fromWIF ( wif : string , network? : NetworkType ) Derive the address from a WIF string. Parameters \u00b6 Type Name Required Description string wif Yes WIF NetworkType network No Network to generate address for Return Value \u00b6 string fromMultiSignatureAsset() \u00b6 public static fromMultiSignatureAsset ( asset : IMultiSignatureAsset , networkVersion? : number ) Derive the address from the given multi signature asset. Parameters \u00b6 Type Name Required Description IMultiSignatureAsset asset Yes Address to validate number networkVersion No Version of the network Return Value \u00b6 string fromPrivateKey() \u00b6 public static fromPrivateKey ( privateKey , networkVersion? : number ) Derive the address from the given private key. Parameters \u00b6 Type Name Required Description any privateKey Yes Private key to derive address for number networkVersion No Version of the network Return Value \u00b6 string fromBuffer() \u00b6 public static fromBuffer ( buffer : Buffer ) Derive the address from a Buffer. Parameters \u00b6 Type Name Required Description Buffer buffer Yes Buffer to derive address from Return Value \u00b6 string toBuffer() \u00b6 public static toBuffer ( address : string ) Convert address to a Buffer. Parameters \u00b6 Type Name Required Description string address Yes Address to convert to buffer Return Value \u00b6 { addressBuffer: Buffer; addressError?: string } validate() \u00b6 public static validate ( address : string , networkVersion? : number ) Validate the given address. Parameters \u00b6 Type Name Required Description string address Yes Address to validate number networkVersion No Version of the network Return Value \u00b6 boolean Crypto\\Identities\\Keys \u00b6 fromPassphrase() \u00b6 public static fromPassphrase ( passphrase : string , compressed : boolean = true ) Derive the keys from the given passphrase. Parameters \u00b6 Type Name Required Description string passphrase Yes Passphrase boolean compressed Yes Compression flag Return Value \u00b6 IKeyPair fromPrivateKey() \u00b6 public static fromPrivateKey ( privateKey : Buffer | string , compressed : boolean = true ) Derive the keys from the given private key. Parameters \u00b6 Type Name Required Description Buffer, string privateKey Yes Private Key to derive keys from boolean compressed Yes Compression flag Return Value \u00b6 IKeyPair fromWIF() \u00b6 public static fromWIF ( wifKey : string , network? : INetwork ) Derive the keys from the given WIF. Parameters \u00b6 Type Name Required Description string wifKey Yes Private key INetwork network No Network Return Value \u00b6 IKeyPair Crypto\\Identities\\PrivateKey \u00b6 fromPassphrase() \u00b6 public static fromPassphrase ( passphrase : string ) Derive the private key for the given passphrase. Parameters \u00b6 Type Name Required Description string passphrase Yes Passphrase Return Value \u00b6 string fromWIF() \u00b6 public static fromWIF ( wif : string , network? : NetworkType ) Create a private key instance from a hex string. Parameters \u00b6 Type Name Required Description string wif Yes Network WIF NetworkType network No Network Return Value \u00b6 string Crypto\\Identities\\PublicKey \u00b6 fromPassphrase() \u00b6 public static fromPassphrase ( passphrase : string ) Derive the public key from the given passphrase. Parameters \u00b6 Type Name Required Description string passphrase Yes Passphrase Return Value \u00b6 string fromWIF() \u00b6 public static fromWIF ( wif : string , network? : NetworkType ) Derive the public key from the given WIF. Parameters \u00b6 Type Name Required Description string wif Yes WIF to derive public key from NetworkType network No Network Return Value \u00b6 string fromMultiSignatureAsset() \u00b6 public static fromMultiSignatureAsset ( asset : IMultiSignatureAsset ) Derive the public key from the given multi signature asset. Parameters \u00b6 Type Name Required Description IMultiSignatureAsset asset Yes Asset Return Value \u00b6 string validate() \u00b6 public static validate ( publicKey : string , networkVersion? : number ) Validate the given public key. Parameters \u00b6 Type Name Required Description string publicKey Yes Public key number networkVersion No Network version Return Value \u00b6 boolean Crypto\\Identities\\WIF \u00b6 fromPassphrase() \u00b6 public static fromPassphrase ( passphrase : string , network? : INetwork ) Derive the WIF from the given passphrase. Parameters \u00b6 Type Name Required Description string passphrase Yes Passphrase to derive WIF from INetwork network No Network wif Return Value \u00b6 string fromKeys() \u00b6 public static fromKeys ( keys : IKeyPair , network? : INetwork ) Derive the WIF from the given keys. Parameters \u00b6 Type Name Required Description IKeyPair keys Yes Keys INetwork network No Network Return Value \u00b6 string Crypto\\Managers\\ConfigManager \u00b6 setConfig() \u00b6 public setConfig ( config : INetworkConfig ) Set the configuration. Parameters \u00b6 Type Name Required Description INetworkConfig config Yes Network configuration object Return Value \u00b6 void setFromPreset() \u00b6 public setFromPreset ( network : NetworkName ) Set the configuration from given presets. Parameters \u00b6 Type Name Required Description NetworkName network Yes Preset Return Value \u00b6 void getPreset() \u00b6 public getPreset ( network : NetworkName ) Get configuration preset. Parameters \u00b6 Type Name Required Description NetworkName network Yes Preset Return Value \u00b6 INetworkConfig all() \u00b6 public all () Get all configs. Return Value \u00b6 INetworkConfig set() \u00b6 public set < T = any > ( key : string , value : T ) Set a value for the specified network config key. Parameters \u00b6 Type Name Required Description string key Yes Key to set T value Yes Value to set Return Value \u00b6 void get() \u00b6 public get < T = any > ( key : string ) Get key. Parameters \u00b6 Type Name Required Description string key Yes Key to get Return Value \u00b6 T setHeight() \u00b6 public setHeight ( value : number ) Set network height. Parameters \u00b6 Type Name Required Description number value Yes Network height Return Value \u00b6 void getHeight() \u00b6 public getHeight () Get network height. Return Value \u00b6 number isNewMilestone() \u00b6 public isNewMilestone ( height? : number ) Verify if current height contains a milestone. Parameters \u00b6 Type Name Required Description number height No Height to check for milestone Return Value \u00b6 boolean getMilestone() \u00b6 public getMilestone ( height? : number ) Get milestone. Parameters \u00b6 Type Name Required Description number height No Network height Return Value \u00b6 { [key: string]: any } getMilestones() \u00b6 public getMilestones () Get all milestones. Return Value \u00b6 any Crypto\\Managers\\NetworkManager \u00b6 all() \u00b6 public static all () Get settings for all networks. Return Value \u00b6 Record<NetworkName, INetworkConfig> findByName() \u00b6 public static findByName ( name : NetworkName ) Get settings for a selected network, default network is testnet. Parameters \u00b6 Type Name Required Description NetworkName name Yes Network name Return Value \u00b6 INetworkConfig Crypto\\Transactions\\Deserialiser \u00b6 deserialise() \u00b6 public static deserialise ( serialised : string | Buffer , options : IDeserialiseOptions = {}) Deserialise Transaction into object. Parameters \u00b6 Type Name Required Description string, Buffer serialised Yes Serialised transaction IDeserialiseOptions options Yes Options for deserialising Return Value \u00b6 ITransaction applyV1Compatibility() \u00b6 public static applyV1Compatibility ( transaction : ITransactionData ) Modify transaction to be v1 compatible. Parameters \u00b6 Type Name Required Description ITransactionData transaction Yes Transaction object Return Value \u00b6 void Crypto\\Transactions\\TransactionFactory \u00b6 fromHex() \u00b6 public static fromHex ( hex : string ) Create Transaction object from HEX. Parameters \u00b6 Type Name Required Description string hex Yes HEX of transaction Return Value \u00b6 ITransaction fromBytes() \u00b6 public static fromBytes ( buffer : Buffer , strict : boolean = true ) Create Transaction object from Buffer. Parameters \u00b6 Type Name Required Description Buffer buffer Yes Transaction buffer boolean strict Yes Strict creation from buffer Return Value \u00b6 ITransaction fromBytesUnsafe() \u00b6 public static fromBytesUnsafe ( buffer : Buffer , id? : string ) Create Transaction object from Buffer (unsafe). NOTE: Only use this internally when it is safe to assume the buffer has already been verified. Parameters \u00b6 Type Name Required Description Buffer buffer Yes Transaction buffer string id No ID override Return Value \u00b6 ITransaction fromJson() \u00b6 public static fromJson ( json : ITransactionJson ) Create Transaction object from JSON. Parameters \u00b6 Type Name Required Description ITransactionJson json Yes Transaction JSON object Return Value \u00b6 ITransaction fromData() \u00b6 public static fromData ( data : ITransactionData , strict : boolean = true ) Create Transaction object from Transaction data. Parameters \u00b6 Type Name Required Description ITransactionData data Yes Transaction object boolean strict Yes Strict conversion Return Value \u00b6 ITransaction Crypto\\Transactions\\Serialiser \u00b6 getBytes() \u00b6 public static getBytes ( transaction : ITransactionData , options : ISerialiseOptions = {}) Convert the transaction to its byte representation. Parameters \u00b6 Type Name Required Description ITransactionData transaction Yes Transaction ISerialiseOptions options Yes Options Return Value \u00b6 Buffer serialise() \u00b6 public static serialise ( transaction : ITransaction , options : ISerialiseOptions = {}) Perform AIP11 compliant serialisation. Parameters \u00b6 Type Name Required Description ITransaction transaction Yes Transaction ISerialiseOptions options Yes Options Return Value \u00b6 Buffer Crypto\\Transactions\\Signer \u00b6 sign() \u00b6 public static sign ( transaction : ITransactionData , keys : IKeyPair , options? : ISerialiseOptions ) Sign the given transaction with the provided keys. Parameters \u00b6 Type Name Required Description ITransactionData transaction Yes Transaction IKeyPair keys Yes Keys ISerialiseOptions options No Options Return Value \u00b6 string secondSign() \u00b6 public static secondSign ( transaction : ITransactionData , keys : IKeyPair ) Second sign the given transaction with the provided keys. Parameters \u00b6 Type Name Required Description ITransactionData transaction Yes Transaction IKeyPair keys Yes Keys Return Value \u00b6 string multiSign() \u00b6 public static multiSign ( transaction : ITransactionData , keys : IKeyPair , index : number = - 1 ) Multi sign the given transaction with the provided keys. Parameters \u00b6 Type Name Required Description ITransactionData transaction Yes Transaction IKeyPair keys Yes Keys number index Yes Index Return Value \u00b6 string Crypto\\Transactions\\Utils \u00b6 toBytes() \u00b6 public static toBytes ( data : ITransactionData ) Convert Transaction object to Buffer. Parameters \u00b6 Type Name Required Description ITransactionData data Yes Transaction object Return Value \u00b6 Buffer toHash() \u00b6 public static toHash ( transaction : ITransactionData , options? : ISerialieOptions ) Convert Transaction object to Hash. Parameters \u00b6 Type Name Required Description ITransactionData transaction Yes Transaction object ISerialiseOptions options No Serialisation options for generating hash Return Value \u00b6 Buffer getId() \u00b6 public static getId ( transaction : ITransactionData , options : ISerialiseOptions = {}) Get Transaction ID of Transaction object. Parameters \u00b6 Type Name Required Description ITransactionData transaction Yes Transaction object ISerialiseOptions options Yes Serialisation options for generating hash Return Value \u00b6 string Crypto\\Transactions\\Verifier \u00b6 verify() \u00b6 public static verify ( data : ITransactionData ) Verify transaction. Parameters \u00b6 Type Name Required Description ITransactionData data Yes Transaction object Return Value \u00b6 boolean verifySecondSignature() \u00b6 public static verifySecondSignature ( transaction : ITransactionData , publicKey : string ) Verify second signature. Parameters \u00b6 Type Name Required Description ITransactionData transaction Yes Transaction object string publicKey Yes Public key Return Value \u00b6 boolean verifySignatures() \u00b6 public static verifySignatures ( transaction : ITransactionData , multiSignature : IMultiSignatureAsset ) Verify the signatures of a Transaction object. Parameters \u00b6 Type Name Required Description ITransactionData transaction Yes Transaction object IMultiSignatureAsset multiSignature Yes Asset for Multi-Signature wallets/transactions Return Value \u00b6 boolean verifyHash() \u00b6 public static verifyHash ( data : ITransactionData ) Verify transaction hash. Parameters \u00b6 Type Name Required Description ITransactionData data Yes Transaction Return Value \u00b6 boolean verifySchema() \u00b6 public static verifySchema ( data : ITransactionData , strict : boolean = true ) Verify transaction schema. Parameters \u00b6 Type Name Required Description ITransactionData data Yes Transaction boolean strict Yes Strict flag Return Value \u00b6 ISchemaValidationResult Crypto\\Transactions\\Builders\\BuilderFactory \u00b6 transfer() \u00b6 public static transfer () Initiate a Transfer transaction type. Return Value \u00b6 TransferBuilder secondSignature() \u00b6 public static secondSignature () Initiate a Second Signature transaction type. Return Value \u00b6 SecondSignatureBuilder delegateRegistration() \u00b6 public static delegateRegistration () Initiate a Delegate Resignation transaction type. Return Value \u00b6 DelegateRegistrationBuilder vote() \u00b6 public static vote () Initiate a Vote transaction type. Return Value \u00b6 VoteBuilder multiSignature() \u00b6 public static multiSignature () Initiate a Multi-Signature transaction type. Return Value \u00b6 MultiSignatureBuilder ipfs() \u00b6 public static ipfs () Initiate an IPFS transaction type. Return Value \u00b6 IPFSBuilder multiPayment() \u00b6 public static multiPayment () Initiate a Multi-Payment transaction type. Return Value \u00b6 MultiPaymentBuilder delegateResignation() \u00b6 public static delegateResignation () Initiate a Delegate Resignation transaction type. Return Value \u00b6 DelegateResignationBuilder htlcLock() \u00b6 public static htlcLock () Initiate a HTLC Lock transaction type. Return Value \u00b6 HtlcLockBuilder htlcClaim() \u00b6 public static htlcClaim () Initiate a HTLC Claim transaction type. Return Value \u00b6 HtlcClaimBuilder htlcRefund() \u00b6 public static htlcRefund () Initiate a HTLC Refund transaction type. Return Value \u00b6 HtlcRefundBuilder Crypto\\Transactions\\Builders\\Transactions\\DelegateRegistrationBuilder \u00b6 usernameAsset() \u00b6 public usernameAsset ( username : string ) Set the username to assign. Parameters \u00b6 Type Name Required Description string username Yes Delegate username Return Value \u00b6 DelegateRegistrationBuilder getStruct() \u00b6 public getStruct () Get transaction structure. Return Value \u00b6 ITransactionData Crypto\\Transactions\\Builders\\Transactions\\DelegateResignationBuilder \u00b6 getStruct() \u00b6 public getStruct () Get transaction structure. Return Value \u00b6 ITransactionData Crypto\\Transactions\\Builders\\Transactions\\HtlcClaimBuilder \u00b6 htlcClaimAsset() \u00b6 public htlcClaimAsset ( claimAsset : IHtlcClaimAsset ) Specify the HTLC Claim asset data for the Transaction. Parameters \u00b6 Type Name Required Description IHtlcClaimAsset claimAsset Yes Asset for a HTLC Claim Return Value \u00b6 HtlcClaimBuilder getStruct() \u00b6 public getStruct () Get transaction structure. Return Value \u00b6 ITransactionData Crypto\\Transactions\\Builders\\Transactions\\HtlcLockBuilder \u00b6 htlcLockAsset() \u00b6 public htlcLockAsset ( lockAsset : IHtlcLockAsset ) Specify the HTLC Lock asset data for the Transaction. Parameters \u00b6 Type Name Required Description IHtlcLockAsset lockAsset Yes Asset for a HTLC Lock Return Value \u00b6 HtlcLockBuilder getStruct() \u00b6 public getStruct () Get transaction structure. Return Value \u00b6 ITransactionData Crypto\\Transactions\\Builders\\Transactions\\HtlcRefundBuilder \u00b6 htlcRefundAsset() \u00b6 public htlcRefundAsset ( refundAsset : IHtlcRefundAsset ) Specify the HTLC Refund asset data for the Transaction. Parameters \u00b6 Type Name Required Description IHtlcRefundAsset refundAsset Yes Asset for a HTLC Refund Return Value \u00b6 HtlcRefundBuilder getStruct() \u00b6 public getStruct () Get transaction structure. Return Value \u00b6 ITransactionData Crypto\\Transactions\\Builders\\Transactions\\IPFSBuilder \u00b6 ipfsAsset() \u00b6 public ipfsAsset ( ipfsId : string ) Set IPFS asset. Parameters \u00b6 Type Name Required Description string ipfsId Yes IPFS ID Return Value \u00b6 IPFSBuilder getStruct() \u00b6 public getStruct () Get transaction structure. Return Value \u00b6 ITransactionData Crypto\\Transactions\\Builders\\Transactions\\MultiPaymentBuilder \u00b6 addPayment() \u00b6 public addPayment ( recipientId : string , amount : string ) Add a new payment to the collection. Parameters \u00b6 Type Name Required Description string recipientId Yes Recipient identifier string amount Yes Transaction amount Return Value \u00b6 MultiPaymentBuilder getStruct() \u00b6 public getStruct () Get transaction structure. Return Value \u00b6 ITransactionData Crypto\\Transactions\\Builders\\Transactions\\MultiSignatureBuilder \u00b6 participant() \u00b6 public participant ( publicKey : string ) Add participant to multi signature transaction. Parameters \u00b6 Type Name Required Description string publicKey Yes Public key Return Value \u00b6 MultiSignatureBuilder min() \u00b6 public min ( min : number ) Set the minimum required signatures. Parameters \u00b6 Type Name Required Description number min Yes Minimum required signatures Return Value \u00b6 MultiSignatureBuilder multiSignatureAsset() \u00b6 public multiSignatureAsset ( multiSignature : IMultiSignatureAsset ) Derive the address from the given multi signature asset. Parameters \u00b6 Type Name Required Description IMultiSignatureAsset multiSignature Yes Multi signature asset Return Value \u00b6 MultiSignatureBuilder getStruct() \u00b6 public getStruct () Get transaction structure. Return Value \u00b6 ITransactionData Crypto\\Transactions\\Builders\\Transactions\\SecondSignatureBuilder \u00b6 signatureAsset() \u00b6 public signatureAsset ( secondPassphrase : string ) Specify the Second Signature asset data for the Transaction. Parameters \u00b6 Type Name Required Description string secondPassphrase Yes Asset for a Second Signature Return Value \u00b6 SecondSignatureBuilder getStruct() \u00b6 public getStruct () Get transaction structure. Return Value \u00b6 ITransactionData Crypto\\Transactions\\Builders\\Transactions\\TransferBuilder \u00b6 expiration() \u00b6 public expiration ( expiration : number ) Set Transfer expiration. Parameters \u00b6 Type Name Required Description number expiration Yes The block-height or time when the transaction should expire Return Value \u00b6 TransferBuilder getStruct() \u00b6 public getStruct () Get transaction structure. Return Value \u00b6 ITransactionData Crypto\\Transactions\\Builders\\Transactions\\VoteBuilder \u00b6 votesAsset() \u00b6 public votesAsset ( votes : string []) Specify the Vote asset data for the Transaction. Parameters \u00b6 Type Name Required Description string votes Yes Asset for a Vote Return Value \u00b6 VoteBuilder getStruct() \u00b6 public getStruct () Get transaction structure. Return Value \u00b6 ITransactionData Crypto\\Transactions\\Types\\DelegateRegistrationTransaction \u00b6 getSchema() \u00b6 public static getSchema () Get transaction schema. Return Value \u00b6 schemas.TransactionSchema serialise() \u00b6 public serialise ( options? : ISerialiseOptions ) Handle the serialisation of \"delegate registration\" data. Parameters \u00b6 Type Name Required Description ISerialiseOptions options No Options Return Value \u00b6 ByteBuffer deserialise() \u00b6 public deserialise ( buf : ByteBuffer ) Handle the deserialisation of \"delegate registration\" data. Parameters \u00b6 Type Name Required Description ByteBuffer buf Yes Buffer Return Value \u00b6 void Crypto\\Transactions\\Types\\DelegateResignationTransaction \u00b6 getSchema() \u00b6 public static getSchema () Get transaction schema. Return Value \u00b6 schemas.TransactionSchema verify() \u00b6 public verify () Verify transaction. Return Value \u00b6 boolean serialise() \u00b6 public serialise ( options? : ISerialiseOptions ) Handle the serialisation of \"delegate resignation\" data. Parameters \u00b6 Type Name Required Description ISerialiseOptions options No Options Return Value \u00b6 ByteBuffer deserialise() \u00b6 public deserialise ( buf : ByteBuffer ) Handle the deserialisation of \"delegate resignation\" data. Parameters \u00b6 Type Name Required Description ByteBuffer buf Yes Buffer Return Value \u00b6 void Crypto\\Transactions\\Types\\TransactionTypeFactory \u00b6 initialise() \u00b6 public static initialise ( transactionTypes : Map < InternalTransactionType , TransactionConstructor > ) Initialise new transaction types factory. Parameters \u00b6 Type Name Required Description Map transactionTypes Yes INSERT_DESCRIPTION create() \u00b6 public static create ( data : ITransactionData ) Create new transaction type. Parameters \u00b6 Type Name Required Description ITransactionData data Yes Transaction object Return Value \u00b6 ITransaction get() \u00b6 public static get ( type : number , typeGroup? : number ) Get a transaction type. Parameters \u00b6 Type Name Required Description number type Yes Transaction type number typeGroup No Transaction group Return Value \u00b6 TransactionConstructor Crypto\\Transactions\\Types\\HtlcClaimTransaction \u00b6 getSchema() \u00b6 public static getSchema () Get transaction schema. Return Value \u00b6 schemas.TransactionSchema verify() \u00b6 public verify () Verify transaction. Return Value \u00b6 boolean serialise() \u00b6 public serialise ( options? : ISerialiseOptions ) Serialise Transaction object. Parameters \u00b6 Type Name Required Description ISerialiseOptions options No Serialisation options Return Value \u00b6 ByteBuffer deserialise() \u00b6 public deserialise ( buf : ByteBuffer ) Deserialise into Transaction object. Parameters \u00b6 Type Name Required Description ByteBuffer buf Yes Buffer to deserialise Return Value \u00b6 void Crypto\\Transactions\\Types\\HtlcLockTransaction \u00b6 getSchema() \u00b6 public static getSchema () Get transaction schema. Return Value \u00b6 schemas.TransactionSchema verify() \u00b6 public verify () Verify transaction. Return Value \u00b6 boolean hasVendorField() \u00b6 public hasVendorField () Verify if the transaction contains a vendorfield. Return Value \u00b6 boolean serialise() \u00b6 public serialise ( options? : ISerialiseOptions ) Serialise a Transaction object. Parameters \u00b6 Type Name Required Description ISerialiseOptions options No Serialisation options Return Value \u00b6 ByteBuffer deserialise() \u00b6 public deserialise ( buf : ByteBuffer ) Deserialise into a Transaction object. Parameters \u00b6 Type Name Required Description ByteBuffer buf Yes Buffer to deserialise Return Value \u00b6 void Crypto\\Transactions\\Types\\HtlcRefundTransaction \u00b6 getSchema() \u00b6 public static getSchema () Get transaction schema. Return Value \u00b6 schemas.TransactionSchema verify() \u00b6 public verify () Verify transaction. Return Value \u00b6 boolean serialise() \u00b6 public serialise ( options? : ISerialiseOptions ) Serialise a Transaction object. Parameters \u00b6 Type Name Required Description ISerialiseOptions options No Serialisation options Return Value \u00b6 ByteBuffer deserialise() \u00b6 public deserialise ( buf : ByteBuffer ) Deserialise into a Transaction object. Parameters \u00b6 Type Name Required Description ByteBuffer buf Yes Buffer to deserialise Return Value \u00b6 void Crypto\\Transactions\\Types\\InternalTransactionType \u00b6 from() \u00b6 public static from ( type : number , typeGroup? : number ) Create new internal transaction type from existing type. Parameters \u00b6 Type Name Required Description number type Yes Transaction type number typeGroup No Transaction group Return Value \u00b6 InternalTransactionType toString() \u00b6 public toString () Convert transaction type to a group/type string representation (E.g. 1/0) Return Value \u00b6 string Crypto\\Transactions\\Types\\IpfsTransaction \u00b6 getSchema() \u00b6 public static getSchema () Get transaction schema. Return Value \u00b6 schemas.TransactionSchema verify() \u00b6 public verify () Verify transaction. Return Value \u00b6 boolean serialise() \u00b6 public serialise ( options? : ISerialiseOptions ) Handle the serialisation of \"IPFS\" data. Parameters \u00b6 Type Name Required Description ISerialiseOptions options No Options Return Value \u00b6 ByteBuffer deserialise() \u00b6 public deserialise ( buf : ByteBuffer ) Handle the deserialisation of \"IPFS\" data. Parameters \u00b6 Type Name Required Description ByteBuffer buf Yes Buffer Return Value \u00b6 void Crypto\\Transactions\\Types\\MultiPaymentTransaction \u00b6 getSchema() \u00b6 public static getSchema () Get transaction schema. Return Value \u00b6 schemas.TransactionSchema verify() \u00b6 public verify () Verify transaction. Return Value \u00b6 boolean hasVendorField() \u00b6 public hasVendorField () Verify if the transaction contains a vendorfield. Return Value \u00b6 boolean serialise() \u00b6 public serialise ( options? : ISerialiseOptions ) Serialise a Transaction object. Parameters \u00b6 Type Name Required Description ISerialiseOptions options No Serialisation options Return Value \u00b6 ByteBuffer deserialise() \u00b6 public deserialise ( buf : ByteBuffer ) Deserialise into a Transaction object. Parameters \u00b6 Type Name Required Description ByteBuffer buf Yes Buffer to deserialise Return Value \u00b6 void Crypto\\Transactions\\Types\\MultiSignatureRegistrationTransaction \u00b6 getSchema() \u00b6 public static getSchema () Get transaction schema. Return Value \u00b6 schemas.TransactionSchema staticFee() \u00b6 public static staticFee ( feeContext : { height? : number ; data? : ITransactionData } = {}) Get the static fee for the Multi-Signature transaction type. Parameters \u00b6 Type Name Required Description object feeContext Yes Context for determining the static fee Return Value \u00b6 BigNumber verify() \u00b6 public verify () Verify transaction. Return Value \u00b6 boolean serialise() \u00b6 public serialise ( options? : ISerialiseOptions ) Serialise a Transaction object. Parameters \u00b6 Type Name Required Description ISerialiseOptions options No Serialisation options Return Value \u00b6 ByteBuffer deserialise() \u00b6 public deserialise ( buf : ByteBuffer ) Deserialise into a Transaction object. Parameters \u00b6 Type Name Required Description ByteBuffer buf Yes Buffer to deserialise Return Value \u00b6 void Crypto\\Transactions\\Types\\SecondSignatureRegistrationTransaction \u00b6 getSchema() \u00b6 public static getSchema () Get transaction schema. Return Value \u00b6 schemas.TransactionSchema serialise() \u00b6 public serialise ( options? : ISerialiseOptions ) Serialise a Transaction object. Parameters \u00b6 Type Name Required Description ISerialiseOptions options No Serialisation options Return Value \u00b6 ByteBuffer deserialise() \u00b6 public deserialise ( buf : ByteBuffer ) Deserialise into a Transaction object. Parameters \u00b6 Type Name Required Description ByteBuffer buf Yes Buffer to deserialise Return Value \u00b6 void Crypto\\Transactions\\Types\\TransferTransaction \u00b6 getSchema() \u00b6 public static getSchema () Get transaction schema. Return Value \u00b6 schemas.TransactionSchema hasVendorField() \u00b6 public hasVendorField () Verify if the transaction contains a vendorfield. Return Value \u00b6 boolean serialise() \u00b6 public serialise ( options? : ISerialiseOptions ) Perform AIP11 compliant serialisation. Parameters \u00b6 Type Name Required Description ISerialiseOptions options No Serialisation options Return Value \u00b6 ByteBuffer deserialise() \u00b6 public deserialise ( buf : ByteBuffer ) Perform AIP11 compliant deserialisation. Parameters \u00b6 Type Name Required Description ByteBuffer buf Yes Buffer to deserialise Return Value \u00b6 void Crypto\\Transactions\\Types\\VoteTransaction \u00b6 getSchema() \u00b6 public static getSchema () Get transaction schema. Return Value \u00b6 schemas.TransactionSchema serialise() \u00b6 public serialise ( options? : ISerialiseOptions ) Perform AIP11 compliant serialisation. Parameters \u00b6 Type Name Required Description ISerialiseOptions options No Serialisation options Return Value \u00b6 ByteBuffer deserialise() \u00b6 public deserialise ( buf : ByteBuffer ) Perform AIP11 compliant deserialisation. Parameters \u00b6 Type Name Required Description ByteBuffer buf Yes Buffer to deserialise Return Value \u00b6 void Crypto\\Validation\\Validator \u00b6 getInstance() \u00b6 public getInstance () Get an instance of the Validator object. Return Value \u00b6 Ajv.Ajv validate() \u00b6 public validate < T = any > ( schemaKeyRef : string | boolean | object , data : T ) Validate a schema object. Parameters \u00b6 Type Name Required Description string, boolean, object schemaKeyRef Yes Schema to validate against T data Yes Data to validate Return Value \u00b6 ISchemaValidationResult<T> validateException() \u00b6 public validateException < T = any > ( schemaKeyRef : string | boolean | object , data : T ) Validate a schema object for an exception. Parameters \u00b6 Type Name Required Description string, boolean, object schemaKeyRef Yes Schema to validate against T data Yes Data to validate Return Value \u00b6 ISchemaValidationResult<T> addFormat() \u00b6 public addFormat ( name : string , format : Ajv.FormatDefinition ) Add formatting definition used for validation. Parameters \u00b6 Type Name Required Description string name Yes Name of definition Ajv format Yes Format definition Return Value \u00b6 void addKeyword() \u00b6 public addKeyword ( keyword : string , definition : Ajv.KeywordDefinition ) Add keyword definition used for validation. Parameters \u00b6 Type Name Required Description string keyword Yes Name of definition Ajv definition Yes Keyword definition Return Value \u00b6 void addSchema() \u00b6 public addSchema ( schema : object | object [], key? : string ) Add schema used for validation. Parameters \u00b6 Type Name Required Description object schema Yes Name of schema string key No Schema Return Value \u00b6 void removeKeyword() \u00b6 public removeKeyword ( keyword : string ) Remove keyword definition from validation. Parameters \u00b6 Type Name Required Description string keyword Yes Name of definition Return Value \u00b6 void removeSchema() \u00b6 public removeSchema ( schemaKeyRef : string | boolean | object | RegExp ) Remove schema from validation. Parameters \u00b6 Type Name Required Description string, boolean, object, RegExp schemaKeyRef Yes Schema to remove Return Value \u00b6 void extendTransaction() \u00b6 public extendTransaction ( schema : TransactionSchema , remove? : boolean ) Extend a Transaction's schema for validation. Parameters \u00b6 Type Name Required Description TransactionSchema schema Yes Schema of transaction to extend boolean remove No Whether to remove the schema","title":"API Documentation"},{"location":"sdk/typescript/crypto/api-documentation/#api-documentation","text":"","title":"API Documentation"},{"location":"sdk/typescript/crypto/api-documentation/#cryptoblocksblockfactory","text":"","title":"Crypto\\Blocks\\BlockFactory"},{"location":"sdk/typescript/crypto/api-documentation/#fromhex","text":"public static fromHex ( hex : string ) Generate Block object from HEX.","title":"fromHex()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters","text":"Type Name Required Description string hex Yes Block content","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value","text":"IBlock","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#frombytes","text":"public static fromBytes ( buffer : Buffer ) Generate Block object from a Buffer.","title":"fromBytes()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_1","text":"Type Name Required Description Buffer buffer Yes Block content","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_1","text":"IBlock","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#fromjson","text":"public static fromJson ( json : IBlockJson ) Generate Block object from JSON.","title":"fromJson()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_2","text":"Type Name Required Description IBlockJson json Yes Block content","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_2","text":"IBlock","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#fromdata","text":"public static fromData ( data : IBlockData , options : { deserialiseTransactionsUnchecked? : boolean } = {}) Generate Block object from Block data.","title":"fromData()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_3","text":"Type Name Required Description IBlockData data Yes Block content object options Yes Options used for parsing block data","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_3","text":"IBlock","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptoblocksserialiser","text":"","title":"Crypto\\Blocks\\Serialiser"},{"location":"sdk/typescript/crypto/api-documentation/#size","text":"public static size ( block : IBlock ) Get size of Block.","title":"size()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_4","text":"Type Name Required Description IBlock block Yes Block object","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_4","text":"number","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#serialisewithtransactions","text":"public static serialiseWithTransactions ( block : IBlockData ) Serialise Block with Transactions.","title":"serialiseWithTransactions()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_5","text":"Type Name Required Description IBlockData block Yes Block object","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_5","text":"Buffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#serialise","text":"public static serialise ( block : IBlockData , includeSignature : boolean = true ) Serialise Block without Transactions.","title":"serialise()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_6","text":"Type Name Required Description IBlockData block Yes Block object boolean includeSignature Yes Whether to include signature in serialisation","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_6","text":"Buffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptocryptohashalgorithms","text":"","title":"Crypto\\Crypto\\HashAlgorithms"},{"location":"sdk/typescript/crypto/api-documentation/#ripemd160","text":"public static ripemd160 ( buffer : Buffer | string ) Hash with RIPEMD-160.","title":"ripemd160()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_7","text":"Type Name Required Description Buffer, string buffer Yes String or Buffer to generate hash for","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_7","text":"Buffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#sha1","text":"public static sha1 ( buffer : Buffer | string ) Hash with SHA-1.","title":"sha1()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_8","text":"Type Name Required Description Buffer, string buffer Yes String or Buffer to generate hash for","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_8","text":"Buffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#sha256","text":"public static sha256 ( buffer : Buffer | string | Buffer []) Hash with SHA-256.","title":"sha256()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_9","text":"Type Name Required Description Buffer, string buffer Yes String or Buffer to generate hash for","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_9","text":"Buffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#hash160","text":"public static hash160 ( buffer : Buffer | string ) Hash with Hash160.","title":"hash160()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_10","text":"Type Name Required Description Buffer, string buffer Yes String or Buffer to generate hash for","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_10","text":"Buffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#hash256","text":"public static hash256 ( buffer : Buffer | string ) Hash with Hash256.","title":"hash256()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_11","text":"Type Name Required Description Buffer, string buffer Yes String or Buffer to generate hash for","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_11","text":"Buffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptocryptohash","text":"","title":"Crypto\\Crypto\\Hash"},{"location":"sdk/typescript/crypto/api-documentation/#signecdsa","text":"public static signECDSA ( hash : Buffer , keys : IKeyPair ) Sign hash with ECDSA.","title":"signECDSA()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_12","text":"Type Name Required Description Buffer hash Yes Hash to sign IKeyPair keys Yes Keys to sign hash with","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_12","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#verifyecdsa","text":"public static verifyECDSA ( hash : Buffer , signature : Buffer | string , publicKey : Buffer | string ) Verify ECDSA signature.","title":"verifyECDSA()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_13","text":"Type Name Required Description Buffer hash Yes Hash to verify Buffer, string signature Yes Signature of hash Buffer, string publicKey Yes Public key of wallet which signed the hash","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_13","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#signschnorr","text":"public static signSchnorr ( hash : Buffer , keys : IKeyPair ) Sign hash with Schnorr.","title":"signSchnorr()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_14","text":"Type Name Required Description Buffer hash Yes Hash to sign IKeyPair keys Yes Keys to sign hash with","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_14","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#verifyschnorr","text":"public static verifySchnorr ( hash : Buffer , signature : Buffer | string , publicKey : Buffer | string ) Verify Schnorr signature.","title":"verifySchnorr()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_15","text":"Type Name Required Description Buffer hash Yes Hash to verify Buffer, string signature Yes Signature of hash Buffer, string publicKey Yes Public key of wallet which signed the hash","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_15","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptocryptohdwallet","text":"","title":"Crypto\\Crypto\\HDWallet"},{"location":"sdk/typescript/crypto/api-documentation/#frommnemonic","text":"public static fromMnemonic ( mnemonic : string , passphrase? : string ) Generate BIP32 Wallet from mnemonic.","title":"fromMnemonic()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_16","text":"Type Name Required Description string mnemonic Yes INSERT_DESCRIPTION string passphrase No INSERT_DESCRIPTION","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_16","text":"BIP32Interface","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#fromkeys","text":"public static fromKeys ( keys : IKeyPair , chainCode : Buffer ) Generate BIP32 Wallet from KeyPair.","title":"fromKeys()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_17","text":"Type Name Required Description IKeyPair keys Yes INSERT_DESCRIPTION Buffer chainCode Yes INSERT_DESCRIPTION","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_17","text":"BIP32Interface","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getkeys","text":"public static getKeys ( node : BIP32Interface ) Get keys for BIP32 Wallet.","title":"getKeys()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_18","text":"Type Name Required Description BIP32Interface node Yes BIP32 Wallet to get keys for","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_18","text":"IKeyPair","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#deriveslip44","text":"public static deriveSlip44 ( root : BIP32Interface , hardened : boolean = true ) Determine Slip44 for BIP32 Wallet.","title":"deriveSlip44()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_19","text":"Type Name Required Description BIP32Interface root Yes BIP32 Wallet to determine Slip44 for boolean hardened Yes INSERT_DESCRIPTION","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_19","text":"BIP32Interface","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#derivenetwork","text":"public static deriveNetwork ( root : BIP32Interface ) Determine Network for BIP32 Wallet.","title":"deriveNetwork()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_20","text":"Type Name Required Description BIP32Interface root Yes BIP32 Wallet to determine network for","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_20","text":"BIP32Interface","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptocryptomessage","text":"","title":"Crypto\\Crypto\\Message"},{"location":"sdk/typescript/crypto/api-documentation/#sign","text":"public static sign ( message : string , passphrase : string ) Sign a message using the given passphrase.","title":"sign()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_21","text":"Type Name Required Description string message Yes Message string passphrase Yes Passphrase","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_21","text":"IMessage","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#signwithwif","text":"public static signWithWif ( message : string , wif : string , network? : INetwork ) Sign a message using the given WIF string.","title":"signWithWif()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_22","text":"Type Name Required Description string message Yes Message string wif Yes Network WIF INetwork network No Network","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_22","text":"IMessage","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#verify","text":"public static verify ({ message , publicKey , signature } : IMessage ) Verify the message contents","title":"verify()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_23","text":"Type Name Required Description IMessage object Yes Message","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_23","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptocryptoslots","text":"","title":"Crypto\\Crypto\\Slots"},{"location":"sdk/typescript/crypto/api-documentation/#gettime","text":"public static getTime ( time? : number ) Get the time diff between now and network start.","title":"getTime()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_24","text":"Type Name Required Description number time No Network start time","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_24","text":"number","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#gettimeinmsuntilnextslot","text":"public static getTimeInMsUntilNextSlot () Get the time (in milliseconds) until the start of the next slot.","title":"getTimeInMsUntilNextSlot()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_25","text":"number","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getslotnumber","text":"public static getSlotNumber ( epoch? : number ) Get the slot number.","title":"getSlotNumber()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_25","text":"Type Name Required Description number epoch No Epoch time","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_26","text":"number","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getslottime","text":"public static getSlotTime ( slot : number ) Get the slot time.","title":"getSlotTime()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_26","text":"Type Name Required Description number slot Yes Slot","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_27","text":"number","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getnextslot","text":"public static getNextSlot () Get the next slot.","title":"getNextSlot()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_28","text":"number","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#isforgingallowed","text":"public static isForgingAllowed ( epoch? : number ) Verify is forging is allowed.","title":"isForgingAllowed()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_27","text":"Type Name Required Description number epoch No Epoch time","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_29","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptoidentitiesaddress","text":"","title":"Crypto\\Identities\\Address"},{"location":"sdk/typescript/crypto/api-documentation/#frompassphrase","text":"public static fromPassphrase ( passphrase : string , networkVersion? : number ) Derive the address from the given passphrase.","title":"fromPassphrase()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_28","text":"Type Name Required Description string passphrase Yes Passphrase number networkVersion No Version of the network","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_30","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#frompublickey","text":"public static fromPublicKey ( publicKey : string , networkVersion? : number ) Derive a (multisig) address from a multi signature asset.","title":"fromPublicKey()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_29","text":"Type Name Required Description string publicKey Yes Public key number networkVersion No Version of the network","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_31","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#fromwif","text":"public static fromWIF ( wif : string , network? : NetworkType ) Derive the address from a WIF string.","title":"fromWIF()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_30","text":"Type Name Required Description string wif Yes WIF NetworkType network No Network to generate address for","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_32","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#frommultisignatureasset","text":"public static fromMultiSignatureAsset ( asset : IMultiSignatureAsset , networkVersion? : number ) Derive the address from the given multi signature asset.","title":"fromMultiSignatureAsset()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_31","text":"Type Name Required Description IMultiSignatureAsset asset Yes Address to validate number networkVersion No Version of the network","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_33","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#fromprivatekey","text":"public static fromPrivateKey ( privateKey , networkVersion? : number ) Derive the address from the given private key.","title":"fromPrivateKey()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_32","text":"Type Name Required Description any privateKey Yes Private key to derive address for number networkVersion No Version of the network","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_34","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#frombuffer","text":"public static fromBuffer ( buffer : Buffer ) Derive the address from a Buffer.","title":"fromBuffer()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_33","text":"Type Name Required Description Buffer buffer Yes Buffer to derive address from","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_35","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#tobuffer","text":"public static toBuffer ( address : string ) Convert address to a Buffer.","title":"toBuffer()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_34","text":"Type Name Required Description string address Yes Address to convert to buffer","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_36","text":"{ addressBuffer: Buffer; addressError?: string }","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#validate","text":"public static validate ( address : string , networkVersion? : number ) Validate the given address.","title":"validate()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_35","text":"Type Name Required Description string address Yes Address to validate number networkVersion No Version of the network","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_37","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptoidentitieskeys","text":"","title":"Crypto\\Identities\\Keys"},{"location":"sdk/typescript/crypto/api-documentation/#frompassphrase_1","text":"public static fromPassphrase ( passphrase : string , compressed : boolean = true ) Derive the keys from the given passphrase.","title":"fromPassphrase()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_36","text":"Type Name Required Description string passphrase Yes Passphrase boolean compressed Yes Compression flag","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_38","text":"IKeyPair","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#fromprivatekey_1","text":"public static fromPrivateKey ( privateKey : Buffer | string , compressed : boolean = true ) Derive the keys from the given private key.","title":"fromPrivateKey()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_37","text":"Type Name Required Description Buffer, string privateKey Yes Private Key to derive keys from boolean compressed Yes Compression flag","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_39","text":"IKeyPair","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#fromwif_1","text":"public static fromWIF ( wifKey : string , network? : INetwork ) Derive the keys from the given WIF.","title":"fromWIF()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_38","text":"Type Name Required Description string wifKey Yes Private key INetwork network No Network","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_40","text":"IKeyPair","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptoidentitiesprivatekey","text":"","title":"Crypto\\Identities\\PrivateKey"},{"location":"sdk/typescript/crypto/api-documentation/#frompassphrase_2","text":"public static fromPassphrase ( passphrase : string ) Derive the private key for the given passphrase.","title":"fromPassphrase()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_39","text":"Type Name Required Description string passphrase Yes Passphrase","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_41","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#fromwif_2","text":"public static fromWIF ( wif : string , network? : NetworkType ) Create a private key instance from a hex string.","title":"fromWIF()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_40","text":"Type Name Required Description string wif Yes Network WIF NetworkType network No Network","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_42","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptoidentitiespublickey","text":"","title":"Crypto\\Identities\\PublicKey"},{"location":"sdk/typescript/crypto/api-documentation/#frompassphrase_3","text":"public static fromPassphrase ( passphrase : string ) Derive the public key from the given passphrase.","title":"fromPassphrase()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_41","text":"Type Name Required Description string passphrase Yes Passphrase","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_43","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#fromwif_3","text":"public static fromWIF ( wif : string , network? : NetworkType ) Derive the public key from the given WIF.","title":"fromWIF()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_42","text":"Type Name Required Description string wif Yes WIF to derive public key from NetworkType network No Network","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_44","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#frommultisignatureasset_1","text":"public static fromMultiSignatureAsset ( asset : IMultiSignatureAsset ) Derive the public key from the given multi signature asset.","title":"fromMultiSignatureAsset()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_43","text":"Type Name Required Description IMultiSignatureAsset asset Yes Asset","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_45","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#validate_1","text":"public static validate ( publicKey : string , networkVersion? : number ) Validate the given public key.","title":"validate()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_44","text":"Type Name Required Description string publicKey Yes Public key number networkVersion No Network version","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_46","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptoidentitieswif","text":"","title":"Crypto\\Identities\\WIF"},{"location":"sdk/typescript/crypto/api-documentation/#frompassphrase_4","text":"public static fromPassphrase ( passphrase : string , network? : INetwork ) Derive the WIF from the given passphrase.","title":"fromPassphrase()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_45","text":"Type Name Required Description string passphrase Yes Passphrase to derive WIF from INetwork network No Network wif","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_47","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#fromkeys_1","text":"public static fromKeys ( keys : IKeyPair , network? : INetwork ) Derive the WIF from the given keys.","title":"fromKeys()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_46","text":"Type Name Required Description IKeyPair keys Yes Keys INetwork network No Network","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_48","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptomanagersconfigmanager","text":"","title":"Crypto\\Managers\\ConfigManager"},{"location":"sdk/typescript/crypto/api-documentation/#setconfig","text":"public setConfig ( config : INetworkConfig ) Set the configuration.","title":"setConfig()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_47","text":"Type Name Required Description INetworkConfig config Yes Network configuration object","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_49","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#setfrompreset","text":"public setFromPreset ( network : NetworkName ) Set the configuration from given presets.","title":"setFromPreset()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_48","text":"Type Name Required Description NetworkName network Yes Preset","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_50","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getpreset","text":"public getPreset ( network : NetworkName ) Get configuration preset.","title":"getPreset()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_49","text":"Type Name Required Description NetworkName network Yes Preset","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_51","text":"INetworkConfig","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#all","text":"public all () Get all configs.","title":"all()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_52","text":"INetworkConfig","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#set","text":"public set < T = any > ( key : string , value : T ) Set a value for the specified network config key.","title":"set()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_50","text":"Type Name Required Description string key Yes Key to set T value Yes Value to set","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_53","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#get","text":"public get < T = any > ( key : string ) Get key.","title":"get()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_51","text":"Type Name Required Description string key Yes Key to get","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_54","text":"T","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#setheight","text":"public setHeight ( value : number ) Set network height.","title":"setHeight()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_52","text":"Type Name Required Description number value Yes Network height","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_55","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getheight","text":"public getHeight () Get network height.","title":"getHeight()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_56","text":"number","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#isnewmilestone","text":"public isNewMilestone ( height? : number ) Verify if current height contains a milestone.","title":"isNewMilestone()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_53","text":"Type Name Required Description number height No Height to check for milestone","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_57","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getmilestone","text":"public getMilestone ( height? : number ) Get milestone.","title":"getMilestone()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_54","text":"Type Name Required Description number height No Network height","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_58","text":"{ [key: string]: any }","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getmilestones","text":"public getMilestones () Get all milestones.","title":"getMilestones()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_59","text":"any","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptomanagersnetworkmanager","text":"","title":"Crypto\\Managers\\NetworkManager"},{"location":"sdk/typescript/crypto/api-documentation/#all_1","text":"public static all () Get settings for all networks.","title":"all()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_60","text":"Record<NetworkName, INetworkConfig>","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#findbyname","text":"public static findByName ( name : NetworkName ) Get settings for a selected network, default network is testnet.","title":"findByName()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_55","text":"Type Name Required Description NetworkName name Yes Network name","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_61","text":"INetworkConfig","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsdeserialiser","text":"","title":"Crypto\\Transactions\\Deserialiser"},{"location":"sdk/typescript/crypto/api-documentation/#deserialise","text":"public static deserialise ( serialised : string | Buffer , options : IDeserialiseOptions = {}) Deserialise Transaction into object.","title":"deserialise()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_56","text":"Type Name Required Description string, Buffer serialised Yes Serialised transaction IDeserialiseOptions options Yes Options for deserialising","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_62","text":"ITransaction","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#applyv1compatibility","text":"public static applyV1Compatibility ( transaction : ITransactionData ) Modify transaction to be v1 compatible.","title":"applyV1Compatibility()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_57","text":"Type Name Required Description ITransactionData transaction Yes Transaction object","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_63","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionstransactionfactory","text":"","title":"Crypto\\Transactions\\TransactionFactory"},{"location":"sdk/typescript/crypto/api-documentation/#fromhex_1","text":"public static fromHex ( hex : string ) Create Transaction object from HEX.","title":"fromHex()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_58","text":"Type Name Required Description string hex Yes HEX of transaction","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_64","text":"ITransaction","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#frombytes_1","text":"public static fromBytes ( buffer : Buffer , strict : boolean = true ) Create Transaction object from Buffer.","title":"fromBytes()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_59","text":"Type Name Required Description Buffer buffer Yes Transaction buffer boolean strict Yes Strict creation from buffer","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_65","text":"ITransaction","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#frombytesunsafe","text":"public static fromBytesUnsafe ( buffer : Buffer , id? : string ) Create Transaction object from Buffer (unsafe). NOTE: Only use this internally when it is safe to assume the buffer has already been verified.","title":"fromBytesUnsafe()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_60","text":"Type Name Required Description Buffer buffer Yes Transaction buffer string id No ID override","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_66","text":"ITransaction","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#fromjson_1","text":"public static fromJson ( json : ITransactionJson ) Create Transaction object from JSON.","title":"fromJson()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_61","text":"Type Name Required Description ITransactionJson json Yes Transaction JSON object","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_67","text":"ITransaction","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#fromdata_1","text":"public static fromData ( data : ITransactionData , strict : boolean = true ) Create Transaction object from Transaction data.","title":"fromData()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_62","text":"Type Name Required Description ITransactionData data Yes Transaction object boolean strict Yes Strict conversion","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_68","text":"ITransaction","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsserialiser","text":"","title":"Crypto\\Transactions\\Serialiser"},{"location":"sdk/typescript/crypto/api-documentation/#getbytes","text":"public static getBytes ( transaction : ITransactionData , options : ISerialiseOptions = {}) Convert the transaction to its byte representation.","title":"getBytes()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_63","text":"Type Name Required Description ITransactionData transaction Yes Transaction ISerialiseOptions options Yes Options","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_69","text":"Buffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#serialise_1","text":"public static serialise ( transaction : ITransaction , options : ISerialiseOptions = {}) Perform AIP11 compliant serialisation.","title":"serialise()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_64","text":"Type Name Required Description ITransaction transaction Yes Transaction ISerialiseOptions options Yes Options","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_70","text":"Buffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionssigner","text":"","title":"Crypto\\Transactions\\Signer"},{"location":"sdk/typescript/crypto/api-documentation/#sign_1","text":"public static sign ( transaction : ITransactionData , keys : IKeyPair , options? : ISerialiseOptions ) Sign the given transaction with the provided keys.","title":"sign()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_65","text":"Type Name Required Description ITransactionData transaction Yes Transaction IKeyPair keys Yes Keys ISerialiseOptions options No Options","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_71","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#secondsign","text":"public static secondSign ( transaction : ITransactionData , keys : IKeyPair ) Second sign the given transaction with the provided keys.","title":"secondSign()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_66","text":"Type Name Required Description ITransactionData transaction Yes Transaction IKeyPair keys Yes Keys","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_72","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#multisign","text":"public static multiSign ( transaction : ITransactionData , keys : IKeyPair , index : number = - 1 ) Multi sign the given transaction with the provided keys.","title":"multiSign()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_67","text":"Type Name Required Description ITransactionData transaction Yes Transaction IKeyPair keys Yes Keys number index Yes Index","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_73","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsutils","text":"","title":"Crypto\\Transactions\\Utils"},{"location":"sdk/typescript/crypto/api-documentation/#tobytes","text":"public static toBytes ( data : ITransactionData ) Convert Transaction object to Buffer.","title":"toBytes()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_68","text":"Type Name Required Description ITransactionData data Yes Transaction object","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_74","text":"Buffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#tohash","text":"public static toHash ( transaction : ITransactionData , options? : ISerialieOptions ) Convert Transaction object to Hash.","title":"toHash()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_69","text":"Type Name Required Description ITransactionData transaction Yes Transaction object ISerialiseOptions options No Serialisation options for generating hash","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_75","text":"Buffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getid","text":"public static getId ( transaction : ITransactionData , options : ISerialiseOptions = {}) Get Transaction ID of Transaction object.","title":"getId()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_70","text":"Type Name Required Description ITransactionData transaction Yes Transaction object ISerialiseOptions options Yes Serialisation options for generating hash","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_76","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsverifier","text":"","title":"Crypto\\Transactions\\Verifier"},{"location":"sdk/typescript/crypto/api-documentation/#verify_1","text":"public static verify ( data : ITransactionData ) Verify transaction.","title":"verify()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_71","text":"Type Name Required Description ITransactionData data Yes Transaction object","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_77","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#verifysecondsignature","text":"public static verifySecondSignature ( transaction : ITransactionData , publicKey : string ) Verify second signature.","title":"verifySecondSignature()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_72","text":"Type Name Required Description ITransactionData transaction Yes Transaction object string publicKey Yes Public key","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_78","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#verifysignatures","text":"public static verifySignatures ( transaction : ITransactionData , multiSignature : IMultiSignatureAsset ) Verify the signatures of a Transaction object.","title":"verifySignatures()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_73","text":"Type Name Required Description ITransactionData transaction Yes Transaction object IMultiSignatureAsset multiSignature Yes Asset for Multi-Signature wallets/transactions","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_79","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#verifyhash","text":"public static verifyHash ( data : ITransactionData ) Verify transaction hash.","title":"verifyHash()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_74","text":"Type Name Required Description ITransactionData data Yes Transaction","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_80","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#verifyschema","text":"public static verifySchema ( data : ITransactionData , strict : boolean = true ) Verify transaction schema.","title":"verifySchema()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_75","text":"Type Name Required Description ITransactionData data Yes Transaction boolean strict Yes Strict flag","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_81","text":"ISchemaValidationResult","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsbuildersbuilderfactory","text":"","title":"Crypto\\Transactions\\Builders\\BuilderFactory"},{"location":"sdk/typescript/crypto/api-documentation/#transfer","text":"public static transfer () Initiate a Transfer transaction type.","title":"transfer()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_82","text":"TransferBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#secondsignature","text":"public static secondSignature () Initiate a Second Signature transaction type.","title":"secondSignature()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_83","text":"SecondSignatureBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#delegateregistration","text":"public static delegateRegistration () Initiate a Delegate Resignation transaction type.","title":"delegateRegistration()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_84","text":"DelegateRegistrationBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#vote","text":"public static vote () Initiate a Vote transaction type.","title":"vote()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_85","text":"VoteBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#multisignature","text":"public static multiSignature () Initiate a Multi-Signature transaction type.","title":"multiSignature()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_86","text":"MultiSignatureBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#ipfs","text":"public static ipfs () Initiate an IPFS transaction type.","title":"ipfs()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_87","text":"IPFSBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#multipayment","text":"public static multiPayment () Initiate a Multi-Payment transaction type.","title":"multiPayment()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_88","text":"MultiPaymentBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#delegateresignation","text":"public static delegateResignation () Initiate a Delegate Resignation transaction type.","title":"delegateResignation()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_89","text":"DelegateResignationBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#htlclock","text":"public static htlcLock () Initiate a HTLC Lock transaction type.","title":"htlcLock()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_90","text":"HtlcLockBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#htlcclaim","text":"public static htlcClaim () Initiate a HTLC Claim transaction type.","title":"htlcClaim()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_91","text":"HtlcClaimBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#htlcrefund","text":"public static htlcRefund () Initiate a HTLC Refund transaction type.","title":"htlcRefund()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_92","text":"HtlcRefundBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsbuilderstransactionsdelegateregistrationbuilder","text":"","title":"Crypto\\Transactions\\Builders\\Transactions\\DelegateRegistrationBuilder"},{"location":"sdk/typescript/crypto/api-documentation/#usernameasset","text":"public usernameAsset ( username : string ) Set the username to assign.","title":"usernameAsset()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_76","text":"Type Name Required Description string username Yes Delegate username","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_93","text":"DelegateRegistrationBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getstruct","text":"public getStruct () Get transaction structure.","title":"getStruct()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_94","text":"ITransactionData","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsbuilderstransactionsdelegateresignationbuilder","text":"","title":"Crypto\\Transactions\\Builders\\Transactions\\DelegateResignationBuilder"},{"location":"sdk/typescript/crypto/api-documentation/#getstruct_1","text":"public getStruct () Get transaction structure.","title":"getStruct()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_95","text":"ITransactionData","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsbuilderstransactionshtlcclaimbuilder","text":"","title":"Crypto\\Transactions\\Builders\\Transactions\\HtlcClaimBuilder"},{"location":"sdk/typescript/crypto/api-documentation/#htlcclaimasset","text":"public htlcClaimAsset ( claimAsset : IHtlcClaimAsset ) Specify the HTLC Claim asset data for the Transaction.","title":"htlcClaimAsset()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_77","text":"Type Name Required Description IHtlcClaimAsset claimAsset Yes Asset for a HTLC Claim","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_96","text":"HtlcClaimBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getstruct_2","text":"public getStruct () Get transaction structure.","title":"getStruct()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_97","text":"ITransactionData","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsbuilderstransactionshtlclockbuilder","text":"","title":"Crypto\\Transactions\\Builders\\Transactions\\HtlcLockBuilder"},{"location":"sdk/typescript/crypto/api-documentation/#htlclockasset","text":"public htlcLockAsset ( lockAsset : IHtlcLockAsset ) Specify the HTLC Lock asset data for the Transaction.","title":"htlcLockAsset()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_78","text":"Type Name Required Description IHtlcLockAsset lockAsset Yes Asset for a HTLC Lock","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_98","text":"HtlcLockBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getstruct_3","text":"public getStruct () Get transaction structure.","title":"getStruct()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_99","text":"ITransactionData","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsbuilderstransactionshtlcrefundbuilder","text":"","title":"Crypto\\Transactions\\Builders\\Transactions\\HtlcRefundBuilder"},{"location":"sdk/typescript/crypto/api-documentation/#htlcrefundasset","text":"public htlcRefundAsset ( refundAsset : IHtlcRefundAsset ) Specify the HTLC Refund asset data for the Transaction.","title":"htlcRefundAsset()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_79","text":"Type Name Required Description IHtlcRefundAsset refundAsset Yes Asset for a HTLC Refund","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_100","text":"HtlcRefundBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getstruct_4","text":"public getStruct () Get transaction structure.","title":"getStruct()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_101","text":"ITransactionData","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsbuilderstransactionsipfsbuilder","text":"","title":"Crypto\\Transactions\\Builders\\Transactions\\IPFSBuilder"},{"location":"sdk/typescript/crypto/api-documentation/#ipfsasset","text":"public ipfsAsset ( ipfsId : string ) Set IPFS asset.","title":"ipfsAsset()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_80","text":"Type Name Required Description string ipfsId Yes IPFS ID","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_102","text":"IPFSBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getstruct_5","text":"public getStruct () Get transaction structure.","title":"getStruct()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_103","text":"ITransactionData","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsbuilderstransactionsmultipaymentbuilder","text":"","title":"Crypto\\Transactions\\Builders\\Transactions\\MultiPaymentBuilder"},{"location":"sdk/typescript/crypto/api-documentation/#addpayment","text":"public addPayment ( recipientId : string , amount : string ) Add a new payment to the collection.","title":"addPayment()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_81","text":"Type Name Required Description string recipientId Yes Recipient identifier string amount Yes Transaction amount","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_104","text":"MultiPaymentBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getstruct_6","text":"public getStruct () Get transaction structure.","title":"getStruct()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_105","text":"ITransactionData","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsbuilderstransactionsmultisignaturebuilder","text":"","title":"Crypto\\Transactions\\Builders\\Transactions\\MultiSignatureBuilder"},{"location":"sdk/typescript/crypto/api-documentation/#participant","text":"public participant ( publicKey : string ) Add participant to multi signature transaction.","title":"participant()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_82","text":"Type Name Required Description string publicKey Yes Public key","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_106","text":"MultiSignatureBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#min","text":"public min ( min : number ) Set the minimum required signatures.","title":"min()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_83","text":"Type Name Required Description number min Yes Minimum required signatures","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_107","text":"MultiSignatureBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#multisignatureasset","text":"public multiSignatureAsset ( multiSignature : IMultiSignatureAsset ) Derive the address from the given multi signature asset.","title":"multiSignatureAsset()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_84","text":"Type Name Required Description IMultiSignatureAsset multiSignature Yes Multi signature asset","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_108","text":"MultiSignatureBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getstruct_7","text":"public getStruct () Get transaction structure.","title":"getStruct()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_109","text":"ITransactionData","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsbuilderstransactionssecondsignaturebuilder","text":"","title":"Crypto\\Transactions\\Builders\\Transactions\\SecondSignatureBuilder"},{"location":"sdk/typescript/crypto/api-documentation/#signatureasset","text":"public signatureAsset ( secondPassphrase : string ) Specify the Second Signature asset data for the Transaction.","title":"signatureAsset()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_85","text":"Type Name Required Description string secondPassphrase Yes Asset for a Second Signature","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_110","text":"SecondSignatureBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getstruct_8","text":"public getStruct () Get transaction structure.","title":"getStruct()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_111","text":"ITransactionData","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsbuilderstransactionstransferbuilder","text":"","title":"Crypto\\Transactions\\Builders\\Transactions\\TransferBuilder"},{"location":"sdk/typescript/crypto/api-documentation/#expiration","text":"public expiration ( expiration : number ) Set Transfer expiration.","title":"expiration()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_86","text":"Type Name Required Description number expiration Yes The block-height or time when the transaction should expire","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_112","text":"TransferBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getstruct_9","text":"public getStruct () Get transaction structure.","title":"getStruct()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_113","text":"ITransactionData","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionsbuilderstransactionsvotebuilder","text":"","title":"Crypto\\Transactions\\Builders\\Transactions\\VoteBuilder"},{"location":"sdk/typescript/crypto/api-documentation/#votesasset","text":"public votesAsset ( votes : string []) Specify the Vote asset data for the Transaction.","title":"votesAsset()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_87","text":"Type Name Required Description string votes Yes Asset for a Vote","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_114","text":"VoteBuilder","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#getstruct_10","text":"public getStruct () Get transaction structure.","title":"getStruct()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_115","text":"ITransactionData","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionstypesdelegateregistrationtransaction","text":"","title":"Crypto\\Transactions\\Types\\DelegateRegistrationTransaction"},{"location":"sdk/typescript/crypto/api-documentation/#getschema","text":"public static getSchema () Get transaction schema.","title":"getSchema()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_116","text":"schemas.TransactionSchema","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#serialise_2","text":"public serialise ( options? : ISerialiseOptions ) Handle the serialisation of \"delegate registration\" data.","title":"serialise()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_88","text":"Type Name Required Description ISerialiseOptions options No Options","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_117","text":"ByteBuffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#deserialise_1","text":"public deserialise ( buf : ByteBuffer ) Handle the deserialisation of \"delegate registration\" data.","title":"deserialise()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_89","text":"Type Name Required Description ByteBuffer buf Yes Buffer","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_118","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionstypesdelegateresignationtransaction","text":"","title":"Crypto\\Transactions\\Types\\DelegateResignationTransaction"},{"location":"sdk/typescript/crypto/api-documentation/#getschema_1","text":"public static getSchema () Get transaction schema.","title":"getSchema()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_119","text":"schemas.TransactionSchema","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#verify_2","text":"public verify () Verify transaction.","title":"verify()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_120","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#serialise_3","text":"public serialise ( options? : ISerialiseOptions ) Handle the serialisation of \"delegate resignation\" data.","title":"serialise()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_90","text":"Type Name Required Description ISerialiseOptions options No Options","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_121","text":"ByteBuffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#deserialise_2","text":"public deserialise ( buf : ByteBuffer ) Handle the deserialisation of \"delegate resignation\" data.","title":"deserialise()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_91","text":"Type Name Required Description ByteBuffer buf Yes Buffer","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_122","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionstypestransactiontypefactory","text":"","title":"Crypto\\Transactions\\Types\\TransactionTypeFactory"},{"location":"sdk/typescript/crypto/api-documentation/#initialise","text":"public static initialise ( transactionTypes : Map < InternalTransactionType , TransactionConstructor > ) Initialise new transaction types factory.","title":"initialise()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_92","text":"Type Name Required Description Map transactionTypes Yes INSERT_DESCRIPTION","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#create","text":"public static create ( data : ITransactionData ) Create new transaction type.","title":"create()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_93","text":"Type Name Required Description ITransactionData data Yes Transaction object","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_123","text":"ITransaction","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#get_1","text":"public static get ( type : number , typeGroup? : number ) Get a transaction type.","title":"get()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_94","text":"Type Name Required Description number type Yes Transaction type number typeGroup No Transaction group","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_124","text":"TransactionConstructor","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionstypeshtlcclaimtransaction","text":"","title":"Crypto\\Transactions\\Types\\HtlcClaimTransaction"},{"location":"sdk/typescript/crypto/api-documentation/#getschema_2","text":"public static getSchema () Get transaction schema.","title":"getSchema()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_125","text":"schemas.TransactionSchema","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#verify_3","text":"public verify () Verify transaction.","title":"verify()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_126","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#serialise_4","text":"public serialise ( options? : ISerialiseOptions ) Serialise Transaction object.","title":"serialise()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_95","text":"Type Name Required Description ISerialiseOptions options No Serialisation options","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_127","text":"ByteBuffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#deserialise_3","text":"public deserialise ( buf : ByteBuffer ) Deserialise into Transaction object.","title":"deserialise()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_96","text":"Type Name Required Description ByteBuffer buf Yes Buffer to deserialise","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_128","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionstypeshtlclocktransaction","text":"","title":"Crypto\\Transactions\\Types\\HtlcLockTransaction"},{"location":"sdk/typescript/crypto/api-documentation/#getschema_3","text":"public static getSchema () Get transaction schema.","title":"getSchema()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_129","text":"schemas.TransactionSchema","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#verify_4","text":"public verify () Verify transaction.","title":"verify()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_130","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#hasvendorfield","text":"public hasVendorField () Verify if the transaction contains a vendorfield.","title":"hasVendorField()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_131","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#serialise_5","text":"public serialise ( options? : ISerialiseOptions ) Serialise a Transaction object.","title":"serialise()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_97","text":"Type Name Required Description ISerialiseOptions options No Serialisation options","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_132","text":"ByteBuffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#deserialise_4","text":"public deserialise ( buf : ByteBuffer ) Deserialise into a Transaction object.","title":"deserialise()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_98","text":"Type Name Required Description ByteBuffer buf Yes Buffer to deserialise","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_133","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionstypeshtlcrefundtransaction","text":"","title":"Crypto\\Transactions\\Types\\HtlcRefundTransaction"},{"location":"sdk/typescript/crypto/api-documentation/#getschema_4","text":"public static getSchema () Get transaction schema.","title":"getSchema()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_134","text":"schemas.TransactionSchema","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#verify_5","text":"public verify () Verify transaction.","title":"verify()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_135","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#serialise_6","text":"public serialise ( options? : ISerialiseOptions ) Serialise a Transaction object.","title":"serialise()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_99","text":"Type Name Required Description ISerialiseOptions options No Serialisation options","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_136","text":"ByteBuffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#deserialise_5","text":"public deserialise ( buf : ByteBuffer ) Deserialise into a Transaction object.","title":"deserialise()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_100","text":"Type Name Required Description ByteBuffer buf Yes Buffer to deserialise","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_137","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionstypesinternaltransactiontype","text":"","title":"Crypto\\Transactions\\Types\\InternalTransactionType"},{"location":"sdk/typescript/crypto/api-documentation/#from","text":"public static from ( type : number , typeGroup? : number ) Create new internal transaction type from existing type.","title":"from()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_101","text":"Type Name Required Description number type Yes Transaction type number typeGroup No Transaction group","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_138","text":"InternalTransactionType","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#tostring","text":"public toString () Convert transaction type to a group/type string representation (E.g. 1/0)","title":"toString()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_139","text":"string","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionstypesipfstransaction","text":"","title":"Crypto\\Transactions\\Types\\IpfsTransaction"},{"location":"sdk/typescript/crypto/api-documentation/#getschema_5","text":"public static getSchema () Get transaction schema.","title":"getSchema()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_140","text":"schemas.TransactionSchema","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#verify_6","text":"public verify () Verify transaction.","title":"verify()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_141","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#serialise_7","text":"public serialise ( options? : ISerialiseOptions ) Handle the serialisation of \"IPFS\" data.","title":"serialise()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_102","text":"Type Name Required Description ISerialiseOptions options No Options","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_142","text":"ByteBuffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#deserialise_6","text":"public deserialise ( buf : ByteBuffer ) Handle the deserialisation of \"IPFS\" data.","title":"deserialise()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_103","text":"Type Name Required Description ByteBuffer buf Yes Buffer","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_143","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionstypesmultipaymenttransaction","text":"","title":"Crypto\\Transactions\\Types\\MultiPaymentTransaction"},{"location":"sdk/typescript/crypto/api-documentation/#getschema_6","text":"public static getSchema () Get transaction schema.","title":"getSchema()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_144","text":"schemas.TransactionSchema","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#verify_7","text":"public verify () Verify transaction.","title":"verify()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_145","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#hasvendorfield_1","text":"public hasVendorField () Verify if the transaction contains a vendorfield.","title":"hasVendorField()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_146","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#serialise_8","text":"public serialise ( options? : ISerialiseOptions ) Serialise a Transaction object.","title":"serialise()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_104","text":"Type Name Required Description ISerialiseOptions options No Serialisation options","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_147","text":"ByteBuffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#deserialise_7","text":"public deserialise ( buf : ByteBuffer ) Deserialise into a Transaction object.","title":"deserialise()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_105","text":"Type Name Required Description ByteBuffer buf Yes Buffer to deserialise","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_148","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionstypesmultisignatureregistrationtransaction","text":"","title":"Crypto\\Transactions\\Types\\MultiSignatureRegistrationTransaction"},{"location":"sdk/typescript/crypto/api-documentation/#getschema_7","text":"public static getSchema () Get transaction schema.","title":"getSchema()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_149","text":"schemas.TransactionSchema","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#staticfee","text":"public static staticFee ( feeContext : { height? : number ; data? : ITransactionData } = {}) Get the static fee for the Multi-Signature transaction type.","title":"staticFee()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_106","text":"Type Name Required Description object feeContext Yes Context for determining the static fee","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_150","text":"BigNumber","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#verify_8","text":"public verify () Verify transaction.","title":"verify()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_151","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#serialise_9","text":"public serialise ( options? : ISerialiseOptions ) Serialise a Transaction object.","title":"serialise()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_107","text":"Type Name Required Description ISerialiseOptions options No Serialisation options","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_152","text":"ByteBuffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#deserialise_8","text":"public deserialise ( buf : ByteBuffer ) Deserialise into a Transaction object.","title":"deserialise()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_108","text":"Type Name Required Description ByteBuffer buf Yes Buffer to deserialise","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_153","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionstypessecondsignatureregistrationtransaction","text":"","title":"Crypto\\Transactions\\Types\\SecondSignatureRegistrationTransaction"},{"location":"sdk/typescript/crypto/api-documentation/#getschema_8","text":"public static getSchema () Get transaction schema.","title":"getSchema()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_154","text":"schemas.TransactionSchema","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#serialise_10","text":"public serialise ( options? : ISerialiseOptions ) Serialise a Transaction object.","title":"serialise()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_109","text":"Type Name Required Description ISerialiseOptions options No Serialisation options","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_155","text":"ByteBuffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#deserialise_9","text":"public deserialise ( buf : ByteBuffer ) Deserialise into a Transaction object.","title":"deserialise()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_110","text":"Type Name Required Description ByteBuffer buf Yes Buffer to deserialise","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_156","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionstypestransfertransaction","text":"","title":"Crypto\\Transactions\\Types\\TransferTransaction"},{"location":"sdk/typescript/crypto/api-documentation/#getschema_9","text":"public static getSchema () Get transaction schema.","title":"getSchema()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_157","text":"schemas.TransactionSchema","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#hasvendorfield_2","text":"public hasVendorField () Verify if the transaction contains a vendorfield.","title":"hasVendorField()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_158","text":"boolean","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#serialise_11","text":"public serialise ( options? : ISerialiseOptions ) Perform AIP11 compliant serialisation.","title":"serialise()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_111","text":"Type Name Required Description ISerialiseOptions options No Serialisation options","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_159","text":"ByteBuffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#deserialise_10","text":"public deserialise ( buf : ByteBuffer ) Perform AIP11 compliant deserialisation.","title":"deserialise()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_112","text":"Type Name Required Description ByteBuffer buf Yes Buffer to deserialise","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_160","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptotransactionstypesvotetransaction","text":"","title":"Crypto\\Transactions\\Types\\VoteTransaction"},{"location":"sdk/typescript/crypto/api-documentation/#getschema_10","text":"public static getSchema () Get transaction schema.","title":"getSchema()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_161","text":"schemas.TransactionSchema","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#serialise_12","text":"public serialise ( options? : ISerialiseOptions ) Perform AIP11 compliant serialisation.","title":"serialise()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_113","text":"Type Name Required Description ISerialiseOptions options No Serialisation options","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_162","text":"ByteBuffer","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#deserialise_11","text":"public deserialise ( buf : ByteBuffer ) Perform AIP11 compliant deserialisation.","title":"deserialise()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_114","text":"Type Name Required Description ByteBuffer buf Yes Buffer to deserialise","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_163","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#cryptovalidationvalidator","text":"","title":"Crypto\\Validation\\Validator"},{"location":"sdk/typescript/crypto/api-documentation/#getinstance","text":"public getInstance () Get an instance of the Validator object.","title":"getInstance()"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_164","text":"Ajv.Ajv","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#validate_2","text":"public validate < T = any > ( schemaKeyRef : string | boolean | object , data : T ) Validate a schema object.","title":"validate()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_115","text":"Type Name Required Description string, boolean, object schemaKeyRef Yes Schema to validate against T data Yes Data to validate","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_165","text":"ISchemaValidationResult<T>","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#validateexception","text":"public validateException < T = any > ( schemaKeyRef : string | boolean | object , data : T ) Validate a schema object for an exception.","title":"validateException()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_116","text":"Type Name Required Description string, boolean, object schemaKeyRef Yes Schema to validate against T data Yes Data to validate","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_166","text":"ISchemaValidationResult<T>","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#addformat","text":"public addFormat ( name : string , format : Ajv.FormatDefinition ) Add formatting definition used for validation.","title":"addFormat()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_117","text":"Type Name Required Description string name Yes Name of definition Ajv format Yes Format definition","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_167","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#addkeyword","text":"public addKeyword ( keyword : string , definition : Ajv.KeywordDefinition ) Add keyword definition used for validation.","title":"addKeyword()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_118","text":"Type Name Required Description string keyword Yes Name of definition Ajv definition Yes Keyword definition","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_168","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#addschema","text":"public addSchema ( schema : object | object [], key? : string ) Add schema used for validation.","title":"addSchema()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_119","text":"Type Name Required Description object schema Yes Name of schema string key No Schema","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_169","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#removekeyword","text":"public removeKeyword ( keyword : string ) Remove keyword definition from validation.","title":"removeKeyword()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_120","text":"Type Name Required Description string keyword Yes Name of definition","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_170","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#removeschema","text":"public removeSchema ( schemaKeyRef : string | boolean | object | RegExp ) Remove schema from validation.","title":"removeSchema()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_121","text":"Type Name Required Description string, boolean, object, RegExp schemaKeyRef Yes Schema to remove","title":"Parameters"},{"location":"sdk/typescript/crypto/api-documentation/#return-value_171","text":"void","title":"Return Value"},{"location":"sdk/typescript/crypto/api-documentation/#extendtransaction","text":"public extendTransaction ( schema : TransactionSchema , remove? : boolean ) Extend a Transaction's schema for validation.","title":"extendTransaction()"},{"location":"sdk/typescript/crypto/api-documentation/#parameters_122","text":"Type Name Required Description TransactionSchema schema Yes Schema of transaction to extend boolean remove No Whether to remove the schema","title":"Parameters"},{"location":"sdk/typescript/crypto/examples/","text":"Examples \u00b6 Initialisation \u00b6 const { Identities } = require ( \"@solar-network/crypto\" ); // Throughout this document, the keys object used is: const keys = Identities . Keys . fromPassphrase ( \"this is a top secret passphrase\" ); // Throughout this document, the recipientId variable used is: const recipientId = Identities . Address . fromPassphrase ( \"this is a top secret passphrase\" ); // Throughout this document, the senderPublicKey variable used is: const senderPublicKey = Identities . PublicKey . fromPassphrase ( \"this is a top secret passphrase\" ); Transactions \u00b6 A transaction is an object specifying the transfer of funds from the sender's wallet to the recipient's. Each transaction must be signed by the sender's private key to prove authenticity and origin. After broadcasting through the client SDK , a transaction is permanently incorporated in the blockchain by a Delegate Node. Sign \u00b6 The crypto SDK can sign a transaction using your private key or passphrase (from which the private key is generated). Ensure you are familiar with digital signatures before using the crypto SDKs. const { Transactions } = require ( \"@solar-network/crypto\" ); const transaction = { type : 0 , amount : 1000 , fee : 2000 , recipientId , timestamp : 121212 , asset : {}, senderPublicKey }; Transactions . Signer . sign ( transaction , keys ); >>> string Serialise \u00b6 Serialisation of a transaction object ensures it is compact and properly formatted to be incorporated in the SXP blockchain. If you are using the crypto SDK in combination with the public API SDK, you should not need to serialise manually. const { Transactions } = require ( \"@solar-network/crypto\" ); const transaction = Transactions . BuilderFactory . transfer () . nonce ( senderNonce . toFixed ()) . memo ( \"This is an example memo\" ) . addTransfer ( \"Address of Recipient Wallet 1\" , 1 * 1e8 ) . addTransfer ( \"Address of Recipient Wallet 2\" , 1 * 1e8 ) . addTransfer ( \"Address of Recipient Wallet 3\" , 1 * 1e8 ) . sign ( \"this is a top secret passphrase\" ); const serialised = Transactions . Serialiser . serialise ( transaction ). toString ( \"hex\" ); >>> string Deserialise \u00b6 A serialised transaction may be deserialised for inspection purposes. The public API does not return serialised transactions, so you should only need to deserialise in exceptional circumstances. const { Transactions } = require ( \"@solar-network/crypto\" ); const deserialised = Transactions . deserialiser . deserialise ( serialised ); >>> ITransaction Message \u00b6 The crypto SDK not only supports transactions but can also work with other arbitrary data (expressed as strings). Sign \u00b6 Signing a string works much like signing a transaction: in most implementations, the message is hashed, and the resulting hash is signed using the private key or passphrase . ECDSA \u00b6 const { Crypto } = require ( \"@solar-network/crypto\" ); const message = \"Arbitrary entry of data\" ; const hash = Crypto . HashAlgorithms . sha256 ( message ); const signature = Crypto . Hash . signECDSA ( hash , keys ); const signed = { message , hash , signature }; >>> IMessage Schnorr \u00b6 const { Crypto } = require ( \"@solar-network/crypto\" ); const message = \"Arbitrary entry of data\" ; const hash = Crypto . HashAlgorithms . sha256 ( message ); const signature = Crypto . Hash . signSchnorr ( hash , keys ); const signed = { message , hash , signature }; >>> IMessage Verify \u00b6 A message's signature can easily be verified by hash, without the private key that signed the message, by using the verify method. ECDSA \u00b6 Crypto . Hash . verifyECDSA ( signed . hash , signed . signature , \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b\" ); >>> boolean Schnorr \u00b6 Crypto . Hash . verifySchnorr ( signed . hash , signed . signature , \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b\" ); >>> boolean Identities \u00b6 The identities class allows for the creation and inspection of keyPairs from passphrases . Here you find vital functions when creating transactions and managing wallets. Derive the Address from a Passphrase \u00b6 const { Identities } = require ( \"@solar-network/crypto\" ); Identities . Address . fromPassphrase ( \"this is a top secret passphrase\" ); >>> string Derive the Address from a Public Key \u00b6 const { Identities } = require ( \"@solar-network/crypto\" ); Identities . Address . fromPublicKey ( \"validPublicKey\" ); >>> string Derive the Address from a Private Key \u00b6 const { Identities } = require ( \"@solar-network/crypto\" ); Identities . Address . fromPrivateKey ( \"validPrivateKey\" ); >>> string Derive the Address from a WIF \u00b6 const { Identities } = require ( \"@solar-network/crypto\" ); Identities . Address . fromWIF ( \"validWif\" ); >>> string Validate an Address \u00b6 const { Identities } = require ( \"@solar-network/crypto\" ); Identities . Address . validate ( \"validAddress\" ); >>> boolean Private Key \u00b6 As the name implies, private keys and passphrases are to remain private. Never store these unencrypted and minimise access to these secrets Derive the Private Key from a Passphrase \u00b6 const { Identities } = require ( \"@solar-network/crypto\" ); Identities . PrivateKey . fromPassphrase ( \"this is a top secret passphrase\" ); >>> string Derive the Private Key Instance Object from a Hexadecimal Encoded String \u00b6 This function has not been implemented in this client library . Derive the Private Key from a WIF \u00b6 const { Identities } = require ( \"@solar-network/crypto\" ); Identities . PrivateKey . fromWIF ( \"validWif\" ); >>> string Public Key \u00b6 Public Keys may be freely shared, and are included in transaction objects to validate the authenticity. Derive the Public Key from a Passphrase \u00b6 const { Identities } = require ( \"@solar-network/crypto\" ); Identities . PublicKey . fromPassphrase ( \"this is a top secret passphrase\" ); >>> string Derive the Public Key Instance Object from a Hexadecimal Encoded String \u00b6 This function has not been implemented in this client library . Validate a Public Key \u00b6 const { Identities } = require ( \"@solar-network/crypto\" ); Identities . PublicKey . validate ( \"validPublicKey\" ); >>> boolean WIF \u00b6 The WIF should remain secret, just like your passphrase and private key . Derive the WIF from a Passphrase \u00b6 const { Identities } = require ( \"@solar-network/crypto\" ); Identities . WIF . fromPassphrase ( \"this is a top secret passphrase\" ); >>> string","title":"Examples"},{"location":"sdk/typescript/crypto/examples/#examples","text":"","title":"Examples"},{"location":"sdk/typescript/crypto/examples/#initialisation","text":"const { Identities } = require ( \"@solar-network/crypto\" ); // Throughout this document, the keys object used is: const keys = Identities . Keys . fromPassphrase ( \"this is a top secret passphrase\" ); // Throughout this document, the recipientId variable used is: const recipientId = Identities . Address . fromPassphrase ( \"this is a top secret passphrase\" ); // Throughout this document, the senderPublicKey variable used is: const senderPublicKey = Identities . PublicKey . fromPassphrase ( \"this is a top secret passphrase\" );","title":"Initialisation"},{"location":"sdk/typescript/crypto/examples/#transactions","text":"A transaction is an object specifying the transfer of funds from the sender's wallet to the recipient's. Each transaction must be signed by the sender's private key to prove authenticity and origin. After broadcasting through the client SDK , a transaction is permanently incorporated in the blockchain by a Delegate Node.","title":"Transactions"},{"location":"sdk/typescript/crypto/examples/#sign","text":"The crypto SDK can sign a transaction using your private key or passphrase (from which the private key is generated). Ensure you are familiar with digital signatures before using the crypto SDKs. const { Transactions } = require ( \"@solar-network/crypto\" ); const transaction = { type : 0 , amount : 1000 , fee : 2000 , recipientId , timestamp : 121212 , asset : {}, senderPublicKey }; Transactions . Signer . sign ( transaction , keys ); >>> string","title":"Sign"},{"location":"sdk/typescript/crypto/examples/#serialise","text":"Serialisation of a transaction object ensures it is compact and properly formatted to be incorporated in the SXP blockchain. If you are using the crypto SDK in combination with the public API SDK, you should not need to serialise manually. const { Transactions } = require ( \"@solar-network/crypto\" ); const transaction = Transactions . BuilderFactory . transfer () . nonce ( senderNonce . toFixed ()) . memo ( \"This is an example memo\" ) . addTransfer ( \"Address of Recipient Wallet 1\" , 1 * 1e8 ) . addTransfer ( \"Address of Recipient Wallet 2\" , 1 * 1e8 ) . addTransfer ( \"Address of Recipient Wallet 3\" , 1 * 1e8 ) . sign ( \"this is a top secret passphrase\" ); const serialised = Transactions . Serialiser . serialise ( transaction ). toString ( \"hex\" ); >>> string","title":"Serialise"},{"location":"sdk/typescript/crypto/examples/#deserialise","text":"A serialised transaction may be deserialised for inspection purposes. The public API does not return serialised transactions, so you should only need to deserialise in exceptional circumstances. const { Transactions } = require ( \"@solar-network/crypto\" ); const deserialised = Transactions . deserialiser . deserialise ( serialised ); >>> ITransaction","title":"Deserialise"},{"location":"sdk/typescript/crypto/examples/#message","text":"The crypto SDK not only supports transactions but can also work with other arbitrary data (expressed as strings).","title":"Message"},{"location":"sdk/typescript/crypto/examples/#sign_1","text":"Signing a string works much like signing a transaction: in most implementations, the message is hashed, and the resulting hash is signed using the private key or passphrase .","title":"Sign"},{"location":"sdk/typescript/crypto/examples/#ecdsa","text":"const { Crypto } = require ( \"@solar-network/crypto\" ); const message = \"Arbitrary entry of data\" ; const hash = Crypto . HashAlgorithms . sha256 ( message ); const signature = Crypto . Hash . signECDSA ( hash , keys ); const signed = { message , hash , signature }; >>> IMessage","title":"ECDSA"},{"location":"sdk/typescript/crypto/examples/#schnorr","text":"const { Crypto } = require ( \"@solar-network/crypto\" ); const message = \"Arbitrary entry of data\" ; const hash = Crypto . HashAlgorithms . sha256 ( message ); const signature = Crypto . Hash . signSchnorr ( hash , keys ); const signed = { message , hash , signature }; >>> IMessage","title":"Schnorr"},{"location":"sdk/typescript/crypto/examples/#verify","text":"A message's signature can easily be verified by hash, without the private key that signed the message, by using the verify method.","title":"Verify"},{"location":"sdk/typescript/crypto/examples/#ecdsa_1","text":"Crypto . Hash . verifyECDSA ( signed . hash , signed . signature , \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b\" ); >>> boolean","title":"ECDSA"},{"location":"sdk/typescript/crypto/examples/#schnorr_1","text":"Crypto . Hash . verifySchnorr ( signed . hash , signed . signature , \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b\" ); >>> boolean","title":"Schnorr"},{"location":"sdk/typescript/crypto/examples/#identities","text":"The identities class allows for the creation and inspection of keyPairs from passphrases . Here you find vital functions when creating transactions and managing wallets.","title":"Identities"},{"location":"sdk/typescript/crypto/examples/#derive-the-address-from-a-passphrase","text":"const { Identities } = require ( \"@solar-network/crypto\" ); Identities . Address . fromPassphrase ( \"this is a top secret passphrase\" ); >>> string","title":"Derive the Address from a Passphrase"},{"location":"sdk/typescript/crypto/examples/#derive-the-address-from-a-public-key","text":"const { Identities } = require ( \"@solar-network/crypto\" ); Identities . Address . fromPublicKey ( \"validPublicKey\" ); >>> string","title":"Derive the Address from a Public Key"},{"location":"sdk/typescript/crypto/examples/#derive-the-address-from-a-private-key","text":"const { Identities } = require ( \"@solar-network/crypto\" ); Identities . Address . fromPrivateKey ( \"validPrivateKey\" ); >>> string","title":"Derive the Address from a Private Key"},{"location":"sdk/typescript/crypto/examples/#derive-the-address-from-a-wif","text":"const { Identities } = require ( \"@solar-network/crypto\" ); Identities . Address . fromWIF ( \"validWif\" ); >>> string","title":"Derive the Address from a WIF"},{"location":"sdk/typescript/crypto/examples/#validate-an-address","text":"const { Identities } = require ( \"@solar-network/crypto\" ); Identities . Address . validate ( \"validAddress\" ); >>> boolean","title":"Validate an Address"},{"location":"sdk/typescript/crypto/examples/#private-key","text":"As the name implies, private keys and passphrases are to remain private. Never store these unencrypted and minimise access to these secrets","title":"Private Key"},{"location":"sdk/typescript/crypto/examples/#derive-the-private-key-from-a-passphrase","text":"const { Identities } = require ( \"@solar-network/crypto\" ); Identities . PrivateKey . fromPassphrase ( \"this is a top secret passphrase\" ); >>> string","title":"Derive the Private Key from a Passphrase"},{"location":"sdk/typescript/crypto/examples/#derive-the-private-key-instance-object-from-a-hexadecimal-encoded-string","text":"This function has not been implemented in this client library .","title":"Derive the Private Key Instance Object from a Hexadecimal Encoded String"},{"location":"sdk/typescript/crypto/examples/#derive-the-private-key-from-a-wif","text":"const { Identities } = require ( \"@solar-network/crypto\" ); Identities . PrivateKey . fromWIF ( \"validWif\" ); >>> string","title":"Derive the Private Key from a WIF"},{"location":"sdk/typescript/crypto/examples/#public-key","text":"Public Keys may be freely shared, and are included in transaction objects to validate the authenticity.","title":"Public Key"},{"location":"sdk/typescript/crypto/examples/#derive-the-public-key-from-a-passphrase","text":"const { Identities } = require ( \"@solar-network/crypto\" ); Identities . PublicKey . fromPassphrase ( \"this is a top secret passphrase\" ); >>> string","title":"Derive the Public Key from a Passphrase"},{"location":"sdk/typescript/crypto/examples/#derive-the-public-key-instance-object-from-a-hexadecimal-encoded-string","text":"This function has not been implemented in this client library .","title":"Derive the Public Key Instance Object from a Hexadecimal Encoded String"},{"location":"sdk/typescript/crypto/examples/#validate-a-public-key","text":"const { Identities } = require ( \"@solar-network/crypto\" ); Identities . PublicKey . validate ( \"validPublicKey\" ); >>> boolean","title":"Validate a Public Key"},{"location":"sdk/typescript/crypto/examples/#wif","text":"The WIF should remain secret, just like your passphrase and private key .","title":"WIF"},{"location":"sdk/typescript/crypto/examples/#derive-the-wif-from-a-passphrase","text":"const { Identities } = require ( \"@solar-network/crypto\" ); Identities . WIF . fromPassphrase ( \"this is a top secret passphrase\" ); >>> string","title":"Derive the WIF from a Passphrase"},{"location":"sdk/typescript/crypto/getting-started/","text":"NodeJS installation \u00b6 NodeJS can be downloaded here: nodejs.org/en/download Alternatively you can install NodeJS through your operating system packager manager . An excellent way to manage your NodeJS installation and be able to work with multiple version is to go through NVM . Yarn \u00b6 Yarn is a package manager for your code. It allows you to use and share code with other developers from around the world. Yarn does this quickly, securely, and reliably so you don\u2019t ever have to worry. Install Yarn \u00b6 Instructions on how to install Yarn can be found here: yarnpkg.com/en/docs/install Install package with Yarn \u00b6 yarn add @solar-network/crypto Development \u00b6 Crypto package is part of our Solar Core repository. Fork the package: github.com/Solar-network/core/fork Clone your forked repository. git clone https://github.com/<githubusername>/core Next, move into the fresh cloned directory. cd core Proceed to install the dependencies. yarn install Dependencies are now installed. yarn test Solar Crypto is located in core/packages/crypto","title":"Getting Started"},{"location":"sdk/typescript/crypto/getting-started/#nodejs-installation","text":"NodeJS can be downloaded here: nodejs.org/en/download Alternatively you can install NodeJS through your operating system packager manager . An excellent way to manage your NodeJS installation and be able to work with multiple version is to go through NVM .","title":"NodeJS installation"},{"location":"sdk/typescript/crypto/getting-started/#yarn","text":"Yarn is a package manager for your code. It allows you to use and share code with other developers from around the world. Yarn does this quickly, securely, and reliably so you don\u2019t ever have to worry.","title":"Yarn"},{"location":"sdk/typescript/crypto/getting-started/#install-yarn","text":"Instructions on how to install Yarn can be found here: yarnpkg.com/en/docs/install","title":"Install Yarn"},{"location":"sdk/typescript/crypto/getting-started/#install-package-with-yarn","text":"yarn add @solar-network/crypto","title":"Install package with Yarn"},{"location":"sdk/typescript/crypto/getting-started/#development","text":"Crypto package is part of our Solar Core repository. Fork the package: github.com/Solar-network/core/fork Clone your forked repository. git clone https://github.com/<githubusername>/core Next, move into the fresh cloned directory. cd core Proceed to install the dependencies. yarn install Dependencies are now installed. yarn test Solar Crypto is located in core/packages/crypto","title":"Development"},{"location":"sdk/typescript/crypto/intro/","text":"Crypto \u00b6 Install package with Yarn \u00b6 yarn add @solar-network/crypto Development \u00b6 Crypto package is part of our Solar Core repository. Fork the package: github.com/Solar-network/core/fork Clone your forked repository. git clone https://github.com/<githubusername>/core Next, move into the fresh cloned directory. cd core/crypto Proceed to install the dependencies. yarn install Dependencies are now installed, you can now run the tests to see if everything is running as it should. yarn test","title":"Getting Started"},{"location":"sdk/typescript/crypto/intro/#crypto","text":"","title":"Crypto"},{"location":"sdk/typescript/crypto/intro/#install-package-with-yarn","text":"yarn add @solar-network/crypto","title":"Install package with Yarn"},{"location":"sdk/typescript/crypto/intro/#development","text":"Crypto package is part of our Solar Core repository. Fork the package: github.com/Solar-network/core/fork Clone your forked repository. git clone https://github.com/<githubusername>/core Next, move into the fresh cloned directory. cd core/crypto Proceed to install the dependencies. yarn install Dependencies are now installed, you can now run the tests to see if everything is running as it should. yarn test","title":"Development"},{"location":"sxpswap/introduction/","text":"Introduction \u00b6 This section is meant for users and exchanges migrating their ERC20/BEP20 SXP to mainnet SXP. If you are already on SXP mainnet, then this guide is not for you. Click on the following links to proceed with the swap. Migration for MetaMask Users Migration for Trust Wallet Users Migration for Exchanges Technical Details","title":"Introduction"},{"location":"sxpswap/introduction/#introduction","text":"This section is meant for users and exchanges migrating their ERC20/BEP20 SXP to mainnet SXP. If you are already on SXP mainnet, then this guide is not for you. Click on the following links to proceed with the swap. Migration for MetaMask Users Migration for Trust Wallet Users Migration for Exchanges Technical Details","title":"Introduction"},{"location":"sxpswap/exchanges/getting-started/","text":"Introduction \u00b6 We advise Exchange Operators to read the information in the technical details section. Technical Details","title":"Introduction"},{"location":"sxpswap/exchanges/getting-started/#introduction","text":"We advise Exchange Operators to read the information in the technical details section. Technical Details","title":"Introduction"},{"location":"sxpswap/technical-details/security/broadcast-procedure/","text":"Phase 2 - Backend Program Broadcasting Transaction \u00b6 In the second phase, the backend program listens for new transactions on BEP20/ERC20 SXPSwap contract. The backend program listens to transactions from a local full node and from trusted remote API's. If the transaction is fully confirmed, the backend program will run the following validations checks. Check if the incoming transaction has already been processed on the backend tool and on the SXP blockchain Contract ID of the tokens that have been received on the SXPSwap contract. Amount of tokens that have been transferred. Validation of the new SXP mainnet address. Check validations over 3 different BSC/ETH nodes. Once all validations are passed. The backend program will generate a transaction and broadcast it to mainnet to the address that was submitted in the contract. Within this transaction, the vendorField will contain additional details regarding the SXPSwap transaction in the following format: Vendorfield bsc:0x4f7ce4430909fef471f30c4d7c74156bc9df8887c3b0f7d0c50d2085dcada254 The prefix determines where the transaction originated from, either Binance Smart Chain or Ethereum. Adding this note to mainnet transactions will provide transparency to incoming swaps, but it's also for the forging nodes to run their own validations. Security Notices \u00b6 The server that hosts the backend program has several security features in case of failures such as server hacks, server reboot, ddos attacks, DC issues or server maintenance. Swaps can only occur from a specific master address. The forging nodes will only process transactions from this wallet if the data in the vendorField matches with the response from the API's. Meaning that any other transactions sent from this wallet with a wrong address, wrong transaction ID or no vendorField at all, will be denied by the forging nodes. This also means that in case the private keys of this master address are leaked in the public or somehow obtained by a hacker, there is no way to move funds out of this wallet without matching data from SXPSwap. Even if it does contain matched data. Duplicate transactions with the same transaction ID are denied by the network.","title":"Broadcast Procedure"},{"location":"sxpswap/technical-details/security/broadcast-procedure/#phase-2-backend-program-broadcasting-transaction","text":"In the second phase, the backend program listens for new transactions on BEP20/ERC20 SXPSwap contract. The backend program listens to transactions from a local full node and from trusted remote API's. If the transaction is fully confirmed, the backend program will run the following validations checks. Check if the incoming transaction has already been processed on the backend tool and on the SXP blockchain Contract ID of the tokens that have been received on the SXPSwap contract. Amount of tokens that have been transferred. Validation of the new SXP mainnet address. Check validations over 3 different BSC/ETH nodes. Once all validations are passed. The backend program will generate a transaction and broadcast it to mainnet to the address that was submitted in the contract. Within this transaction, the vendorField will contain additional details regarding the SXPSwap transaction in the following format: Vendorfield bsc:0x4f7ce4430909fef471f30c4d7c74156bc9df8887c3b0f7d0c50d2085dcada254 The prefix determines where the transaction originated from, either Binance Smart Chain or Ethereum. Adding this note to mainnet transactions will provide transparency to incoming swaps, but it's also for the forging nodes to run their own validations.","title":"Phase 2 - Backend Program Broadcasting Transaction"},{"location":"sxpswap/technical-details/security/broadcast-procedure/#security-notices","text":"The server that hosts the backend program has several security features in case of failures such as server hacks, server reboot, ddos attacks, DC issues or server maintenance. Swaps can only occur from a specific master address. The forging nodes will only process transactions from this wallet if the data in the vendorField matches with the response from the API's. Meaning that any other transactions sent from this wallet with a wrong address, wrong transaction ID or no vendorField at all, will be denied by the forging nodes. This also means that in case the private keys of this master address are leaked in the public or somehow obtained by a hacker, there is no way to move funds out of this wallet without matching data from SXPSwap. Even if it does contain matched data. Duplicate transactions with the same transaction ID are denied by the network.","title":"Security Notices"},{"location":"sxpswap/technical-details/security/contract-procedure/","text":"Phase 1 - Sending tokens to SXPSwap Contract (BSC/ETH) \u00b6 In order to facilitate a successful migration, the Swipe (SXP) tokens on BEP20/ERC20 are meant to enter a contract and never leave the contract ever again. This is facilitated by a contract on BEP20 and ERC20. The process consists on 2 main functions. 1. The first function \"approve\", which exists on the Swipe (SXP) token contract, this serves for the purpose of approving the SXPSwap contract to move the Swipe tokens over the new SXPSwap Contract. 2. The second function \"transferTokenToContract\", this serves for the purpose of sending the tokens that were previously approved to SXPSwap. Functions on the new contract. The function \"transferTokenToContract\" is only accepted if the following parameters are included. These parameters are: Address of Swipe token. Amount of tokens to be transferred. A valid SXP mainnet address to be entered in string format. If these parameters are missing, the transaction will fail. Validation \u00b6 New Wallet Address Validation \u00b6 There are 4 validation controls for the SXP mainnet address that check for a 34 character address with the S prefix. 1. Validation on the frontend for Metamask users that are using the official SXPSwap tool. 2. Validation on the smart contract to only allow addresses with a certain prefix. 3. Validation on the backend program that sends the mainnet SXP to the new address. 4. Validation by the forging nodes that accept or deny the transaction created by the backend tool. Interacting with the contract directly and entering a wrong address by accident or on purpose will result in loss of funds. There is no way to recover the tokens from a contract and sending new SXP tokens on mainnet is impossible without a valid transaction on the contract side. Notes \u00b6 Other tokens can be sent to the SXPSwap contract. These tokens can not be recovered and will not be accepted by the backend program that broadcasts the swap to the forging delegates. Due to the validation by the backend program and the validation from the forging delegates, trying to send \"fake\" SXP tokens with a correct SXP mainnet address will have no impact on the swap procedure. Disclaimer! Read carefully! Below links will direct you to the contracts on Binance Smart Chain and Ethereum. Warning! Do no interact with the contract directly unless you know what you are doing. Interacting with the contract directly or sending your tokens to the contract without attaching a correct mainnet address will result in losing your SXP tokens. Mainnet \u00b6 BEP20 Token Contract ERC20 Token Contract BEP20 Swap Contract ERC20 Swap Contract Additionally, exchanges are also able to use the Metamask version of the swap. For testnet, this is available under https://swap.testnet.sh For mainnet under https://swap.solar.org Contact us if you wish to receive SXP testnet tokens on BSC Testnet or Ethereum Kovan.","title":"Contract Procedure"},{"location":"sxpswap/technical-details/security/contract-procedure/#phase-1-sending-tokens-to-sxpswap-contract-bsceth","text":"In order to facilitate a successful migration, the Swipe (SXP) tokens on BEP20/ERC20 are meant to enter a contract and never leave the contract ever again. This is facilitated by a contract on BEP20 and ERC20. The process consists on 2 main functions. 1. The first function \"approve\", which exists on the Swipe (SXP) token contract, this serves for the purpose of approving the SXPSwap contract to move the Swipe tokens over the new SXPSwap Contract. 2. The second function \"transferTokenToContract\", this serves for the purpose of sending the tokens that were previously approved to SXPSwap. Functions on the new contract. The function \"transferTokenToContract\" is only accepted if the following parameters are included. These parameters are: Address of Swipe token. Amount of tokens to be transferred. A valid SXP mainnet address to be entered in string format. If these parameters are missing, the transaction will fail.","title":"Phase 1 - Sending tokens to SXPSwap Contract (BSC/ETH)"},{"location":"sxpswap/technical-details/security/contract-procedure/#validation","text":"","title":"Validation"},{"location":"sxpswap/technical-details/security/contract-procedure/#new-wallet-address-validation","text":"There are 4 validation controls for the SXP mainnet address that check for a 34 character address with the S prefix. 1. Validation on the frontend for Metamask users that are using the official SXPSwap tool. 2. Validation on the smart contract to only allow addresses with a certain prefix. 3. Validation on the backend program that sends the mainnet SXP to the new address. 4. Validation by the forging nodes that accept or deny the transaction created by the backend tool. Interacting with the contract directly and entering a wrong address by accident or on purpose will result in loss of funds. There is no way to recover the tokens from a contract and sending new SXP tokens on mainnet is impossible without a valid transaction on the contract side.","title":"New Wallet Address Validation"},{"location":"sxpswap/technical-details/security/contract-procedure/#notes","text":"Other tokens can be sent to the SXPSwap contract. These tokens can not be recovered and will not be accepted by the backend program that broadcasts the swap to the forging delegates. Due to the validation by the backend program and the validation from the forging delegates, trying to send \"fake\" SXP tokens with a correct SXP mainnet address will have no impact on the swap procedure. Disclaimer! Read carefully! Below links will direct you to the contracts on Binance Smart Chain and Ethereum. Warning! Do no interact with the contract directly unless you know what you are doing. Interacting with the contract directly or sending your tokens to the contract without attaching a correct mainnet address will result in losing your SXP tokens.","title":"Notes"},{"location":"sxpswap/technical-details/security/contract-procedure/#mainnet","text":"BEP20 Token Contract ERC20 Token Contract BEP20 Swap Contract ERC20 Swap Contract Additionally, exchanges are also able to use the Metamask version of the swap. For testnet, this is available under https://swap.testnet.sh For mainnet under https://swap.solar.org Contact us if you wish to receive SXP testnet tokens on BSC Testnet or Ethereum Kovan.","title":"Mainnet"},{"location":"sxpswap/technical-details/security/introduction/","text":"Introduction \u00b6 The SXPSwap tool is an entirely decentralized module to facilitate the migration from BEP20/ERC20 to mainnet SXP. SXPSwap focuses on several security features that are important to facilitate a migration on protocol level. Contract Procedure Broadcast Procedure Mainnet Procedure","title":"Introduction"},{"location":"sxpswap/technical-details/security/introduction/#introduction","text":"The SXPSwap tool is an entirely decentralized module to facilitate the migration from BEP20/ERC20 to mainnet SXP. SXPSwap focuses on several security features that are important to facilitate a migration on protocol level. Contract Procedure Broadcast Procedure Mainnet Procedure","title":"Introduction"},{"location":"sxpswap/technical-details/security/mainnet-procedure/","text":"Phase 3 - Processing the Swaps \u00b6 Phase 3 relates to transactions from the Swap Master Address to the new SXP mainnet address. All nodes on mainnet are equipped with a plugin that validates and processes transactions sent by the Swap Master Address. Vendorfield Swaps can only occur from a specific master address. The forging nodes will only process transactions from this wallet if the data in the vendorField matches with the response from the API's. Meaning that any other transactions sent from this wallet with a wrong address, wrong transaction ID or no vendorField at all, will be denied by the forging nodes. This also means that in case the private keys of this master address are leaked in the public or somehow obtained by a hacker, there is no way to move funds out of this wallet without matching data from SXPSwap. Even if it does contain matched data. Duplicate transactions with the same transaction ID are denied by the network. The plugins on the forging, relay and seed nodes are equiped with plugins that request data from several API's to verify transactions that are sent from the Swap Master Address. Nodes can choose to use the default remote API or use a local full node to request data from the BSC or ETH chain. The node validates the following data to either accept or deny the transaction. 1. Transaction ID with a minimum amount of confirmations. 2. Match the new wallet address with the wallet address provided in the contract. 3. Match the amount that is being sent to the new wallet with the amount that was transferred to the contract. 4. Validate if the SXPSwap contract has the right contract ID for SXP. 5. Verify that the transaction hasn't been executed earlier. All nodes including forging nodes, relays, and seed peers will have to validate this transaction in order to accept the block. Nodes that have latency issues, bad or manipulated API or wrong data will fork from the network and from the seed peers.","title":"Mainnet Procedure"},{"location":"sxpswap/technical-details/security/mainnet-procedure/#phase-3-processing-the-swaps","text":"Phase 3 relates to transactions from the Swap Master Address to the new SXP mainnet address. All nodes on mainnet are equipped with a plugin that validates and processes transactions sent by the Swap Master Address. Vendorfield Swaps can only occur from a specific master address. The forging nodes will only process transactions from this wallet if the data in the vendorField matches with the response from the API's. Meaning that any other transactions sent from this wallet with a wrong address, wrong transaction ID or no vendorField at all, will be denied by the forging nodes. This also means that in case the private keys of this master address are leaked in the public or somehow obtained by a hacker, there is no way to move funds out of this wallet without matching data from SXPSwap. Even if it does contain matched data. Duplicate transactions with the same transaction ID are denied by the network. The plugins on the forging, relay and seed nodes are equiped with plugins that request data from several API's to verify transactions that are sent from the Swap Master Address. Nodes can choose to use the default remote API or use a local full node to request data from the BSC or ETH chain. The node validates the following data to either accept or deny the transaction. 1. Transaction ID with a minimum amount of confirmations. 2. Match the new wallet address with the wallet address provided in the contract. 3. Match the amount that is being sent to the new wallet with the amount that was transferred to the contract. 4. Validate if the SXPSwap contract has the right contract ID for SXP. 5. Verify that the transaction hasn't been executed earlier. All nodes including forging nodes, relays, and seed peers will have to validate this transaction in order to accept the block. Nodes that have latency issues, bad or manipulated API or wrong data will fork from the network and from the seed peers.","title":"Phase 3 - Processing the Swaps"},{"location":"sxpswap/users/metamask/","text":"Introduction \u00b6 Disclaimer! Please read the information on this page carefully. You need a Solar Wallet address to perform the swap from ERC20/BEP20 SXP to Mainnet SXP. Visit our official website to download the latest Solar Desktop Wallet . Swap Procedure \u00b6 This guide is meant for users that have their ERC20/BEP20 SXP tokens in the Metamask Wallet. Read the instructions below to swap your ERC20/BEP20 SXP tokens to Mainnet SXP coins: Create a mainnet address using the Solar Desktop Wallet or click here to learn more about creating wallets . Make sure to securely store your passphrase with additional backups. Do not share this passphrase with anyone. Make sure to have the SXP tokens (BEP20 or ERC20) in your MetaMask wallet with gas to cover the fees for the swap. Visit the Swap Website and make sure that you are visiting the right domain. https://swap.solar.org Connect to your MetaMask Wallet and click next. Select the network where you are holding your SXP tokens and click next. Enter the amount of SXP you wish to swap. You can try with a low amount and swap more later. On the next page, enter your wallet address from the Solar Desktop Wallet. The mainnet SXP address starts with an S and is 34 characters long. Click next after you've filled in your SXP mainnet wallet address. From this point, it won't be possible to recover your assets if you fill in the wrong address. Double check the details on this page and click on the \"Approve Swap\" button. You will now be asked to confirm the transactions which sends the tokens to a specialized contract. Wait. Do not close this page. You are not done yet. A new button will be available. Click on the button that says \"Swap Now\" and finalize the swap by confirming and signing the Swap transaction. The swap is done. You can now view the transaction on the block explorer. The new SXP mainnet coins will arrive in your wallet within 30-minutes after receiving the required amount of confirmations.","title":"Swap/Migration for MetaMask users"},{"location":"sxpswap/users/metamask/#introduction","text":"Disclaimer! Please read the information on this page carefully. You need a Solar Wallet address to perform the swap from ERC20/BEP20 SXP to Mainnet SXP. Visit our official website to download the latest Solar Desktop Wallet .","title":"Introduction"},{"location":"sxpswap/users/metamask/#swap-procedure","text":"This guide is meant for users that have their ERC20/BEP20 SXP tokens in the Metamask Wallet. Read the instructions below to swap your ERC20/BEP20 SXP tokens to Mainnet SXP coins: Create a mainnet address using the Solar Desktop Wallet or click here to learn more about creating wallets . Make sure to securely store your passphrase with additional backups. Do not share this passphrase with anyone. Make sure to have the SXP tokens (BEP20 or ERC20) in your MetaMask wallet with gas to cover the fees for the swap. Visit the Swap Website and make sure that you are visiting the right domain. https://swap.solar.org Connect to your MetaMask Wallet and click next. Select the network where you are holding your SXP tokens and click next. Enter the amount of SXP you wish to swap. You can try with a low amount and swap more later. On the next page, enter your wallet address from the Solar Desktop Wallet. The mainnet SXP address starts with an S and is 34 characters long. Click next after you've filled in your SXP mainnet wallet address. From this point, it won't be possible to recover your assets if you fill in the wrong address. Double check the details on this page and click on the \"Approve Swap\" button. You will now be asked to confirm the transactions which sends the tokens to a specialized contract. Wait. Do not close this page. You are not done yet. A new button will be available. Click on the button that says \"Swap Now\" and finalize the swap by confirming and signing the Swap transaction. The swap is done. You can now view the transaction on the block explorer. The new SXP mainnet coins will arrive in your wallet within 30-minutes after receiving the required amount of confirmations.","title":"Swap Procedure"},{"location":"sxpswap/users/trust-wallet/","text":"Introduction \u00b6 Coming soon The implementation for using the swap bridge with the Trust Wallet is currently being implemented and will be available in early Q2.","title":"Swap/Migration for Trust Wallet users"},{"location":"sxpswap/users/trust-wallet/#introduction","text":"Coming soon The implementation for using the swap bridge with the Trust Wallet is currently being implemented and will be available in early Q2.","title":"Introduction"}]}