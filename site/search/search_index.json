{ "config": { "indexing": "full", "lang": ["en"], "min_search_length": 3, "prebuild_index": false, "separator": "[\\s\\-]+" }, "docs": [{ "location": "", "text": "", "title": "Documentation" }, { "location": "license/", "text": "License \u00b6 MIT License Copyright \u00a9 2016-2022 Martin Donath Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", "title": "License" }, { "location": "license/#license", "text": "MIT License Copyright \u00a9 2016-2022 Martin Donath Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", "title": "License" }, { "location": "core/intro/", "text": "Coming soon", "title": "Intro" }, { "location": "exchanges/configuring-rate-limits/", "text": "Configuring Rate Limits \u00b6 Solar Core is mainly used in the context of public services, providing desktop wallets with the necessary endpoints to function. Since they serve anonymous users and to protect against DDoS attacks, Solar Core nodes have strict rate limits. Enterprise users (such as exchanges) might encounter a problem creating large batches of transactions and broadcasting them. The rate limit can be configured in multiple ways to solve these problems. Exceeding the Rate Limit \u00b6 By default, rate limits are enabled on Solar Core nodes. When the rate limit is exceeded; a 429 HTTP status is returned. Configuring the Rate Limit \u00b6 You can fine tune or completely disable the node's rate limit by editing the .env file found at ~/.config/solar-core/{network}/.env . Find most important parameters below: file: ~/.config/solar-core/{network}/.env \u00b6 CORE_API_RATE_LIMIT_DISABLED = true CORE_API_RATE_LIMIT_USER_LIMIT = 300 CORE_API_RATE_LIMIT_WHITELIST = 127.0.0.1 , 192.168.1.1 , 172.31.255.1 Setting CORE_API_RATE_LIMIT_DISABLED=true will globally disable all rate limits. For internal use this is safe. More fine-grained control may be exerted by using CORE_API_RATE_LIMIT_USER_LIMIT , which uses IP addresses to assign rate limits. The unit is requests/minute (default: 100 requests/per minute/per IP). Excluding certain IP addresses from rate limiting can be achieved by setting CORE_API_RATE_LIMIT_WHITELIST= followed by comma separated list of IP addresses (default: 172.0.0.1). Use case 1: Disable Rate Limits \u00b6 WARNING: Make sure API is accessible only to your internal network and not visible to the outside world. CORE_API_RATE_LIMIT_DISABLED = true Use case 2: White Listing \u00b6 INFO: Instead of globally disabling rate limits it is possible to exclude certain IP addresses from rate limits and raise the global limits. CORE_API_RATE_LIMIT_WHITELIST = 127.0.0.1 , 192.168.1.1 , 172.31.255.1 CORE_API_RATE_LIMIT_USER_LIMIT = 300", "title": "Configuring Rate Limits" }, { "location": "exchanges/configuring-rate-limits/#configuring-rate-limits", "text": "Solar Core is mainly used in the context of public services, providing desktop wallets with the necessary endpoints to function. Since they serve anonymous users and to protect against DDoS attacks, Solar Core nodes have strict rate limits. Enterprise users (such as exchanges) might encounter a problem creating large batches of transactions and broadcasting them. The rate limit can be configured in multiple ways to solve these problems.", "title": "Configuring Rate Limits" }, { "location": "exchanges/configuring-rate-limits/#exceeding-the-rate-limit", "text": "By default, rate limits are enabled on Solar Core nodes. When the rate limit is exceeded; a 429 HTTP status is returned.", "title": "Exceeding the Rate Limit " }, { "location": "exchanges/configuring-rate-limits/#configuring-the-rate-limit", "text": "You can fine tune or completely disable the node's rate limit by editing the .env file found at ~/.config/solar-core/{network}/.env . Find most important parameters below:", "title": "Configuring the Rate Limit " }, { "location": "exchanges/configuring-rate-limits/#file-configsolar-corenetworkenv", "text": "CORE_API_RATE_LIMIT_DISABLED = true CORE_API_RATE_LIMIT_USER_LIMIT = 300 CORE_API_RATE_LIMIT_WHITELIST = 127.0.0.1 , 192.168.1.1 , 172.31.255.1 Setting CORE_API_RATE_LIMIT_DISABLED=true will globally disable all rate limits. For internal use this is safe. More fine-grained control may be exerted by using CORE_API_RATE_LIMIT_USER_LIMIT , which uses IP addresses to assign rate limits. The unit is requests/minute (default: 100 requests/per minute/per IP). Excluding certain IP addresses from rate limiting can be achieved by setting CORE_API_RATE_LIMIT_WHITELIST= followed by comma separated list of IP addresses (default: 172.0.0.1).", "title": "file: ~/.config/solar-core/{network}/.env " }, { "location": "exchanges/configuring-rate-limits/#use-case-1-disable-rate-limits", "text": "WARNING: Make sure API is accessible only to your internal network and not visible to the outside world. CORE_API_RATE_LIMIT_DISABLED = true", "title": "Use case 1: Disable Rate Limits  " }, { "location": "exchanges/configuring-rate-limits/#use-case-2-white-listing", "text": "INFO: Instead of globally disabling rate limits it is possible to exclude certain IP addresses from rate limits and raise the global limits. CORE_API_RATE_LIMIT_WHITELIST = 127.0.0.1 , 192.168.1.1 , 172.31.255.1 CORE_API_RATE_LIMIT_USER_LIMIT = 300", "title": "Use case 2: White Listing  " }, { "location": "exchanges/intro/", "text": "Introduction \u00b6 This section is tailored for institutional/production usage of Solar Core. Most exchanges and third-party services are familiar with Bitcoind-RPC when listing or adding a new cryptocurrency. Since Solar is a custom blockchain, some companies have had difficulty navigating through our GitHub and integrating Solar into their platform. The two most popular means of accessing the Solar blockchain are via the Public API and the JSON-RPC . Though the JSON-RPC is the recommended approach, we include instructions here on how to accomplish the most common tasks on both API surfaces. We have added \"quick guides\" to walk you through the process of interacting with the Solar blockchain in each API. Use the sidebar to navigate this section", "title": "Introduction" }, { "location": "exchanges/intro/#introduction", "text": "This section is tailored for institutional/production usage of Solar Core. Most exchanges and third-party services are familiar with Bitcoind-RPC when listing or adding a new cryptocurrency. Since Solar is a custom blockchain, some companies have had difficulty navigating through our GitHub and integrating Solar into their platform. The two most popular means of accessing the Solar blockchain are via the Public API and the JSON-RPC . Though the JSON-RPC is the recommended approach, we include instructions here on how to accomplish the most common tasks on both API surfaces. We have added \"quick guides\" to walk you through the process of interacting with the Solar blockchain in each API. Use the sidebar to navigate this section", "title": "Introduction" }, { "location": "exchanges/public-api-guide/", "text": "Exchanges API Guide \u00b6 For exchanges we recommend the usage of JSON-RPC server with optimized methods for client and crypto functionality. Best practice is to install a Relay Node and JSON-RPC in a secure environment. If really necessary then follow the basic instructions for connection via Public REST API. Connecting to the PUBLIC API is done via the Crypto and Client SDKs . Many queries can be performed using the Client SDK alone, while the Crypto SDK performs any actions requiring cryptographic functionality (i.e., signing transactions). At a surface level, the two SDKs are separated by their functions and intended use cases: The Crypto SDK provides the cryptographic functions necessary to authenticate and validate Solar transactions. The Client SDK provides wrapper functions to unify and streamline API calls between your application and the Solar blockchain. Put another way, the Crypto SDK structures your data in a format that all Solar nodes can understand, while the Client SDK handles the actual communication between your application and an Solar node. Where the Crypto SDK is internal, the Client SDK is external, as the below diagram illustrates: Note that the Public API is only available after a node has fully synced. This ensures your data on the blockchain is up to date. Setup \u00b6 These quick actions will all assume you've loaded a Client instance with the IP address of your node and the API version you're requesting. Solar Node (v1) has been deprecated. Some references to V1 client constructors may remain for legacy purposes. However, no current clients require you to specify the API Version (defaults to v2). const Client = require ( \"@solar/client\" ); const exchangeClient = new Client ( \"YOUR.NODE.IP\" , 2 ); HashMap < String , Object > map = new HashMap <> (); map . put ( \"host\" , \"http://node-ip:port/api/\" ); map . put ( \"API-Version\" , 2 ); Connection < Two > connection = new Connection ( map ); package main import ( sxp \"github.com/solar/go-client/client\" \"net/url\" ) func main () { client := sxp . NewClient ( nil ) client . BaseURL , _ = url . Parse ( \"http://{NODE_IP}:{NODE_HOST}/api\" ) from client import ArkClient client = ArkClient ( 'http://127.0.0.1:6003/api' ) Check Wallet Balance \u00b6 Checking a wallet balance involves using the wallets resource to GET the wallet corresponding to a given Solar address. const walletAddress = \"ARyNwFj7nQUCip5gYt4gSWG6F8evL93eBL\" ; let wallet ; exchangeClient . resource ( \"wallets\" ) . get ( walletAddress ) . then ( response => { wallet = response . data . data ; }) . catch ( error => { console . log ( error ); }); console . log ( wallet . balance ); ... import \"github.com/davecgh/go-spew/spew\" func main () { ... responseStruct , _ , err := client . Wallets . Get ( context . TODO (), \"ARyNwFj7nQUCip5gYt4gSWG6F8evL93eBL\" ) if err != nil { log . Panic ( err ) } spew . Dump ( responseStruct ) } from pprint import pprint pprint ( client . wallets . get ( wallet_id = 'ARyNwFj7nQUCip5gYt4gSWG6F8evL93eBL' )) Find Block Information \u00b6 If you know the ID of the block you are looking for, you can use the GET method on the blocks resource to return information on that block. const blockId = 4439278960598580069 ; let block ; exchangeClient . resource ( \"blocks\" ) . get ( blockId ) . then ( response => { block = response . data . data ; }) . catch ( error => { console . log ( error ); }); console . log ( block ); func main () { ... responseStruct , _ , err := client . Blocks . Get ( context . TODO (), 4439278960598580069 ) if err != nil { log . Panic ( err ) } spew . Dump ( responseStruct ) } pprint ( client . blocks . get ( block_id = '4439278960598580069' )) Alternatively, if you are not sure of the block ID, or if you want to find all wallets in a range, you can make use of the wallets.search method. This endpoint accepts a JSON object representing the search parameters to use when narrowing down a list of blocks. The following block properties can be used to create your range: timestamp height numberOfTransactions totalAmount totalFee reward payloadLength To use any of these properties as a range, include the relevant key in your request as an object containing from and to specifiers. For example, this code can be used to search all blocks between blockchain heights 720 and 735 with total fees between 0 and 2000 arktoshi: exchangeClient . resource ( \"blocks\" ) . search ({ height : { from : 720 , to : 735 }, totalFee : { from : 0 , to : 2000 } }) . then ( response => { console . log ( response . data ); // all blocks matching the search criteria }); func main () { ... responseStruct , _ , err := client . Blocks . Search ( context . TODO (), sxp . BlocksSearchRequest { Height : sxp . FromTo { From : 720 , To : 735 }, TotalFee : sxp . FromTo { From : 0 , To : 2000 }, }) if err != nil { log . Panic ( err ) } spew . Dump ( responseStruct ) } pprint ( client . blocks . search ({ \"height\" : { \"from\" : 720 , \"to\" : 735 }, \"totalFee\" : { \"from\" : 0 , \"to\" : 2000 }, })) Create and Broadcast Transactions \u00b6 To create transactions, make use of the transactionBuilder module of @solar/crypto . First, install the package from npm or your language's equivalent: yarn add @solar/crypto go get -u github.com/solar/go-crypto/crypto pip install solar-crypto The crypto package functionality we'll use here is the transactionBuilder, which provides a series of \"chainable\" methods that can be called, one after another, to produce a transaction object. These methods create and define your transaction: its type, its amount in arktoshi, its signature, and more. Regardless of which SDK you use, every transactionBuilder contains a similar function to getStruct , which will return a completed transaction object. After making one or more of these transaction objects, you can combine them into an array to use as the transactions key in your request. With all the steps together, here is an example of how to send a transaction for approval: const crypto = require ( \"@solar/crypto\" ); const transactionBuilder = crypto . transactionBuilder ; const transaction = transactionBuilder . transfer () . amount ( 2 * Math . pow ( 10 , 8 )) . recipientId ( recipientId ) . sign ( passphrase ) . getStruct (); exchangeClient . resource ( \"transactions\" ) . create ({ transactions : [ transaction ] }) . then ( response => { console . log ( response . data ); if ( response . data . errors ) { errors . forEach ( error => { console . log ( error ); }); } }) . catch ( error => { console . log ( error ); }); ... import ark_crypto \"github.com/solar/go-crypto/crypto\" func main () { ... transaction := ark_crypto . BuildTransfer ( recipientId , uint64 ( amount ), \"Hello World\" , passphrase , ) // cast is a fictitious helper function which alters ark_crypto.Transaction // into an ark_client.CreateTransactionRequest. responseStruct , _ , err := client . Transaction . Create ( context . TODO (), cast ( transaction )) if err != nil { log . Panic ( err ) } spew . Dump ( responseStruct ) } ... from crypto.transactions.builder.transfer import Transfer tx = Transfer ( recipientId = recipientId , amount = 1000 ) tx . sign ( passphrase ) pprint ( client . transactions . create ([ tx ])) There are a few things worth noticing about the above code. Firstly, the code assumes that you have declared two variables already: passphrase - the passphrase of the sending account, used to sign the transaction. This should come from somewhere secure, such as a .env file. recipientId - the Solar address of the receiving account. Should be provided by the exchange user when submitting withdrawal requests. Second, when sending your request using the exchangeClient , ensure that the value of transactions is an array, even if you have only one transaction object. If your request is successful, you will receive a response with the following data key: { data : { accept : [ '96e3952b66a370d8145055b55cedc6f1435b3a71cb17334aa954f8844ad1202f' ], broadcast : [ '96e3952b66a370d8145055b55cedc6f1435b3a71cb17334aa954f8844ad1202f' ], excess : [], invalid : [] }, errors : null } Let us look at the returned data object in more depth. It is composed of four arrays, each holding zero or more transaction IDs: accept - a list of all accepted transactions broadcast - a list of all transactions broadcast to the network excess - if the node's transaction pool is full, this lists all excess transactions invalid - a list of all transactions deemed invalid by the node Our sample code above submitted one transaction, which the node accepted and broadcast and thus the accept and broadcast arrays contain precisely one item each: the ID of the transaction we submitted. If we had submitted any invalid transactions, the invalid list would have contained their IDs, and the errors key would have been populated with one error per invalid transaction. The diagram below offers a top-level overview of the transaction submission process: Check Transaction Confirmations \u00b6 Once a transaction has been created and added to the blockchain, you can access the number of confirmations it has by using the transactions resource to get the value matching the transaction ID. const transactionId = \"9085b309dd0c20c12c1a00c40e1c71cdadaa74476b669e9f8a632db337fb6915\" ; exchangeClient . resource ( \"transactions\" ) . get ( transactionId ) . then ( response => { console . log ( response . data ); }); ... func main () { ... txID := \"9085b309dd0c20c12c1a00c40e1c71cdadaa74476b669e9f8a632db337fb6915\" responseStruct , _ , err := client . Transactions . Get ( context . TODO (), txID ) if err != nil { log . Panic ( err ) } spew . Dump ( responseStruct ) } txID = \"9085b309dd0c20c12c1a00c40e1c71cdadaa74476b669e9f8a632db337fb6915\" pprint ( client . transactions . get ( transaction_id = txID )) If the transaction has been added to the blockchain, you'll receive the following data structure in your console: { data : { id : 'a4d3d3ab059b8445894805c1158f06049a4200b2878892e18d95b88fc57d0ae5' , blockId : '7236620515792246272' , version : 1 , type : 0 , amount : 200000000 , fee : 10000000 , sender : 'ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo' , recipient : 'AbfQq8iRSf9TFQRzQWo33dHYU7HFMS17Zd' , signature : '304402206f1a45d0e8fadf033bfd539ddf05aa33ca296813f30a72a0e17d560e2d04ba8e02204a2525972d14bb3da407a04f2b9d797747a4eb99ff547e4803f60143f6a68543' , confirmations : 0 , timestamp : { epoch : 54759242 , unix : 1544860442 , human : '2018-12-15T07:54:02.000Z' } } } You can see that the confirmations key holds the number of confirmations this transaction has received from the network, in the above case 0. As the average block takes 8 seconds to forge, finality is typically established within a minute following a transaction's addition to the blockchain. Check Node Status \u00b6 Checking node status can be done by using the node resource's status method: exchangeClient . resource ( \"node\" ) . status () . then ( response => { console . log ( response . data ); }); ... func main () { ... responseStruct , _ , err := client . Node . Status ( context . TODO ()) if err != nil { log . Panic ( err ) } spew . Dump ( responseStruct ) } pprint ( client . node . status ()) By running this code, you'd see the output in your console resembling the following object: { data : { synced : true , // whether this node is fully synchronized with the network now : 14468 , // the current network height of this node's blockchain blocksCount : 0 // if not synced, the number of blocks yet to be synced } } If synced is true, your node is operating as expected and fully synced with the Solar network. Otherwise, use the blocksCount key to get an estimation of how long your node will take to sync.", "title": "Public API quick guide" }, { "location": "exchanges/public-api-guide/#exchanges-api-guide", "text": "For exchanges we recommend the usage of JSON-RPC server with optimized methods for client and crypto functionality. Best practice is to install a Relay Node and JSON-RPC in a secure environment. If really necessary then follow the basic instructions for connection via Public REST API. Connecting to the PUBLIC API is done via the Crypto and Client SDKs . Many queries can be performed using the Client SDK alone, while the Crypto SDK performs any actions requiring cryptographic functionality (i.e., signing transactions). At a surface level, the two SDKs are separated by their functions and intended use cases: The Crypto SDK provides the cryptographic functions necessary to authenticate and validate Solar transactions. The Client SDK provides wrapper functions to unify and streamline API calls between your application and the Solar blockchain. Put another way, the Crypto SDK structures your data in a format that all Solar nodes can understand, while the Client SDK handles the actual communication between your application and an Solar node. Where the Crypto SDK is internal, the Client SDK is external, as the below diagram illustrates: Note that the Public API is only available after a node has fully synced. This ensures your data on the blockchain is up to date.", "title": "Exchanges API Guide" }, { "location": "exchanges/public-api-guide/#setup", "text": "These quick actions will all assume you've loaded a Client instance with the IP address of your node and the API version you're requesting. Solar Node (v1) has been deprecated. Some references to V1 client constructors may remain for legacy purposes. However, no current clients require you to specify the API Version (defaults to v2). const Client = require ( \"@solar/client\" ); const exchangeClient = new Client ( \"YOUR.NODE.IP\" , 2 ); HashMap < String , Object > map = new HashMap <> (); map . put ( \"host\" , \"http://node-ip:port/api/\" ); map . put ( \"API-Version\" , 2 ); Connection < Two > connection = new Connection ( map ); package main import ( sxp \"github.com/solar/go-client/client\" \"net/url\" ) func main () { client := sxp . NewClient ( nil ) client . BaseURL , _ = url . Parse ( \"http://{NODE_IP}:{NODE_HOST}/api\" ) from client import ArkClient client = ArkClient ( 'http://127.0.0.1:6003/api' )", "title": "Setup" }, { "location": "exchanges/public-api-guide/#check-wallet-balance", "text": "Checking a wallet balance involves using the wallets resource to GET the wallet corresponding to a given Solar address. const walletAddress = \"ARyNwFj7nQUCip5gYt4gSWG6F8evL93eBL\" ; let wallet ; exchangeClient . resource ( \"wallets\" ) . get ( walletAddress ) . then ( response => { wallet = response . data . data ; }) . catch ( error => { console . log ( error ); }); console . log ( wallet . balance ); ... import \"github.com/davecgh/go-spew/spew\" func main () { ... responseStruct , _ , err := client . Wallets . Get ( context . TODO (), \"ARyNwFj7nQUCip5gYt4gSWG6F8evL93eBL\" ) if err != nil { log . Panic ( err ) } spew . Dump ( responseStruct ) } from pprint import pprint pprint ( client . wallets . get ( wallet_id = 'ARyNwFj7nQUCip5gYt4gSWG6F8evL93eBL' ))", "title": "Check Wallet Balance" }, { "location": "exchanges/public-api-guide/#find-block-information", "text": "If you know the ID of the block you are looking for, you can use the GET method on the blocks resource to return information on that block. const blockId = 4439278960598580069 ; let block ; exchangeClient . resource ( \"blocks\" ) . get ( blockId ) . then ( response => { block = response . data . data ; }) . catch ( error => { console . log ( error ); }); console . log ( block ); func main () { ... responseStruct , _ , err := client . Blocks . Get ( context . TODO (), 4439278960598580069 ) if err != nil { log . Panic ( err ) } spew . Dump ( responseStruct ) } pprint ( client . blocks . get ( block_id = '4439278960598580069' )) Alternatively, if you are not sure of the block ID, or if you want to find all wallets in a range, you can make use of the wallets.search method. This endpoint accepts a JSON object representing the search parameters to use when narrowing down a list of blocks. The following block properties can be used to create your range: timestamp height numberOfTransactions totalAmount totalFee reward payloadLength To use any of these properties as a range, include the relevant key in your request as an object containing from and to specifiers. For example, this code can be used to search all blocks between blockchain heights 720 and 735 with total fees between 0 and 2000 arktoshi: exchangeClient . resource ( \"blocks\" ) . search ({ height : { from : 720 , to : 735 }, totalFee : { from : 0 , to : 2000 } }) . then ( response => { console . log ( response . data ); // all blocks matching the search criteria }); func main () { ... responseStruct , _ , err := client . Blocks . Search ( context . TODO (), sxp . BlocksSearchRequest { Height : sxp . FromTo { From : 720 , To : 735 }, TotalFee : sxp . FromTo { From : 0 , To : 2000 }, }) if err != nil { log . Panic ( err ) } spew . Dump ( responseStruct ) } pprint ( client . blocks . search ({ \"height\" : { \"from\" : 720 , \"to\" : 735 }, \"totalFee\" : { \"from\" : 0 , \"to\" : 2000 }, }))", "title": "Find Block Information" }, { "location": "exchanges/public-api-guide/#create-and-broadcast-transactions", "text": "To create transactions, make use of the transactionBuilder module of @solar/crypto . First, install the package from npm or your language's equivalent: yarn add @solar/crypto go get -u github.com/solar/go-crypto/crypto pip install solar-crypto The crypto package functionality we'll use here is the transactionBuilder, which provides a series of \"chainable\" methods that can be called, one after another, to produce a transaction object. These methods create and define your transaction: its type, its amount in arktoshi, its signature, and more. Regardless of which SDK you use, every transactionBuilder contains a similar function to getStruct , which will return a completed transaction object. After making one or more of these transaction objects, you can combine them into an array to use as the transactions key in your request. With all the steps together, here is an example of how to send a transaction for approval: const crypto = require ( \"@solar/crypto\" ); const transactionBuilder = crypto . transactionBuilder ; const transaction = transactionBuilder . transfer () . amount ( 2 * Math . pow ( 10 , 8 )) . recipientId ( recipientId ) . sign ( passphrase ) . getStruct (); exchangeClient . resource ( \"transactions\" ) . create ({ transactions : [ transaction ] }) . then ( response => { console . log ( response . data ); if ( response . data . errors ) { errors . forEach ( error => { console . log ( error ); }); } }) . catch ( error => { console . log ( error ); }); ... import ark_crypto \"github.com/solar/go-crypto/crypto\" func main () { ... transaction := ark_crypto . BuildTransfer ( recipientId , uint64 ( amount ), \"Hello World\" , passphrase , ) // cast is a fictitious helper function which alters ark_crypto.Transaction // into an ark_client.CreateTransactionRequest. responseStruct , _ , err := client . Transaction . Create ( context . TODO (), cast ( transaction )) if err != nil { log . Panic ( err ) } spew . Dump ( responseStruct ) } ... from crypto.transactions.builder.transfer import Transfer tx = Transfer ( recipientId = recipientId , amount = 1000 ) tx . sign ( passphrase ) pprint ( client . transactions . create ([ tx ])) There are a few things worth noticing about the above code. Firstly, the code assumes that you have declared two variables already: passphrase - the passphrase of the sending account, used to sign the transaction. This should come from somewhere secure, such as a .env file. recipientId - the Solar address of the receiving account. Should be provided by the exchange user when submitting withdrawal requests. Second, when sending your request using the exchangeClient , ensure that the value of transactions is an array, even if you have only one transaction object. If your request is successful, you will receive a response with the following data key: { data : { accept : [ '96e3952b66a370d8145055b55cedc6f1435b3a71cb17334aa954f8844ad1202f' ], broadcast : [ '96e3952b66a370d8145055b55cedc6f1435b3a71cb17334aa954f8844ad1202f' ], excess : [], invalid : [] }, errors : null } Let us look at the returned data object in more depth. It is composed of four arrays, each holding zero or more transaction IDs: accept - a list of all accepted transactions broadcast - a list of all transactions broadcast to the network excess - if the node's transaction pool is full, this lists all excess transactions invalid - a list of all transactions deemed invalid by the node Our sample code above submitted one transaction, which the node accepted and broadcast and thus the accept and broadcast arrays contain precisely one item each: the ID of the transaction we submitted. If we had submitted any invalid transactions, the invalid list would have contained their IDs, and the errors key would have been populated with one error per invalid transaction. The diagram below offers a top-level overview of the transaction submission process:", "title": "Create and Broadcast Transactions" }, { "location": "exchanges/public-api-guide/#check-transaction-confirmations", "text": "Once a transaction has been created and added to the blockchain, you can access the number of confirmations it has by using the transactions resource to get the value matching the transaction ID. const transactionId = \"9085b309dd0c20c12c1a00c40e1c71cdadaa74476b669e9f8a632db337fb6915\" ; exchangeClient . resource ( \"transactions\" ) . get ( transactionId ) . then ( response => { console . log ( response . data ); }); ... func main () { ... txID := \"9085b309dd0c20c12c1a00c40e1c71cdadaa74476b669e9f8a632db337fb6915\" responseStruct , _ , err := client . Transactions . Get ( context . TODO (), txID ) if err != nil { log . Panic ( err ) } spew . Dump ( responseStruct ) } txID = \"9085b309dd0c20c12c1a00c40e1c71cdadaa74476b669e9f8a632db337fb6915\" pprint ( client . transactions . get ( transaction_id = txID )) If the transaction has been added to the blockchain, you'll receive the following data structure in your console: { data : { id : 'a4d3d3ab059b8445894805c1158f06049a4200b2878892e18d95b88fc57d0ae5' , blockId : '7236620515792246272' , version : 1 , type : 0 , amount : 200000000 , fee : 10000000 , sender : 'ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo' , recipient : 'AbfQq8iRSf9TFQRzQWo33dHYU7HFMS17Zd' , signature : '304402206f1a45d0e8fadf033bfd539ddf05aa33ca296813f30a72a0e17d560e2d04ba8e02204a2525972d14bb3da407a04f2b9d797747a4eb99ff547e4803f60143f6a68543' , confirmations : 0 , timestamp : { epoch : 54759242 , unix : 1544860442 , human : '2018-12-15T07:54:02.000Z' } } } You can see that the confirmations key holds the number of confirmations this transaction has received from the network, in the above case 0. As the average block takes 8 seconds to forge, finality is typically established within a minute following a transaction's addition to the blockchain.", "title": "Check Transaction Confirmations" }, { "location": "exchanges/public-api-guide/#check-node-status", "text": "Checking node status can be done by using the node resource's status method: exchangeClient . resource ( \"node\" ) . status () . then ( response => { console . log ( response . data ); }); ... func main () { ... responseStruct , _ , err := client . Node . Status ( context . TODO ()) if err != nil { log . Panic ( err ) } spew . Dump ( responseStruct ) } pprint ( client . node . status ()) By running this code, you'd see the output in your console resembling the following object: { data : { synced : true , // whether this node is fully synchronized with the network now : 14468 , // the current network height of this node's blockchain blocksCount : 0 // if not synced, the number of blocks yet to be synced } } If synced is true, your node is operating as expected and fully synced with the Solar network. Otherwise, use the blocksCount key to get an estimation of how long your node will take to sync.", "title": "Check Node Status" }, { "location": "exchanges/json-rpc/examples/", "text": "Examples \u00b6 All HTTP requests have to be sent with the Content-Type: application/vnd.api+json header. If the header is not present, it will result in malformed responses or request rejections. const axios = require ( 'axios' ) // install using npm: `npm install axios` const url = \"http://0.0.0.0:8080\" // http://${NODE_IP}:${JSON-RPC_PORT} const headers = { \"Content-Type\" : \"application/json\" } const body = {} // this object is unique to each method described below axios . post ( url , body , headers ) . then ( response => { console . log ( response . result ) } . catch ( error => { console . log ( error ) }) package main import ( \"bytes\" \"encoding/json\" \"net/http\" ) func post ( URL string , body interface {}) ( * http . Response , error ) { b := new ( bytes . Buffer ) err := json . NewEncoder ( b ). Encode ( u ) if err != nil { return nil , err } return http . Post ( URL , \"application/json\" , b ) } type request struct { Jsonrpc string `json:\"jsonrpc\"` Method string `json:\"method\"` ID int `json:\"id\"` Params interface {} `json:\"params\"` } func main () { resp , err := post ( \"http://0.0.0.0:8080\" , request {}, ) } import requests r = requests . post ( \"http://0.0.0.0:8080\" ) print ( r ) To complete the template, replace the empty body object with the objects provided in each quick action. The blocks.latest method, for example, can be accessed by the following script: const axios = require ( 'axios' ) // install from npm with `npm install axios` const url = \"http://0.0.0.0:8080\" // http://${NODE_ID}:${JSON-RPC-PORT} const headers = { \"Content-Type\" : \"application/json\" } const body = { jsonrpc : \"2.0\" , // JSON-RPC API version. method : \"blocks.latest\" , // RPC method. id : 31 // internal ID to track responses. } axios . post ( url , body , headers ) . then ( response => { console . log ( response . data ) } . catch ( error => { console . log ( error ) }) package main import ( \"bytes\" \"encoding/json\" \"net/http\" ) func post ( URL string , body interface {}) ( * http . Response , error ) { b := new ( bytes . Buffer ) err := json . NewEncoder ( b ). Encode ( u ) if err != nil { return nil , err } return http . Post ( URL , \"application/json; charset=utf-8\" , b ) } type request struct { Jsonrpc string `json:\"jsonrpc\"` Method string `json:\"method\"` ID int `json:\"id\"` Params interface {} `json:\"params\"` } func main () { resp , err := post ( \"http://0.0.0.0:8080\" , request { Jsonrpc : \"2.0\" , Method : \"blocks.latest\" , ID : 31 , Params : nil , }, ) } import requests r = requests . post ( \"http://0.0.0.0:8080\" , json = { \"jsonrpc\" : \"2.0\" , \"method\" : \"blocks.latest\" , \"id\" : 31 } ) print ( r ) Check Wallet Balance \u00b6 This method can be used to check the account balance associated with a particular Solar address. To utilize it, use the following body payload: const body = { jsonrpc : \"2.0\" , method : \"wallets.info\" , id : 31 // internal ID to track responses params : { address : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" // the address of the wallet being queried. } } package main ... type walletInfoParams struct { Address string `json:\"address\"` } func main () { resp , err := post ( \"http://0.0.0.0:8080\" , request { Jsonrpc : \"2.0\" , Method : \"wallets.info\" , ID : 31 , Params : walletInfoParams { Address : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" , }, }, ) } r = requests . post ( \"http://0.0.0.0:8080\" , json = { \"jsonrpc\" : \"2.0\" , \"method\" : \"wallets.info\" , \"id\" : 31 , \"params\" : { \"address\" : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" , }, } ) The response will contain the jsonrpc and id you used to call the request, along with a payload containing the following data: { \"address\" : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" , \"balance\" : 245098210000000 , \"isDelegate\" : true , \"publicKey\" : \"02532c68cd0842fb86b2202c1027eafc741bdd581517047d9d19319e6741c54883\" , \"secondPublicKey\" : null , \"username\" : \"genesis_30\" } Find Block Information \u00b6 If you want to retrieve the latest block on the blockchain, call the blocks.latest method with no parameters: const body = { jsonrpc : \"2.0\" , method : \"blocks.latest\" , id : 31 // internal ID to track responses }; package main ... func main () { resp , err := post ( \"http://0.0.0.0:8080\" , request { Jsonrpc : \"2.0\" , Method : \"blocks.latest\" , ID : 31 , Params : nil , }, ) } r = requests . post ( \"http://0.0.0.0:8080\" , json = { \"jsonrpc\" : \"2.0\" , \"method\" : \"blocks.latest\" , \"id\" : 31 } ) This returns a response similar to the following: { \"forged\" : { \"amount\" : 0 , \"fee\" : 0 , \"reward\" : 0 , \"total\" : 0 }, \"generator\" : { \"address\" : \"AdWRsk7Lbo97jxGBKzLAFwevVHbqVbW1Cj\" , \"publicKey\" : \"03691178f8610d0a295e650201b62345056c788d7f9ac7e8570b69c6c90091b564\" , \"username\" : \"genesis_8\" }, \"height\" : 20582 , \"id\" : \"5897025410627682852\" , \"payload\" : { \"hash\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"length\" : 0 }, \"previous\" : \"9643009166535029717\" , \"signature\" : \"30440220772362881112eb0ce65d2a91b92cbb6b404f83165edfc95aa2cfb19a02026a3a022010bec681e7b9abfca61a4961f0e29db6730e8d3f9c649b5ab4b7eee1b919897e\" , \"timestamp\" : { \"epoch\" : 54902770 , \"human\" : \"2018-12-16T23:46:10.000Z\" , \"unix\" : 1545003970 }, \"transactions\" : 0 , \"version\" : 0 } Create and Broadcast Transactions \u00b6 Creating a transaction using the JSON-RPC is a two-step process: Create the transaction object with transactions.create . Broadcast the transaction to the network with transactions.broadcast . The transactions.create endpoint accepts three parameters: RecipientId Amount Passphrase An example transaction creation payload could look like this: const body = { jsonrpc : \"2.0\" , method : \"transactions.create\" , id : 31 params : { recipientId : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" // the address you want to send to, amount : \"200000000\" , // 2 Solar * 100,000,000 arktoshi/SXP passphrase : \"craft imitate step mixture patch forest volcano business charge around girl confirm\" } } package main ... type transaction struct { RecipientId string `json:\"recipientId\"` Amount string `json:\"amount\"` Passphrase string `json:\"passphrase\"` } func main () { resp , err := post ( \"http://0.0.0.0:8080\" , request { Jsonrpc : \"2.0\" , Method : \"transactions.create\" , ID : 31 , Params : transaction { Address : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" , Amount : \"200000000\" , // 2 Solar * 100,000,000 arktoshi/SXP Passphrase : \"craft imitate step mixture patch forest volcano business charge around girl confirm\" , }, }, ) } r = requests . post ( \"http://0.0.0.0:8080\" , json = { \"jsonrpc\" : \"2.0\" , \"method\" : \"transactions.create\" , \"id\" : 31 , \"params\" : { \"recipientId\" : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" # the address you want to send to, \"amount\" : \"200000000\" , # 2 Solar * 100,000,000 arktoshi/SXP \"passphrase\" : \"craft imitate step mixture patch forest volcano business charge around girl confirm\" }, } ) This endpoint will return a transaction object similar to the following: { \"amount\" : \"200000000\" , \"fee\" : 10000000 , \"id\" : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" , \"recipientId\" : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" , \"senderPublicKey\" : \"038082dad560a22ea003022015e3136b21ef1ffd9f2fd50049026cbe8e2258ca17\" , \"signature\" : \"304402204236a59a19266b5969e18f87d6d4b178180277c79beb5d4b42f272ee03fba0b702200c6c97ed5ab2e6231f3dce5cdfe740e72261b460f896fb4c5be0ca7ce6244c67\" , \"timestamp\" : 54903765 , \"type\" : 0 } Importantly, this does not mean your transaction has been added to the blockchain! To do so, we'll need to submit a second request to transactions.broadcast . This request should have a params object with a single key: the id key returned by transactions.create . With the returned ID, our second request body looks like this: const body = { jsonrpc : \"2.0\" , method : \"transactions.broadcast\" , id : 31 params : { id : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" } } package main ... type broadcast struct { Id string `json:\"id\"` } func main () { resp , err := post ( \"http://0.0.0.0:8080\" , request { Jsonrpc : \"2.0\" , Method : \"transactions.broadcast\" , ID : 31 , Params : broadcast { Id : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" , }, }, ) } r = requests . post ( \"http://0.0.0.0:8080\" , json = { \"jsonrpc\" : \"2.0\" , \"method\" : \"transactions.broadcast\" , \"id\" : 31 , \"params\" : { \"id\" : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" , }, } ) If we receive the same transaction object as the call to transactions.create , our transaction was successful. Within your application, one way to confirm the result is to check that result.id matches the transaction ID you provided to the endpoint. Otherwise, the errors key will contain more information on what went wrong. Check Transaction Confirmations \u00b6 Checking the number of confirmations a transaction can be done via JSON-RPC by the transactions.info method. The command accepts one parameter: the id of the transaction to query. A sample request could look like: const body = { jsonrpc : \"2.0\" , method : \"transactions.info\" , id : 9 , params : { id : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" } }; package main ... type transactionInfo struct { Id string `json:\"id\"` } func main () { resp , err := post ( \"http://0.0.0.0:8080\" , request { Jsonrpc : \"2.0\" , Method : \"transactions.info\" , ID : 31 , Params : transactionInfo { id : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" , }, }, ) } r = requests . post ( \"http://0.0.0.0:8080\" , json = { \"jsonrpc\" : \"2.0\" , \"method\" : \"transactions.info\" , \"id\" : 31 , \"params\" : { \"id\" : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" , }, } ) If successful, you'll receive a response similar to the following: { \"amount\" : 200000000 , \"blockId\" : \"16888082711050311577\" , \"confirmations\" : 27 , \"fee\" : 10000000 , \"id\" : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" , \"recipient\" : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" , \"sender\" : \"ARAibxGqLQJTo1bWMJfu5fCc88rdWWjqgv\" , \"signature\" : \"304402204236a59a19266b5969e18f87d6d4b178180277c79beb5d4b42f272ee03fba0b702200c6c97ed5ab2e6231f3dce5cdfe740e72261b460f896fb4c5be0ca7ce6244c67\" , \"timestamp\" : { \"epoch\" : 54903765 , \"human\" : \"2018-12-17T00:02:45.000Z\" , \"unix\" : 1545004965 }, \"type\" : 0 , \"version\" : 1 } This particular transaction has 27 confirmations, meaning you can be confident that this transaction has been irreversibly included in the blockchain. Most exchanges use a minimum of 51 confirmations, which is one complete round.", "title": "Examples" }, { "location": "exchanges/json-rpc/examples/#examples", "text": "All HTTP requests have to be sent with the Content-Type: application/vnd.api+json header. If the header is not present, it will result in malformed responses or request rejections. const axios = require ( 'axios' ) // install using npm: `npm install axios` const url = \"http://0.0.0.0:8080\" // http://${NODE_IP}:${JSON-RPC_PORT} const headers = { \"Content-Type\" : \"application/json\" } const body = {} // this object is unique to each method described below axios . post ( url , body , headers ) . then ( response => { console . log ( response . result ) } . catch ( error => { console . log ( error ) }) package main import ( \"bytes\" \"encoding/json\" \"net/http\" ) func post ( URL string , body interface {}) ( * http . Response , error ) { b := new ( bytes . Buffer ) err := json . NewEncoder ( b ). Encode ( u ) if err != nil { return nil , err } return http . Post ( URL , \"application/json\" , b ) } type request struct { Jsonrpc string `json:\"jsonrpc\"` Method string `json:\"method\"` ID int `json:\"id\"` Params interface {} `json:\"params\"` } func main () { resp , err := post ( \"http://0.0.0.0:8080\" , request {}, ) } import requests r = requests . post ( \"http://0.0.0.0:8080\" ) print ( r ) To complete the template, replace the empty body object with the objects provided in each quick action. The blocks.latest method, for example, can be accessed by the following script: const axios = require ( 'axios' ) // install from npm with `npm install axios` const url = \"http://0.0.0.0:8080\" // http://${NODE_ID}:${JSON-RPC-PORT} const headers = { \"Content-Type\" : \"application/json\" } const body = { jsonrpc : \"2.0\" , // JSON-RPC API version. method : \"blocks.latest\" , // RPC method. id : 31 // internal ID to track responses. } axios . post ( url , body , headers ) . then ( response => { console . log ( response . data ) } . catch ( error => { console . log ( error ) }) package main import ( \"bytes\" \"encoding/json\" \"net/http\" ) func post ( URL string , body interface {}) ( * http . Response , error ) { b := new ( bytes . Buffer ) err := json . NewEncoder ( b ). Encode ( u ) if err != nil { return nil , err } return http . Post ( URL , \"application/json; charset=utf-8\" , b ) } type request struct { Jsonrpc string `json:\"jsonrpc\"` Method string `json:\"method\"` ID int `json:\"id\"` Params interface {} `json:\"params\"` } func main () { resp , err := post ( \"http://0.0.0.0:8080\" , request { Jsonrpc : \"2.0\" , Method : \"blocks.latest\" , ID : 31 , Params : nil , }, ) } import requests r = requests . post ( \"http://0.0.0.0:8080\" , json = { \"jsonrpc\" : \"2.0\" , \"method\" : \"blocks.latest\" , \"id\" : 31 } ) print ( r )", "title": "Examples" }, { "location": "exchanges/json-rpc/examples/#check-wallet-balance", "text": "This method can be used to check the account balance associated with a particular Solar address. To utilize it, use the following body payload: const body = { jsonrpc : \"2.0\" , method : \"wallets.info\" , id : 31 // internal ID to track responses params : { address : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" // the address of the wallet being queried. } } package main ... type walletInfoParams struct { Address string `json:\"address\"` } func main () { resp , err := post ( \"http://0.0.0.0:8080\" , request { Jsonrpc : \"2.0\" , Method : \"wallets.info\" , ID : 31 , Params : walletInfoParams { Address : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" , }, }, ) } r = requests . post ( \"http://0.0.0.0:8080\" , json = { \"jsonrpc\" : \"2.0\" , \"method\" : \"wallets.info\" , \"id\" : 31 , \"params\" : { \"address\" : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" , }, } ) The response will contain the jsonrpc and id you used to call the request, along with a payload containing the following data: { \"address\" : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" , \"balance\" : 245098210000000 , \"isDelegate\" : true , \"publicKey\" : \"02532c68cd0842fb86b2202c1027eafc741bdd581517047d9d19319e6741c54883\" , \"secondPublicKey\" : null , \"username\" : \"genesis_30\" }", "title": "Check Wallet Balance" }, { "location": "exchanges/json-rpc/examples/#find-block-information", "text": "If you want to retrieve the latest block on the blockchain, call the blocks.latest method with no parameters: const body = { jsonrpc : \"2.0\" , method : \"blocks.latest\" , id : 31 // internal ID to track responses }; package main ... func main () { resp , err := post ( \"http://0.0.0.0:8080\" , request { Jsonrpc : \"2.0\" , Method : \"blocks.latest\" , ID : 31 , Params : nil , }, ) } r = requests . post ( \"http://0.0.0.0:8080\" , json = { \"jsonrpc\" : \"2.0\" , \"method\" : \"blocks.latest\" , \"id\" : 31 } ) This returns a response similar to the following: { \"forged\" : { \"amount\" : 0 , \"fee\" : 0 , \"reward\" : 0 , \"total\" : 0 }, \"generator\" : { \"address\" : \"AdWRsk7Lbo97jxGBKzLAFwevVHbqVbW1Cj\" , \"publicKey\" : \"03691178f8610d0a295e650201b62345056c788d7f9ac7e8570b69c6c90091b564\" , \"username\" : \"genesis_8\" }, \"height\" : 20582 , \"id\" : \"5897025410627682852\" , \"payload\" : { \"hash\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"length\" : 0 }, \"previous\" : \"9643009166535029717\" , \"signature\" : \"30440220772362881112eb0ce65d2a91b92cbb6b404f83165edfc95aa2cfb19a02026a3a022010bec681e7b9abfca61a4961f0e29db6730e8d3f9c649b5ab4b7eee1b919897e\" , \"timestamp\" : { \"epoch\" : 54902770 , \"human\" : \"2018-12-16T23:46:10.000Z\" , \"unix\" : 1545003970 }, \"transactions\" : 0 , \"version\" : 0 }", "title": "Find Block Information" }, { "location": "exchanges/json-rpc/examples/#create-and-broadcast-transactions", "text": "Creating a transaction using the JSON-RPC is a two-step process: Create the transaction object with transactions.create . Broadcast the transaction to the network with transactions.broadcast . The transactions.create endpoint accepts three parameters: RecipientId Amount Passphrase An example transaction creation payload could look like this: const body = { jsonrpc : \"2.0\" , method : \"transactions.create\" , id : 31 params : { recipientId : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" // the address you want to send to, amount : \"200000000\" , // 2 Solar * 100,000,000 arktoshi/SXP passphrase : \"craft imitate step mixture patch forest volcano business charge around girl confirm\" } } package main ... type transaction struct { RecipientId string `json:\"recipientId\"` Amount string `json:\"amount\"` Passphrase string `json:\"passphrase\"` } func main () { resp , err := post ( \"http://0.0.0.0:8080\" , request { Jsonrpc : \"2.0\" , Method : \"transactions.create\" , ID : 31 , Params : transaction { Address : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" , Amount : \"200000000\" , // 2 Solar * 100,000,000 arktoshi/SXP Passphrase : \"craft imitate step mixture patch forest volcano business charge around girl confirm\" , }, }, ) } r = requests . post ( \"http://0.0.0.0:8080\" , json = { \"jsonrpc\" : \"2.0\" , \"method\" : \"transactions.create\" , \"id\" : 31 , \"params\" : { \"recipientId\" : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" # the address you want to send to, \"amount\" : \"200000000\" , # 2 Solar * 100,000,000 arktoshi/SXP \"passphrase\" : \"craft imitate step mixture patch forest volcano business charge around girl confirm\" }, } ) This endpoint will return a transaction object similar to the following: { \"amount\" : \"200000000\" , \"fee\" : 10000000 , \"id\" : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" , \"recipientId\" : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" , \"senderPublicKey\" : \"038082dad560a22ea003022015e3136b21ef1ffd9f2fd50049026cbe8e2258ca17\" , \"signature\" : \"304402204236a59a19266b5969e18f87d6d4b178180277c79beb5d4b42f272ee03fba0b702200c6c97ed5ab2e6231f3dce5cdfe740e72261b460f896fb4c5be0ca7ce6244c67\" , \"timestamp\" : 54903765 , \"type\" : 0 } Importantly, this does not mean your transaction has been added to the blockchain! To do so, we'll need to submit a second request to transactions.broadcast . This request should have a params object with a single key: the id key returned by transactions.create . With the returned ID, our second request body looks like this: const body = { jsonrpc : \"2.0\" , method : \"transactions.broadcast\" , id : 31 params : { id : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" } } package main ... type broadcast struct { Id string `json:\"id\"` } func main () { resp , err := post ( \"http://0.0.0.0:8080\" , request { Jsonrpc : \"2.0\" , Method : \"transactions.broadcast\" , ID : 31 , Params : broadcast { Id : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" , }, }, ) } r = requests . post ( \"http://0.0.0.0:8080\" , json = { \"jsonrpc\" : \"2.0\" , \"method\" : \"transactions.broadcast\" , \"id\" : 31 , \"params\" : { \"id\" : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" , }, } ) If we receive the same transaction object as the call to transactions.create , our transaction was successful. Within your application, one way to confirm the result is to check that result.id matches the transaction ID you provided to the endpoint. Otherwise, the errors key will contain more information on what went wrong.", "title": "Create and Broadcast Transactions" }, { "location": "exchanges/json-rpc/examples/#check-transaction-confirmations", "text": "Checking the number of confirmations a transaction can be done via JSON-RPC by the transactions.info method. The command accepts one parameter: the id of the transaction to query. A sample request could look like: const body = { jsonrpc : \"2.0\" , method : \"transactions.info\" , id : 9 , params : { id : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" } }; package main ... type transactionInfo struct { Id string `json:\"id\"` } func main () { resp , err := post ( \"http://0.0.0.0:8080\" , request { Jsonrpc : \"2.0\" , Method : \"transactions.info\" , ID : 31 , Params : transactionInfo { id : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" , }, }, ) } r = requests . post ( \"http://0.0.0.0:8080\" , json = { \"jsonrpc\" : \"2.0\" , \"method\" : \"transactions.info\" , \"id\" : 31 , \"params\" : { \"id\" : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" , }, } ) If successful, you'll receive a response similar to the following: { \"amount\" : 200000000 , \"blockId\" : \"16888082711050311577\" , \"confirmations\" : 27 , \"fee\" : 10000000 , \"id\" : \"b60525042509586151fac7e3c70fe7a75ca00ffdf9988f20d0c1c0f3db798e86\" , \"recipient\" : \"AMv3iLrvyvpi6d4wEfLqX8kzMxaRvxAcHT\" , \"sender\" : \"ARAibxGqLQJTo1bWMJfu5fCc88rdWWjqgv\" , \"signature\" : \"304402204236a59a19266b5969e18f87d6d4b178180277c79beb5d4b42f272ee03fba0b702200c6c97ed5ab2e6231f3dce5cdfe740e72261b460f896fb4c5be0ca7ce6244c67\" , \"timestamp\" : { \"epoch\" : 54903765 , \"human\" : \"2018-12-17T00:02:45.000Z\" , \"unix\" : 1545004965 }, \"type\" : 0 , \"version\" : 1 } This particular transaction has 27 confirmations, meaning you can be confident that this transaction has been irreversibly included in the blockchain. Most exchanges use a minimum of 51 confirmations, which is one complete round.", "title": "Check Transaction Confirmations" }, { "location": "exchanges/json-rpc/getting-started/", "text": "Getting Started \u00b6 The Exchange JSON-RPC is only maintained for exchanges, as the name suggests. We do not offer any support or guidance unless you are an Exchange in which case you most likely will already be in touch with us. Installation via Yarn \u00b6 yarn global add @arkecosystem/exchange-json-rpc-cli Usage instructions \u00b6 All commands support a -h flag to show help for the specified command. $ exchange-json-rpc A JSON-RPC 2 .0 specification compliant server for Exchanges to interact with the Solar Blockchain. VERSION @arkecosystem/exchange-json-rpc-cli/1.0.0 darwin-x64 node-v10.16.0 USAGE $ exchange-json-rpc [ COMMAND ] COMMANDS autocomplete display autocomplete installation instructions command commands list all the commands help display help for exchange-json-rpc log Show the log restart Restart the JSON-RPC run Run the JSON-RPC ( without pm2 ) start Start the JSON-RPC status Show the JSON-RPC status stop Stop the JSON-RPC update Update the exchange-json-rpc installation start \u00b6 Start the JSON-RPC exchange-json-rpc start Flag Description Default Required --[no-]allowRemote allow remote connections which are filtered by a whitelist n/a No --network= the name of the network that should be used mainnet No --token= the name of the token that should be used sxp No --host= the host that should be used to expose the RPC 0.0.0.0 No --port= the port that should be used to expose the RPC 8008 No --peer= the peer you want to use for communication, defaults to random network peers n/a No --whitelist= a comma separated list of IPs that can access the RPC 127.0.0.1,::ffff:127.0.0.1 No restart \u00b6 Restart the JSON-RPC exchange-json-rpc restart stop \u00b6 Stop the JSON-RPC exchange-json-rpc stop Flag Description Default Required --kill kill the process or daemon n/a No run \u00b6 Run the JSON-RPC without pm2 (exits on CTRL+C) exchange-json-rpc run Flag Description Default Required --[no-]allowRemote allow remote connections which are filtered by a whitelist n/a No --network= the name of the network that should be used mainnet No --token= the name of the token that should be used sxp No --host= the host that should be used to expose the RPC 0.0.0.0 No --port= the port that should be used to expose the RPC 8008 No --peer= the peer you want to use for communication, defaults to random network peers n/a No --whitelist= a comma separated list of IPs that can access the RPC 127.0.0.1,::ffff:127.0.0.1 No status \u00b6 Show the JSON-RPC status exchange-json-rpc status update \u00b6 Update the JSON-RPC installation exchange-json-rpc update log \u00b6 Show the log exchange-json-rpc log Flag Description Default Required --error= only show error output n/a No --lines= number of lines to tail 15 No Security \u00b6 If you discover a security vulnerability within this package, please send an e-mail to security@solar.network . All security vulnerabilities will be promptly addressed.", "title": "Getting Started" }, { "location": "exchanges/json-rpc/getting-started/#getting-started", "text": "The Exchange JSON-RPC is only maintained for exchanges, as the name suggests. We do not offer any support or guidance unless you are an Exchange in which case you most likely will already be in touch with us.", "title": "Getting Started" }, { "location": "exchanges/json-rpc/getting-started/#installation-via-yarn", "text": "yarn global add @arkecosystem/exchange-json-rpc-cli", "title": "Installation via Yarn" }, { "location": "exchanges/json-rpc/getting-started/#usage-instructions", "text": "All commands support a -h flag to show help for the specified command. $ exchange-json-rpc A JSON-RPC 2 .0 specification compliant server for Exchanges to interact with the Solar Blockchain. VERSION @arkecosystem/exchange-json-rpc-cli/1.0.0 darwin-x64 node-v10.16.0 USAGE $ exchange-json-rpc [ COMMAND ] COMMANDS autocomplete display autocomplete installation instructions command commands list all the commands help display help for exchange-json-rpc log Show the log restart Restart the JSON-RPC run Run the JSON-RPC ( without pm2 ) start Start the JSON-RPC status Show the JSON-RPC status stop Stop the JSON-RPC update Update the exchange-json-rpc installation", "title": "Usage instructions" }, { "location": "exchanges/json-rpc/getting-started/#start", "text": "Start the JSON-RPC exchange-json-rpc start Flag Description Default Required --[no-]allowRemote allow remote connections which are filtered by a whitelist n/a No --network= the name of the network that should be used mainnet No --token= the name of the token that should be used sxp No --host= the host that should be used to expose the RPC 0.0.0.0 No --port= the port that should be used to expose the RPC 8008 No --peer= the peer you want to use for communication, defaults to random network peers n/a No --whitelist= a comma separated list of IPs that can access the RPC 127.0.0.1,::ffff:127.0.0.1 No", "title": "start" }, { "location": "exchanges/json-rpc/getting-started/#restart", "text": "Restart the JSON-RPC exchange-json-rpc restart", "title": "restart" }, { "location": "exchanges/json-rpc/getting-started/#stop", "text": "Stop the JSON-RPC exchange-json-rpc stop Flag Description Default Required --kill kill the process or daemon n/a No", "title": "stop" }, { "location": "exchanges/json-rpc/getting-started/#run", "text": "Run the JSON-RPC without pm2 (exits on CTRL+C) exchange-json-rpc run Flag Description Default Required --[no-]allowRemote allow remote connections which are filtered by a whitelist n/a No --network= the name of the network that should be used mainnet No --token= the name of the token that should be used sxp No --host= the host that should be used to expose the RPC 0.0.0.0 No --port= the port that should be used to expose the RPC 8008 No --peer= the peer you want to use for communication, defaults to random network peers n/a No --whitelist= a comma separated list of IPs that can access the RPC 127.0.0.1,::ffff:127.0.0.1 No", "title": "run" }, { "location": "exchanges/json-rpc/getting-started/#status", "text": "Show the JSON-RPC status exchange-json-rpc status", "title": "status" }, { "location": "exchanges/json-rpc/getting-started/#update", "text": "Update the JSON-RPC installation exchange-json-rpc update", "title": "update" }, { "location": "exchanges/json-rpc/getting-started/#log", "text": "Show the log exchange-json-rpc log Flag Description Default Required --error= only show error output n/a No --lines= number of lines to tail 15 No", "title": "log" }, { "location": "exchanges/json-rpc/getting-started/#security", "text": "If you discover a security vulnerability within this package, please send an e-mail to security@solar.network . All security vulnerabilities will be promptly addressed.", "title": "Security" }, { "location": "exchanges/json-rpc/endpoints/blocks/", "text": "Blocks \u00b6 Get a Block \u00b6 Method \u00b6 blocks.info Body Parameters \u00b6 Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.id string The identifier of the block to be retrieved. Yes Request \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"blocks.info\" , \"params\" : { \"id\" : \"9336364900436444611\" } } Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"id\" : \"9336364900436444611\" , \"version\" : 0 , \"height\" : 23 , \"previous\" : \"17180650139879860733\" , \"forged\" : { \"reward\" : 0 , \"fee\" : 0 , \"total\" : 0 }, \"payload\" : { \"hash\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"length\" : 0 }, \"generator\" : { \"username\" : \"genesis_43\" , \"address\" : \"AQBo4exLwyapRiDoDteh1fF2ctWWdxofSf\" , \"publicKey\" : \"034985f6f2167cc8c9df1204aaf6744bc97c0d7f3c07c43ee6c0978bc91b6c680e\" }, \"signature\" : \"3045022100b5c6ebb1c4c6694b82b98eea6c6eb889547908d8c1aff98d16f3f9df810fe34b02207266371081ffc6461da6fbb2811065aabe135c6e47863605416e6e5ddb4c7806\" , \"transactions\" : 0 , \"timestamp\" : { \"epoch\" : 50686634 , \"unix\" : 1540787834 , \"human\" : \"2018-10-29T04:37:14Z\" } } } Error Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } } Get the Latest Block \u00b6 Method \u00b6 blocks.latest Body Parameters \u00b6 Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes Request \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"blocks.latest\" } Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"id\" : \"1453043075643523354\" , \"version\" : 0 , \"height\" : 29 , \"previous\" : \"14915069404850182157\" , \"forged\" : { \"reward\" : 0 , \"fee\" : 0 , \"total\" : 0 }, \"payload\" : { \"hash\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"length\" : 0 }, \"generator\" : { \"username\" : \"genesis_42\" , \"address\" : \"AcmXmomxpP8NahbbFivq32QmLuKFkTkqRg\" , \"publicKey\" : \"0311077c86a98b67850e7ed2c81775d094cf81c6991082ddc33fc7be5347dc765d\" }, \"signature\" : \"3045022100d94630fc328f5e70a4fa6134fa8aadbaab42eff15b22e91ae17438b6f28cfd3a022014df10ff42cea9d02e549353c24a6207c3de10d85b4f91742b44ffb4f303592e\" , \"transactions\" : 0 , \"timestamp\" : { \"epoch\" : 50686712 , \"unix\" : 1540787912 , \"human\" : \"2018-10-29T04:38:32Z\" } } } Error Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } } Get a Blocks Transactions \u00b6 Method \u00b6 blocks.transactions Body Parameters \u00b6 Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.id string The identifier of the block to be retrieved. Yes params.offset int The offset of transactions to be retrieved. Yes Request \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"blocks.transactions\" , \"params\" : { \"id\" : \"17184958558311101492\" } } Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"count\" : 153 , \"data\" : [ { \"id\" : \"db1aa687737858cc9199bfa336f9b1c035915c30aaee60b1e0f8afadfdb946bd\" , \"blockId\" : \"17184958558311101492\" , \"type\" : 0 , \"amount\" : 245098000000000 , \"fee\" : 0 , \"sender\" : \"APnhwwyTbMiykJwYbGhYjNgtHiVJDSEhSn\" , \"recipient\" : \"AHXtmB84sTZ9Zd35h9Y1vfFvPE2Xzqj8ri\" , \"signature\" : \"304402205fcb0677e06bde7aac3dc776665615f4b93ef8c3ed0fddecef9900e74fcb00f302206958a0c9868ea1b1f3d151bdfa92da1ce24de0b1fcd91933e64fb7971e92f48d\" , \"confirmations\" : 3 , \"timestamp\" : { \"epoch\" : 0 , \"unix\" : 1490101200 , \"human\" : \"2017-03-21T13:00:00Z\" } } ] } } Error Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }", "title": "Blocks" }, { "location": "exchanges/json-rpc/endpoints/blocks/#blocks", "text": "", "title": "Blocks" }, { "location": "exchanges/json-rpc/endpoints/blocks/#get-a-block", "text": "", "title": "Get a Block" }, { "location": "exchanges/json-rpc/endpoints/blocks/#method", "text": "blocks.info", "title": "Method" }, { "location": "exchanges/json-rpc/endpoints/blocks/#body-parameters", "text": "Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.id string The identifier of the block to be retrieved. Yes", "title": "Body Parameters" }, { "location": "exchanges/json-rpc/endpoints/blocks/#request", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"blocks.info\" , \"params\" : { \"id\" : \"9336364900436444611\" } }", "title": "Request" }, { "location": "exchanges/json-rpc/endpoints/blocks/#response", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"id\" : \"9336364900436444611\" , \"version\" : 0 , \"height\" : 23 , \"previous\" : \"17180650139879860733\" , \"forged\" : { \"reward\" : 0 , \"fee\" : 0 , \"total\" : 0 }, \"payload\" : { \"hash\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"length\" : 0 }, \"generator\" : { \"username\" : \"genesis_43\" , \"address\" : \"AQBo4exLwyapRiDoDteh1fF2ctWWdxofSf\" , \"publicKey\" : \"034985f6f2167cc8c9df1204aaf6744bc97c0d7f3c07c43ee6c0978bc91b6c680e\" }, \"signature\" : \"3045022100b5c6ebb1c4c6694b82b98eea6c6eb889547908d8c1aff98d16f3f9df810fe34b02207266371081ffc6461da6fbb2811065aabe135c6e47863605416e6e5ddb4c7806\" , \"transactions\" : 0 , \"timestamp\" : { \"epoch\" : 50686634 , \"unix\" : 1540787834 , \"human\" : \"2018-10-29T04:37:14Z\" } } }", "title": "Response" }, { "location": "exchanges/json-rpc/endpoints/blocks/#error-response", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }", "title": "Error Response" }, { "location": "exchanges/json-rpc/endpoints/blocks/#get-the-latest-block", "text": "", "title": "Get the Latest Block" }, { "location": "exchanges/json-rpc/endpoints/blocks/#method_1", "text": "blocks.latest", "title": "Method" }, { "location": "exchanges/json-rpc/endpoints/blocks/#body-parameters_1", "text": "Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes", "title": "Body Parameters" }, { "location": "exchanges/json-rpc/endpoints/blocks/#request_1", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"blocks.latest\" }", "title": "Request" }, { "location": "exchanges/json-rpc/endpoints/blocks/#response_1", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"id\" : \"1453043075643523354\" , \"version\" : 0 , \"height\" : 29 , \"previous\" : \"14915069404850182157\" , \"forged\" : { \"reward\" : 0 , \"fee\" : 0 , \"total\" : 0 }, \"payload\" : { \"hash\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"length\" : 0 }, \"generator\" : { \"username\" : \"genesis_42\" , \"address\" : \"AcmXmomxpP8NahbbFivq32QmLuKFkTkqRg\" , \"publicKey\" : \"0311077c86a98b67850e7ed2c81775d094cf81c6991082ddc33fc7be5347dc765d\" }, \"signature\" : \"3045022100d94630fc328f5e70a4fa6134fa8aadbaab42eff15b22e91ae17438b6f28cfd3a022014df10ff42cea9d02e549353c24a6207c3de10d85b4f91742b44ffb4f303592e\" , \"transactions\" : 0 , \"timestamp\" : { \"epoch\" : 50686712 , \"unix\" : 1540787912 , \"human\" : \"2018-10-29T04:38:32Z\" } } }", "title": "Response" }, { "location": "exchanges/json-rpc/endpoints/blocks/#error-response_1", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }", "title": "Error Response" }, { "location": "exchanges/json-rpc/endpoints/blocks/#get-a-blocks-transactions", "text": "", "title": "Get a Blocks Transactions" }, { "location": "exchanges/json-rpc/endpoints/blocks/#method_2", "text": "blocks.transactions", "title": "Method" }, { "location": "exchanges/json-rpc/endpoints/blocks/#body-parameters_2", "text": "Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.id string The identifier of the block to be retrieved. Yes params.offset int The offset of transactions to be retrieved. Yes", "title": "Body Parameters" }, { "location": "exchanges/json-rpc/endpoints/blocks/#request_2", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"blocks.transactions\" , \"params\" : { \"id\" : \"17184958558311101492\" } }", "title": "Request" }, { "location": "exchanges/json-rpc/endpoints/blocks/#response_2", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"count\" : 153 , \"data\" : [ { \"id\" : \"db1aa687737858cc9199bfa336f9b1c035915c30aaee60b1e0f8afadfdb946bd\" , \"blockId\" : \"17184958558311101492\" , \"type\" : 0 , \"amount\" : 245098000000000 , \"fee\" : 0 , \"sender\" : \"APnhwwyTbMiykJwYbGhYjNgtHiVJDSEhSn\" , \"recipient\" : \"AHXtmB84sTZ9Zd35h9Y1vfFvPE2Xzqj8ri\" , \"signature\" : \"304402205fcb0677e06bde7aac3dc776665615f4b93ef8c3ed0fddecef9900e74fcb00f302206958a0c9868ea1b1f3d151bdfa92da1ce24de0b1fcd91933e64fb7971e92f48d\" , \"confirmations\" : 3 , \"timestamp\" : { \"epoch\" : 0 , \"unix\" : 1490101200 , \"human\" : \"2017-03-21T13:00:00Z\" } } ] } }", "title": "Response" }, { "location": "exchanges/json-rpc/endpoints/blocks/#error-response_2", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }", "title": "Error Response" }, { "location": "exchanges/json-rpc/endpoints/intro/", "text": "", "title": "JSON-RPC Endpoints" }, { "location": "exchanges/json-rpc/endpoints/transactions/", "text": "Transactions \u00b6 Get a Transaction \u00b6 Method \u00b6 transaction.info Body Parameters \u00b6 Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.id string The identifier of the transaction to be retrieved. Yes Request \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"transactions.info\" , \"params\" : { \"id\" : \"49a4cc2b931e75da4676c5b06649543d3ea30f1097e944549e2ab3d67bc91e6a\" } } Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"id\" : \"49a4cc2b931e75da4676c5b06649543d3ea30f1097e944549e2ab3d67bc91e6a\" , \"blockId\" : \"1957735382338577043\" , \"type\" : 0 , \"amount\" : 1000000000 , \"fee\" : 10000000 , \"sender\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" , \"recipient\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" , \"signature\" : \"304502210084484fc57bd1c0af1e6bf2fc79e1d5c210b29d7651e3482cc764d2160bbd887a0220776362194a30f4c04365061344dd4b4ac2cc6f5efc479afcda07d26be9621e04\" , \"confirmations\" : 1 , \"timestamp\" : { \"epoch\" : 50271515 , \"unix\" : 1540372715 , \"human\" : \"2018-10-24T09:18:35Z\" } } } Error Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } } Broadcast Transactions \u00b6 In order to broadcast transactions via the JSON-RPC they also need to be created through it. If you are looking to just broadcast any transactions you should take a look at Transactions for the public API. Method \u00b6 transactions.broadcast Body Parameters \u00b6 Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.transactions array The list of transactions to be broadcast. Yes Request \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"transactions.broadcast\" , \"params\" : { \"id\" : \"49a4cc2b931e75da4676c5b06649543d3ea30f1097e944549e2ab3d67bc91e6a\" } } Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"id\" : \"49a4cc2b931e75da4676c5b06649543d3ea30f1097e944549e2ab3d67bc91e6a\" , \"signature\" : \"304502210084484fc57bd1c0af1e6bf2fc79e1d5c210b29d7651e3482cc764d2160bbd887a0220776362194a30f4c04365061344dd4b4ac2cc6f5efc479afcda07d26be9621e04\" , \"timestamp\" : 50271515 , \"type\" : 0 , \"fee\" : 10000000 , \"senderPublicKey\" : \"03287bfebba4c7881a0509717e71b34b63f31e40021c321f89ae04f84be6d6ac37\" , \"amount\" : 1000000000 , \"recipientId\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" } } Error Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } } Create a Transaction \u00b6 Method \u00b6 transactions.create Body Parameters \u00b6 Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.recipientId string The address of the recipient. Yes params.amount string The amount to be send. Yes params.passphrase string The passphrase of the sender. Yes params.vendorField string Optional field with custom content. No params.fee string Transaction Fee. If not set the average fee is read from the network. No Parameter params.fee is optional. If the parameter is not set, transaction is created by using the current public network average fee. Make sure to check the network for average fee values , before signing and sending a transaction. This is to handle edge case of them being higher than the current static ones. Request \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"transactions.create\" , \"params\" : { \"passphrase\" : \"this is a top secret passphrase\" , \"amount\" : 1000000000 , \"recipientId\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" } } Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"id\" : \"58f4f8ed866d2c6a42fc2b48d49fc5c949af6768b55d307376aaac61f930d8b6\" , \"signature\" : \"304402201ace9afcaf9d0ec64a31fd98c589767c76b5360d5b22dfe3cde2dfffdfef61dc022026d276a6140e6abbd80775541479cc71cf52590895bd24c0c577a9c57ecae581\" , \"timestamp\" : 50686854 , \"type\" : 0 , \"fee\" : 10000000 , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"amount\" : 1000000000 , \"recipientId\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" } } Error Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } } Create a Transaction from a BIP38 \u00b6 Method \u00b6 transactions.list Body Parameters \u00b6 Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.recipientId string The address of the recipient. Yes params.amount string The amount to be send. Yes params.bip38 string The bip38 of the sender. Yes params.userId string The identifier of the sender. Yes params.vendorField string Optional field with custom content. No params.fee string Transaction Fee. If not set the average fee is read from the network. No Parameter params.fee is optional. If the parameter is not set, transaction is created by using the current public network average fee. Make sure to check the network for average fee values , before signing and sending a transaction. This is to handle edge case of them being higher than the current static ones. Request \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"transactions.bip38.create\" , \"params\" : { \"bip38\" : \"this is a top secret passphrase\" , \"userId\" : \"123\" , \"amount\" : 1000000000 , \"recipientId\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" } } Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"id\" : \"729d8f1974bd1eb517619fe9a4c45c3e769f49bbe1b682237ef3f049038c5421\" , \"signature\" : \"304402207a4877d3515b2dc3c2d8bc337b767cea62718e80d4b9ba02d8f2f873c82e2987022067951e8aa731fed8223b650419c29ef7e71460807920604ea23d3c2872328217\" , \"timestamp\" : 50686826 , \"type\" : 0 , \"fee\" : 10000000 , \"senderPublicKey\" : \"022cf1c9de60c22c0b5a138b6545777cb2edaf82fe3906faa345580352000f84b6\" , \"amount\" : 1000000000 , \"recipientId\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" } } Error Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }", "title": "Transactions" }, { "location": "exchanges/json-rpc/endpoints/transactions/#transactions", "text": "", "title": "Transactions" }, { "location": "exchanges/json-rpc/endpoints/transactions/#get-a-transaction", "text": "", "title": "Get a Transaction" }, { "location": "exchanges/json-rpc/endpoints/transactions/#method", "text": "transaction.info", "title": "Method" }, { "location": "exchanges/json-rpc/endpoints/transactions/#body-parameters", "text": "Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.id string The identifier of the transaction to be retrieved. Yes", "title": "Body Parameters" }, { "location": "exchanges/json-rpc/endpoints/transactions/#request", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"transactions.info\" , \"params\" : { \"id\" : \"49a4cc2b931e75da4676c5b06649543d3ea30f1097e944549e2ab3d67bc91e6a\" } }", "title": "Request" }, { "location": "exchanges/json-rpc/endpoints/transactions/#response", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"id\" : \"49a4cc2b931e75da4676c5b06649543d3ea30f1097e944549e2ab3d67bc91e6a\" , \"blockId\" : \"1957735382338577043\" , \"type\" : 0 , \"amount\" : 1000000000 , \"fee\" : 10000000 , \"sender\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" , \"recipient\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" , \"signature\" : \"304502210084484fc57bd1c0af1e6bf2fc79e1d5c210b29d7651e3482cc764d2160bbd887a0220776362194a30f4c04365061344dd4b4ac2cc6f5efc479afcda07d26be9621e04\" , \"confirmations\" : 1 , \"timestamp\" : { \"epoch\" : 50271515 , \"unix\" : 1540372715 , \"human\" : \"2018-10-24T09:18:35Z\" } } }", "title": "Response" }, { "location": "exchanges/json-rpc/endpoints/transactions/#error-response", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }", "title": "Error Response" }, { "location": "exchanges/json-rpc/endpoints/transactions/#broadcast-transactions", "text": "In order to broadcast transactions via the JSON-RPC they also need to be created through it. If you are looking to just broadcast any transactions you should take a look at Transactions for the public API.", "title": "Broadcast Transactions" }, { "location": "exchanges/json-rpc/endpoints/transactions/#method_1", "text": "transactions.broadcast", "title": "Method" }, { "location": "exchanges/json-rpc/endpoints/transactions/#body-parameters_1", "text": "Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.transactions array The list of transactions to be broadcast. Yes", "title": "Body Parameters" }, { "location": "exchanges/json-rpc/endpoints/transactions/#request_1", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"transactions.broadcast\" , \"params\" : { \"id\" : \"49a4cc2b931e75da4676c5b06649543d3ea30f1097e944549e2ab3d67bc91e6a\" } }", "title": "Request" }, { "location": "exchanges/json-rpc/endpoints/transactions/#response_1", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"id\" : \"49a4cc2b931e75da4676c5b06649543d3ea30f1097e944549e2ab3d67bc91e6a\" , \"signature\" : \"304502210084484fc57bd1c0af1e6bf2fc79e1d5c210b29d7651e3482cc764d2160bbd887a0220776362194a30f4c04365061344dd4b4ac2cc6f5efc479afcda07d26be9621e04\" , \"timestamp\" : 50271515 , \"type\" : 0 , \"fee\" : 10000000 , \"senderPublicKey\" : \"03287bfebba4c7881a0509717e71b34b63f31e40021c321f89ae04f84be6d6ac37\" , \"amount\" : 1000000000 , \"recipientId\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" } }", "title": "Response" }, { "location": "exchanges/json-rpc/endpoints/transactions/#error-response_1", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }", "title": "Error Response" }, { "location": "exchanges/json-rpc/endpoints/transactions/#create-a-transaction", "text": "", "title": "Create a Transaction" }, { "location": "exchanges/json-rpc/endpoints/transactions/#method_2", "text": "transactions.create", "title": "Method" }, { "location": "exchanges/json-rpc/endpoints/transactions/#body-parameters_2", "text": "Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.recipientId string The address of the recipient. Yes params.amount string The amount to be send. Yes params.passphrase string The passphrase of the sender. Yes params.vendorField string Optional field with custom content. No params.fee string Transaction Fee. If not set the average fee is read from the network. No Parameter params.fee is optional. If the parameter is not set, transaction is created by using the current public network average fee. Make sure to check the network for average fee values , before signing and sending a transaction. This is to handle edge case of them being higher than the current static ones.", "title": "Body Parameters" }, { "location": "exchanges/json-rpc/endpoints/transactions/#request_2", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"transactions.create\" , \"params\" : { \"passphrase\" : \"this is a top secret passphrase\" , \"amount\" : 1000000000 , \"recipientId\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" } }", "title": "Request" }, { "location": "exchanges/json-rpc/endpoints/transactions/#response_2", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"id\" : \"58f4f8ed866d2c6a42fc2b48d49fc5c949af6768b55d307376aaac61f930d8b6\" , \"signature\" : \"304402201ace9afcaf9d0ec64a31fd98c589767c76b5360d5b22dfe3cde2dfffdfef61dc022026d276a6140e6abbd80775541479cc71cf52590895bd24c0c577a9c57ecae581\" , \"timestamp\" : 50686854 , \"type\" : 0 , \"fee\" : 10000000 , \"senderPublicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"amount\" : 1000000000 , \"recipientId\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" } }", "title": "Response" }, { "location": "exchanges/json-rpc/endpoints/transactions/#error-response_2", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }", "title": "Error Response" }, { "location": "exchanges/json-rpc/endpoints/transactions/#create-a-transaction-from-a-bip38", "text": "", "title": "Create a Transaction from a BIP38" }, { "location": "exchanges/json-rpc/endpoints/transactions/#method_3", "text": "transactions.list", "title": "Method" }, { "location": "exchanges/json-rpc/endpoints/transactions/#body-parameters_3", "text": "Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.recipientId string The address of the recipient. Yes params.amount string The amount to be send. Yes params.bip38 string The bip38 of the sender. Yes params.userId string The identifier of the sender. Yes params.vendorField string Optional field with custom content. No params.fee string Transaction Fee. If not set the average fee is read from the network. No Parameter params.fee is optional. If the parameter is not set, transaction is created by using the current public network average fee. Make sure to check the network for average fee values , before signing and sending a transaction. This is to handle edge case of them being higher than the current static ones.", "title": "Body Parameters" }, { "location": "exchanges/json-rpc/endpoints/transactions/#request_3", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"transactions.bip38.create\" , \"params\" : { \"bip38\" : \"this is a top secret passphrase\" , \"userId\" : \"123\" , \"amount\" : 1000000000 , \"recipientId\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" } }", "title": "Request" }, { "location": "exchanges/json-rpc/endpoints/transactions/#response_3", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"id\" : \"729d8f1974bd1eb517619fe9a4c45c3e769f49bbe1b682237ef3f049038c5421\" , \"signature\" : \"304402207a4877d3515b2dc3c2d8bc337b767cea62718e80d4b9ba02d8f2f873c82e2987022067951e8aa731fed8223b650419c29ef7e71460807920604ea23d3c2872328217\" , \"timestamp\" : 50686826 , \"type\" : 0 , \"fee\" : 10000000 , \"senderPublicKey\" : \"022cf1c9de60c22c0b5a138b6545777cb2edaf82fe3906faa345580352000f84b6\" , \"amount\" : 1000000000 , \"recipientId\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" } }", "title": "Response" }, { "location": "exchanges/json-rpc/endpoints/transactions/#error-response_3", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }", "title": "Error Response" }, { "location": "exchanges/json-rpc/endpoints/wallets/", "text": "Wallets \u00b6 Get a Wallet \u00b6 Method \u00b6 wallets.info Body Parameters \u00b6 Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.address string The address of the wallet to be retrieved. Yes Request \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"wallets.info\" , \"params\" : { \"address\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" } } Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"address\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" , \"publicKey\" : \"03287bfebba4c7881a0509717e71b34b63f31e40021c321f89ae04f84be6d6ac37\" , \"secondPublicKey\" : null , \"balance\" : 245100000000000 , \"isDelegate\" : true } } Error Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } } Get a Wallets Transactions \u00b6 Method \u00b6 wallets.transactions Body Parameters \u00b6 Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.address string The address of the transactions to be retrieved. Yes params.offset int The offset of transactions to be retrieved. Yes Request \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"wallets.transactions\" , \"params\" : { \"address\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" } } Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"count\" : 153 , \"data\" : [ { \"id\" : \"db1aa687737858cc9199bfa336f9b1c035915c30aaee60b1e0f8afadfdb946bd\" , \"blockId\" : \"17184958558311101492\" , \"type\" : 0 , \"amount\" : 245098000000000 , \"fee\" : 0 , \"sender\" : \"APnhwwyTbMiykJwYbGhYjNgtHiVJDSEhSn\" , \"recipient\" : \"AHXtmB84sTZ9Zd35h9Y1vfFvPE2Xzqj8ri\" , \"signature\" : \"304402205fcb0677e06bde7aac3dc776665615f4b93ef8c3ed0fddecef9900e74fcb00f302206958a0c9868ea1b1f3d151bdfa92da1ce24de0b1fcd91933e64fb7971e92f48d\" , \"confirmations\" : 3 , \"timestamp\" : { \"epoch\" : 0 , \"unix\" : 1490101200 , \"human\" : \"2017-03-21T13:00:00Z\" } } ] } } Error Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } } Create a Wallet \u00b6 Method \u00b6 wallets.create Body Parameters \u00b6 Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.passphrase string The passphrase of the wallet to be created. Yes Request \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"wallets.create\" , \"params\" : { \"passphrase\" : \"this is a top secret passphrase\" } } Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"publicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"address\" : \"AGeYmgbg2LgGxRW2vNNJvQ88PknEJsYizC\" } } Error Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } } Get a BIP38 Wallet \u00b6 Method \u00b6 wallets.bip38.info Body Parameters \u00b6 Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.userId string The identifier of the wallet to be retrieved. Yes Request \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"wallets.bip38.info\" , \"params\" : { \"userId\" : \"123\" } } Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"wif\" : \"6PYTWME2aAJTx2NcRyS33zYrS79Hk7KiNbHZmGQWUYJYKWGZn4N36AdUMf\" } } Error Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } } Create a BIP38 Wallet \u00b6 Method \u00b6 wallets.bip38.create Body Parameters \u00b6 Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.bip38 string The bip38 of the wallet to be retrieved. Yes params.userId string The identifier of the wallet to be retrieved. Yes Request \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"wallets.bip38.create\" , \"params\" : { \"userId\" : \"123\" , \"bip38\" : \"this is a top secret passphrase\" } } Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"publicKey\" : \"022cf1c9de60c22c0b5a138b6545777cb2edaf82fe3906faa345580352000f84b6\" , \"address\" : \"AL4z4quXFVPR4ybDHeJ67HfSEmFrguQ6e5\" , \"wif\" : \"6PYTWME2aAJTx2NcRyS33zYrS79Hk7KiNbHZmGQWUYJYKWGZn4N36AdUMf\" } } Error Response \u00b6 { \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }", "title": "Wallets" }, { "location": "exchanges/json-rpc/endpoints/wallets/#wallets", "text": "", "title": "Wallets" }, { "location": "exchanges/json-rpc/endpoints/wallets/#get-a-wallet", "text": "", "title": "Get a Wallet" }, { "location": "exchanges/json-rpc/endpoints/wallets/#method", "text": "wallets.info", "title": "Method" }, { "location": "exchanges/json-rpc/endpoints/wallets/#body-parameters", "text": "Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.address string The address of the wallet to be retrieved. Yes", "title": "Body Parameters" }, { "location": "exchanges/json-rpc/endpoints/wallets/#request", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"wallets.info\" , \"params\" : { \"address\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" } }", "title": "Request" }, { "location": "exchanges/json-rpc/endpoints/wallets/#response", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"address\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" , \"publicKey\" : \"03287bfebba4c7881a0509717e71b34b63f31e40021c321f89ae04f84be6d6ac37\" , \"secondPublicKey\" : null , \"balance\" : 245100000000000 , \"isDelegate\" : true } }", "title": "Response" }, { "location": "exchanges/json-rpc/endpoints/wallets/#error-response", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }", "title": "Error Response" }, { "location": "exchanges/json-rpc/endpoints/wallets/#get-a-wallets-transactions", "text": "", "title": "Get a Wallets Transactions" }, { "location": "exchanges/json-rpc/endpoints/wallets/#method_1", "text": "wallets.transactions", "title": "Method" }, { "location": "exchanges/json-rpc/endpoints/wallets/#body-parameters_1", "text": "Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.address string The address of the transactions to be retrieved. Yes params.offset int The offset of transactions to be retrieved. Yes", "title": "Body Parameters" }, { "location": "exchanges/json-rpc/endpoints/wallets/#request_1", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"wallets.transactions\" , \"params\" : { \"address\" : \"ANBkoGqWeTSiaEVgVzSKZd3jS7UWzv9PSo\" } }", "title": "Request" }, { "location": "exchanges/json-rpc/endpoints/wallets/#response_1", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"count\" : 153 , \"data\" : [ { \"id\" : \"db1aa687737858cc9199bfa336f9b1c035915c30aaee60b1e0f8afadfdb946bd\" , \"blockId\" : \"17184958558311101492\" , \"type\" : 0 , \"amount\" : 245098000000000 , \"fee\" : 0 , \"sender\" : \"APnhwwyTbMiykJwYbGhYjNgtHiVJDSEhSn\" , \"recipient\" : \"AHXtmB84sTZ9Zd35h9Y1vfFvPE2Xzqj8ri\" , \"signature\" : \"304402205fcb0677e06bde7aac3dc776665615f4b93ef8c3ed0fddecef9900e74fcb00f302206958a0c9868ea1b1f3d151bdfa92da1ce24de0b1fcd91933e64fb7971e92f48d\" , \"confirmations\" : 3 , \"timestamp\" : { \"epoch\" : 0 , \"unix\" : 1490101200 , \"human\" : \"2017-03-21T13:00:00Z\" } } ] } }", "title": "Response" }, { "location": "exchanges/json-rpc/endpoints/wallets/#error-response_1", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }", "title": "Error Response" }, { "location": "exchanges/json-rpc/endpoints/wallets/#create-a-wallet", "text": "", "title": "Create a Wallet" }, { "location": "exchanges/json-rpc/endpoints/wallets/#method_2", "text": "wallets.create", "title": "Method" }, { "location": "exchanges/json-rpc/endpoints/wallets/#body-parameters_2", "text": "Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.passphrase string The passphrase of the wallet to be created. Yes", "title": "Body Parameters" }, { "location": "exchanges/json-rpc/endpoints/wallets/#request_2", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"wallets.create\" , \"params\" : { \"passphrase\" : \"this is a top secret passphrase\" } }", "title": "Request" }, { "location": "exchanges/json-rpc/endpoints/wallets/#response_2", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"publicKey\" : \"034151a3ec46b5670a682b0a63394f863587d1bc97483b1b6c70eb58e7f0aed192\" , \"address\" : \"AGeYmgbg2LgGxRW2vNNJvQ88PknEJsYizC\" } }", "title": "Response" }, { "location": "exchanges/json-rpc/endpoints/wallets/#error-response_2", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }", "title": "Error Response" }, { "location": "exchanges/json-rpc/endpoints/wallets/#get-a-bip38-wallet", "text": "", "title": "Get a BIP38 Wallet" }, { "location": "exchanges/json-rpc/endpoints/wallets/#method_3", "text": "wallets.bip38.info", "title": "Method" }, { "location": "exchanges/json-rpc/endpoints/wallets/#body-parameters_3", "text": "Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.userId string The identifier of the wallet to be retrieved. Yes", "title": "Body Parameters" }, { "location": "exchanges/json-rpc/endpoints/wallets/#request_3", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"wallets.bip38.info\" , \"params\" : { \"userId\" : \"123\" } }", "title": "Request" }, { "location": "exchanges/json-rpc/endpoints/wallets/#response_3", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"wif\" : \"6PYTWME2aAJTx2NcRyS33zYrS79Hk7KiNbHZmGQWUYJYKWGZn4N36AdUMf\" } }", "title": "Response" }, { "location": "exchanges/json-rpc/endpoints/wallets/#error-response_3", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }", "title": "Error Response" }, { "location": "exchanges/json-rpc/endpoints/wallets/#create-a-bip38-wallet", "text": "", "title": "Create a BIP38 Wallet" }, { "location": "exchanges/json-rpc/endpoints/wallets/#method_4", "text": "wallets.bip38.create", "title": "Method" }, { "location": "exchanges/json-rpc/endpoints/wallets/#body-parameters_4", "text": "Name Type Description Required jsonrpc string The protocol version. Yes id string The identifier of the request. Yes method string The method name. Yes params object The parameters of the request. Yes params.bip38 string The bip38 of the wallet to be retrieved. Yes params.userId string The identifier of the wallet to be retrieved. Yes", "title": "Body Parameters" }, { "location": "exchanges/json-rpc/endpoints/wallets/#request_4", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"method\" : \"wallets.bip38.create\" , \"params\" : { \"userId\" : \"123\" , \"bip38\" : \"this is a top secret passphrase\" } }", "title": "Request" }, { "location": "exchanges/json-rpc/endpoints/wallets/#response_4", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"result\" : { \"publicKey\" : \"022cf1c9de60c22c0b5a138b6545777cb2edaf82fe3906faa345580352000f84b6\" , \"address\" : \"AL4z4quXFVPR4ybDHeJ67HfSEmFrguQ6e5\" , \"wif\" : \"6PYTWME2aAJTx2NcRyS33zYrS79Hk7KiNbHZmGQWUYJYKWGZn4N36AdUMf\" } }", "title": "Response" }, { "location": "exchanges/json-rpc/endpoints/wallets/#error-response_4", "text": "{ \"jsonrpc\" : \"2.0\" , \"id\" : \"unique-request-id\" , \"error\" : { \"code\" : \"unique-error-code\" , \"message\" : \"descriptive-error-message\" , \"data\" : \"detailed-error-information\" } }", "title": "Error Response" }, { "location": "exchanges/node-installation/baremetal-instructions/", "text": "BareMetal or VM Install (APN | Mainnet) \u00b6 Installation Using the Official Installation Script \u00b6 On a fresh Ubuntu installation, follow these commands. 1. Update and Upgrade \u00b6 Always ensure your server has the latest set of updates, due to performance and security considerations. sudo apt-get update && sudo apt-get upgrade 2. Add a New User and Add to the Sudo Group \u00b6 It is best to create a specific SXP-related user, which can later own the required databases as well. # add 'solar' user sudo adduser solar sudo usermod -aG sudo solar 3. Switch to the New User \u00b6 Switch to the new user account and go to the base directory. # change to solar user and solar directory sudo su - solar cd ~ 4. Install Dependencies and Solar Core \u00b6 We will use Solar installer script that will install all of the necessary dependencies, Solar Core onto your server and publish configuration files for it. To install essentials run this command. bash < ( curl -s https://raw.githubusercontent.com/solar-network/core/main/install.sh ) You will be asked to input your current users password for sudo privileges. Write or paste it and press enter to start installation process. Process might take a while, don't interrupt it and wait for it to finish. 5. Selecting Solar Core Network \u00b6 Once installation of dependencies and Solar Core is finished you will need to select on which network you wish to operate, since we are setting mainnet node select it. This can be achieved by pressing up or down arrow keys and confirming selection with enter . After you made your selection you will need to confirm by pressing y and confirm with enter . 6. Configuring Solar Core Database \u00b6 Last step of the Solar Core essential configuration is to configure database parameters. You will be presented with a prompt: Would you like to configure the database? [ y/N ] : Press y and confirm with enter . You can input any custom database credentials you want to use or use the one provided below: Enter the database username: solar Enter the database password: password Enter the database name: solar_mainnet This will create PostgreSQL role and database to be used for storing blockchain data. 7. Starting Solar Relay Process \u00b6 To start Solar relay process and with it synchronization process with Solar blockchain we need to start relay process with our integrated CLI: solar relay:start If the process has started you will get a message: Starting solar-relay... done All of the CLI commands with a description can be viewed in our Core CLI documentation or by executing the solar help command. 8. Checking to See if Everything Is Working \u00b6 Now we want to see if the Solar relay process has started the synchronization process you can do that by running one of these two commands solar relay:log or pm2 logs If the process has started you will see a lot of messages like this (with actual data) [ YYYY-DD-MM hh:mm:ss ][ DEBUG ] : Delegate <delegate name> ( <public key> ) allowed to forge block < #> \ud83d\udc4d Synchronization of the blockchain can take upwards of 10 hours so let it run, once its synchronized allowed to forge block messages will only pop-up every 8 seconds. A single round consists of 51 delegates each forging a single block. Ensure you properly restart the node process when editing your .env file. Use the --update-env flag, for example: pm2 restart all --update-env Next Steps \u00b6 Please note that API will be available when the node has synced with the network, which can take up to 15 hours depending on your network speed. Now that the relay node has been configured, you should head over to the JSON-RPC Getting Started or look at relevant Public API endpoints related to blockchain functionality to manage your wallets and transactions. Notes \u00b6 Please read the documentation pages for all of our SXP SDK clients and cryptography libraries (offered in many programming languages). Also, read the API documentation.", "title": "Relay node installation instructions (Bare Metal or VM)" }, { "location": "exchanges/node-installation/baremetal-instructions/#baremetal-or-vm-install-apn-mainnet", "text": "", "title": "BareMetal or VM Install (APN | Mainnet)" }, { "location": "exchanges/node-installation/baremetal-instructions/#installation-using-the-official-installation-script", "text": "On a fresh Ubuntu installation, follow these commands.", "title": "Installation Using the Official Installation Script" }, { "location": "exchanges/node-installation/baremetal-instructions/#1-update-and-upgrade", "text": "Always ensure your server has the latest set of updates, due to performance and security considerations. sudo apt-get update && sudo apt-get upgrade", "title": "1. Update and Upgrade" }, { "location": "exchanges/node-installation/baremetal-instructions/#2-add-a-new-user-and-add-to-the-sudo-group", "text": "It is best to create a specific SXP-related user, which can later own the required databases as well. # add 'solar' user sudo adduser solar sudo usermod -aG sudo solar", "title": "2. Add a New User and Add to the Sudo Group" }, { "location": "exchanges/node-installation/baremetal-instructions/#3-switch-to-the-new-user", "text": "Switch to the new user account and go to the base directory. # change to solar user and solar directory sudo su - solar cd ~", "title": "3. Switch to the New User" }, { "location": "exchanges/node-installation/baremetal-instructions/#4-install-dependencies-and-solar-core", "text": "We will use Solar installer script that will install all of the necessary dependencies, Solar Core onto your server and publish configuration files for it. To install essentials run this command. bash < ( curl -s https://raw.githubusercontent.com/solar-network/core/main/install.sh ) You will be asked to input your current users password for sudo privileges. Write or paste it and press enter to start installation process. Process might take a while, don't interrupt it and wait for it to finish.", "title": "4. Install Dependencies and Solar Core" }, { "location": "exchanges/node-installation/baremetal-instructions/#5-selecting-solar-core-network", "text": "Once installation of dependencies and Solar Core is finished you will need to select on which network you wish to operate, since we are setting mainnet node select it. This can be achieved by pressing up or down arrow keys and confirming selection with enter . After you made your selection you will need to confirm by pressing y and confirm with enter .", "title": "5. Selecting Solar Core Network" }, { "location": "exchanges/node-installation/baremetal-instructions/#6-configuring-solar-core-database", "text": "Last step of the Solar Core essential configuration is to configure database parameters. You will be presented with a prompt: Would you like to configure the database? [ y/N ] : Press y and confirm with enter . You can input any custom database credentials you want to use or use the one provided below: Enter the database username: solar Enter the database password: password Enter the database name: solar_mainnet This will create PostgreSQL role and database to be used for storing blockchain data.", "title": "6. Configuring Solar Core Database" }, { "location": "exchanges/node-installation/baremetal-instructions/#7-starting-solar-relay-process", "text": "To start Solar relay process and with it synchronization process with Solar blockchain we need to start relay process with our integrated CLI: solar relay:start If the process has started you will get a message: Starting solar-relay... done All of the CLI commands with a description can be viewed in our Core CLI documentation or by executing the solar help command.", "title": "7. Starting Solar Relay Process" }, { "location": "exchanges/node-installation/baremetal-instructions/#8-checking-to-see-if-everything-is-working", "text": "Now we want to see if the Solar relay process has started the synchronization process you can do that by running one of these two commands solar relay:log or pm2 logs If the process has started you will see a lot of messages like this (with actual data) [ YYYY-DD-MM hh:mm:ss ][ DEBUG ] : Delegate <delegate name> ( <public key> ) allowed to forge block < #> \ud83d\udc4d Synchronization of the blockchain can take upwards of 10 hours so let it run, once its synchronized allowed to forge block messages will only pop-up every 8 seconds. A single round consists of 51 delegates each forging a single block. Ensure you properly restart the node process when editing your .env file. Use the --update-env flag, for example: pm2 restart all --update-env", "title": "8. Checking to See if Everything Is Working" }, { "location": "exchanges/node-installation/baremetal-instructions/#next-steps", "text": "Please note that API will be available when the node has synced with the network, which can take up to 15 hours depending on your network speed. Now that the relay node has been configured, you should head over to the JSON-RPC Getting Started or look at relevant Public API endpoints related to blockchain functionality to manage your wallets and transactions.", "title": "Next Steps" }, { "location": "exchanges/node-installation/baremetal-instructions/#notes", "text": "Please read the documentation pages for all of our SXP SDK clients and cryptography libraries (offered in many programming languages). Also, read the API documentation.", "title": "Notes" }, { "location": "exchanges/node-installation/hardware-requirements/", "text": "Hardware Requirements \u00b6 A Relay Node is a full node in the Solar network; it maintains a complete copy of the ledger (blockchain). These nodes serve as Public API endpoint, use an internal service discovery mechanism to locate other nodes and keep each other in sync. Recommended Hardware Requirements \u00b6 Relay Specification Minimum Recommended CPUs 2 4 RAM 4GB 8GB HDD 80GB 100GB - 120GB Supported OS Release Version(s) Ubuntu 18.x / 20.x Ubuntu 16.x and older is no longer supported. SXP Nodes execute many query intensive operations. The most cost-effective approach for running a high-performance node is choosing SSD over HDD. Increasing the total RAM improves cache performance. Configuration Requirements \u00b6 Stable internet connection Access to multiple open ports (actual ports may be configured) Service Port Required Enabled by default Documentation p2p 6001 \u2705 \u2705 reference public API 6003 \u274c \u2705 reference webhook 6004 \u274c \u274c reference", "title": "Hardware Requirements" }, { "location": "exchanges/node-installation/hardware-requirements/#hardware-requirements", "text": "A Relay Node is a full node in the Solar network; it maintains a complete copy of the ledger (blockchain). These nodes serve as Public API endpoint, use an internal service discovery mechanism to locate other nodes and keep each other in sync.", "title": "Hardware Requirements" }, { "location": "exchanges/node-installation/hardware-requirements/#recommended-hardware-requirements", "text": "Relay Specification Minimum Recommended CPUs 2 4 RAM 4GB 8GB HDD 80GB 100GB - 120GB Supported OS Release Version(s) Ubuntu 18.x / 20.x Ubuntu 16.x and older is no longer supported. SXP Nodes execute many query intensive operations. The most cost-effective approach for running a high-performance node is choosing SSD over HDD. Increasing the total RAM improves cache performance.", "title": "Recommended Hardware Requirements" }, { "location": "exchanges/node-installation/hardware-requirements/#configuration-requirements", "text": "Stable internet connection Access to multiple open ports (actual ports may be configured) Service Port Required Enabled by default Documentation p2p 6001 \u2705 \u2705 reference public API 6003 \u274c \u2705 reference webhook 6004 \u274c \u274c reference", "title": "Configuration Requirements" }] }